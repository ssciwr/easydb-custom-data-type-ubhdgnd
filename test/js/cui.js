// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var $elementIsInDOM, addToArray, alert_dump, assert, assertImplements, assertInstanceOf, atou, compareIndex, copyObject, dump, elementGetPosition, escapeRegExp, findInArray, getCoordinatesFromEvent, getFloat, getInt, getIntOrString, getMs, getObjectClass, getObjectClassRegexp, idxInArray, index, isBoolean, isContent, isDeferred, isElement, isEmpty, isFalse, isFloat, isInteger, isNull, isNumber, isPosInt, isPromise, isString, isTrue, isUndef, moveInArray, pushOntoArray, removeFromArray, toCamel, toClass, toDash, toDot, toHtml, utoa, xor;

assert = function(condition, caller, message, debug_output) {
  var args, e, error, key, msg, parms, stack, value;
  if (!CUI.defaults.asserts) {
    return;
  }
  if (condition) {
    return;
  }
  try {
    e = new Error('dummy');
    stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@').replace().split('\n');
  } catch (error) {
    e = error;
    stack = "Can't get callstack in this browser. Try using Stacktrace.js";
  }
  parms = [];
  if (debug_output) {
    args = [caller + ":"];
    for (key in debug_output) {
      value = debug_output[key];
      args.push(key + ":");
      parms.push(key);
      args.push(value);
    }
    console.debug.apply(console, args);
  }
  if (parms.length) {
    msg = caller + "(" + (parms.join(",")) + ")";
  } else {
    msg = caller;
  }
  if (message) {
    msg += ": " + message;
  }
  switch (CUI.defaults.asserts_alert) {
    case 'debugger':
      debugger;
      break;
    case 'js':
      alert(msg);
      break;
    case 'cui':
      CUI.problem({
        text: msg
      });
      break;
  }
  if (CUI.__in_error) {
    console.error("Another assert occurred, cannot throw Error to avoid loop: ", msg);
    return;
  }
  CUI.__in_error = true;
  CUI.setTimeout((function(_this) {
    return function() {
      return CUI.__in_error = false;
    };
  })(this));
  throw new Error(msg);
};

assertImplements = function(inst, methods) {
  var j, len, method, needs;
  if (!CUI.defaults.asserts) {
    return;
  }
  needs = [];
  for (j = 0, len = methods.length; j < len; j++) {
    method = methods[j];
    if (!CUI.isFunction(inst[method])) {
      needs.push(method);
    }
  }
  assert(needs.length === 0, "" + (getObjectClass(inst)), "Needs implementations for " + (needs.join(', ')) + ".", {
    instance: inst
  });
};

assertInstanceOf = function(variableName, classClass, opts, value) {
  var cn, cond, fn;
  if (value == null) {
    value = void 0;
  }
  if (!CUI.defaults.asserts) {
    return;
  }
  if (!CUI.isFunction(classClass) && !classClass === "PlainObject") {
    throw "assertInstanceOf: class is not a Function";
  }
  if (value === void 0) {
    value = opts[variableName];
    assert(CUI.isPlainObject(opts), "new " + arguments.callee.caller.name, "opts needs to be PlainObject but it is " + (getObjectClass(opts)) + ".", {
      opts: opts
    });
  }
  if (classClass === "Array") {
    cn = "Array";
    cond = value instanceof Array;
  } else if (classClass === "Integer") {
    cn = "Integer";
    cond = isInteger(value);
  } else if (classClass === "PlainObject") {
    cn = "PlainObject";
    cond = CUI.isPlainObject(value);
  } else if ((new String) instanceof classClass) {
    cn = "String";
    cond = isString(value);
  } else if ((new Boolean) instanceof classClass) {
    cn = "Boolean";
    cond = value === true || value === false;
  } else {
    cond = value instanceof classClass;
    cn = classClass.name;
  }
  if (cond) {
    return;
  }
  fn = arguments.callee.caller.name;
  if (!fn) {
    fn = getObjectClass(this);
  }
  assert(false, "new " + fn, "opts." + variableName + " needs to be instance of " + cn + " but it is " + (getObjectClass(value)) + ".", {
    opts: opts,
    value: value,
    classClass: classClass
  });
};

$elementIsInDOM = function($el) {
  return $el.parents().last().is("html");
};

getCoordinatesFromEvent = function(ev) {
  var coord;
  coord = {
    pageX: ev.pageX(),
    pageY: ev.pageY()
  };
  if (ev.scrollPageY) {
    coord.pageY += ev.scrollPageY;
  }
  if (ev.scrollPageX) {
    coord.pageX += ev.scrollPageX;
  }
  return coord;
};

elementGetPosition = function(coordinates, el) {
  var position, rect;
  rect = DOM.getRect(el);
  position = {
    left: coordinates.pageX - rect.left,
    top: coordinates.pageY - rect.top
  };
  if (el !== document.body) {
    position.left += el.scrollLeft;
    position.top += el.scrollTop;
  }
  return position;
};

getObjectClassRegexp = /^function\s*(\w+)/;

getObjectClass = function(obj) {
  var arr, str;
  if (!obj || !obj.constructor) {
    return void 0;
  }
  if (CUI.browser.ie) {
    str = obj.constructor.toString().trim();
    if (str.substr(0, 8) === "function") {
      arr = str.match(getObjectClassRegexp);
      if (arr && arr.length === 2) {
        return arr[1];
      } else {
        return void 0;
      }
    } else {
      return void 0;
    }
  } else {
    return obj.constructor.name;
  }
};

isUndef = function(obj) {
  return typeof obj === "undefined";
};

isNull = function(obj) {
  return isUndef(obj) || obj === null;
};

isString = function(obj) {
  return typeof obj === "string";
};

isEmpty = function(obj) {
  return isNull(obj) || obj === "";
};

isTrue = function(obj) {
  return !isNull(obj) && (obj === 1 || obj === true || obj === "1" || obj === "true");
};

isFalse = function(obj) {
  return isNull(obj) || obj === 0 || obj === false || obj === "0" || obj === "false";
};

isBoolean = function(obj) {
  return obj === true || obj === false;
};

isElement = function(obj) {
  return obj instanceof HTMLElement;
};

isPosInt = function(obj) {
  return isInteger(obj) && obj >= 0;
};

isContent = function(obj) {
  return isElement(obj) || obj instanceof HTMLCollection || obj instanceof NodeList || CUI.isArray(obj) || CUI.isFunction(obj) || isElement(obj != null ? obj.DOM : void 0);
};

isNumber = function(n) {
  return isInteger(n) || isFloat(n);
};

isFloat = function(n) {
  return n===+n && n!==(n|0);
};

isInteger = function(n) {
  return n===+n && n===(n|0);
};

isPromise = function(n) {
  if (n instanceof CUI.Promise || n instanceof CUI.Deferred) {
    return true;
  } else {
    return false;
  }
};

isDeferred = function(n) {
  if (n instanceof CUI.Deferred) {
    return true;
  } else {
    return false;
  }
};

escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

getIntOrString = function(s) {
  return getInt(s, true);
};

getInt = function(s, ret_as_is) {
  var i;
  if (ret_as_is == null) {
    ret_as_is = false;
  }
  if (isNull(s)) {
    return null;
  }
  i = parseInt(s);
  if (isNaN(i) || (i + "").length !== (s + "").trim().length) {
    if (ret_as_is) {
      return s;
    } else {
      return null;
    }
  }
  return i;
};

getFloat = function(s) {
  var f;
  if (isNull(s)) {
    return null;
  }
  f = parseFloat(s);
  if (isNaN(f)) {
    return null;
  } else {
    return f;
  }
};

xor = function(a, b) {
  return !!((a && !b) || (!a && b));
};

toHtml = function(data, space2nbsp) {
  if (isNull(data) || !isString(data)) {
    return "";
  }
  data = data.replace(/&/g, "&amp;").replace(/\'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;");
  if (space2nbsp) {
    return data.replace(/\s/g, "&nbsp;");
  } else {
    return data;
  }
};

copyObject = function(obj, deep, level) {
  var e, error, j, k, len, new_arr, new_obj, o, ref, v;
  if (deep == null) {
    deep = false;
  }
  if (level == null) {
    level = 0;
  }
  if ((ref = typeof obj) === "string" || ref === "number" || ref === "boolean" || ref === "function") {
    return obj;
  }
  if (isNull(obj)) {
    return obj;
  }
  if (obj instanceof CUI.Element) {
    if (level === 0 || deep) {
      return obj.copy();
    } else {
      return obj;
    }
  }
  if (obj instanceof HTMLElement) {
    return obj;
  }
  if (obj instanceof CUI.Dummy) {
    return obj;
  }
  if (CUI.isPlainObject(obj)) {
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      if (deep) {
        try {
          new_obj[k] = copyObject(v, true, level + 1);
        } catch (error) {
          e = error;
          console.error("Error during Object copy:", e.toString(), "Key:", k, "Object:", obj);
          throw e;
        }
      } else {
        new_obj[k] = v;
      }
    }
    return new_obj;
  }
  if (CUI.isArray(obj)) {
    if (!deep) {
      return obj.slice(0);
    }
    new_arr = [];
    for (j = 0, len = obj.length; j < len; j++) {
      o = obj[j];
      new_arr.push(copyObject(o, true, level + 1));
    }
    return new_arr;
  }
  return assert(false, "copyObject", "Only {},[],string, boolean, and number can be copied. Object is: " + (getObjectClass(obj)), {
    obj: obj,
    deep: deep
  });
};

dump = function(obj, space) {
  var clean_obj, e, error;
  if (space == null) {
    space = "\t";
  }
  clean_obj = function(obj) {
    var item, j, k, len, ref, result, v;
    if (CUI.isArray(obj)) {
      result = [];
      for (j = 0, len = obj.length; j < len; j++) {
        item = obj[j];
        result.push(clean_obj(item));
      }
      return result;
    } else if (CUI.isPlainObject(obj)) {
      result = {};
      for (k in obj) {
        v = obj[k];
        result[k] = clean_obj(v);
      }
      return result;
    } else if ((ref = typeof obj) === "string" || ref === "number" || ref === "boolean") {
      return obj;
    } else if (isUndef(obj)) {
      return "<undefined>";
    } else if (isNull(obj)) {
      return "<null>";
    } else {
      return getObjectClass(obj);
    }
  };
  try {
    return JSON.stringify(clean_obj(obj), null, space);
  } catch (error) {
    e = error;
    CUI.error(e);
    return "Unable to dump object";
  }
};

alert_dump = function(v) {
  return alert(dump(v, "    "));
};

toDash = function(s) {
  var s1;
  s = s + "U";
  s1 = s.substring(0, 1) + s.substring(1).replace(/([A-Z](?![A-Z0-9]))/g, function($1) {
    return "-" + ($1.toLowerCase());
  });
  s1 = s1.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  s1 = s1.substring(0, s1.length - 2);
  return s1.replace(/\./g, "-");
};

toClass = function(s) {
  return toDash(s).replace(/_/g, "-").replace(/\s+/g, "-");
};

toDot = function(s) {
  return toDash(s).replace(/-/g, ".");
};

toCamel = function(s, includeFirst) {
  if (includeFirst == null) {
    includeFirst = false;
  }
  if (includeFirst) {
    return s.replace(/((\-|^)[a-z])/g, function($1) {
      return $1.toUpperCase().replace('-', '');
    });
  } else {
    return s.replace(/(\-[a-z])/g, function($1) {
      return $1.toUpperCase().replace('-', '');
    });
  }
};

removeFromArray = function(value, arr, compFunc) {
  var idx, removed;
  assert(CUI.isArray(arr), "removeFromArray", "Second parameter needs to be an Array", {
    value: value,
    array: arr,
    compFunc: compFunc
  });
  removed = 0;
  while (true) {
    idx = idxInArray(value, arr, compFunc);
    if (idx > -1) {
      arr.splice(idx, 1);
      removed++;
    } else {
      break;
    }
  }
  return removed;
};

moveInArray = function(from, to, arr, after) {
  var move;
  if (after == null) {
    after = false;
  }
  if (from === to) {
    return to;
  }
  if (from > to) {
    if (after) {
      to++;
    }
  } else {
    if (!after) {
      to--;
    }
  }
  move = arr.splice(from, 1)[0];
  arr.splice(to, 0, move);
  return to;
};

compareIndex = function(a_idx, b_idx) {
  if (a_idx < b_idx) {
    return -1;
  } else if (a_idx > b_idx) {
    return 1;
  } else {
    return 0;
  }
};

index = function(node) {
  return Array.prototype.indexOf.call(node.parentNode.children, node);
};

pushOntoArray = function(value, arr, compFunc) {
  var idx;
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    arr.push(value);
    return arr.length - 1;
  } else {
    return idx;
  }
};

idxInArray = function(value, arr, compFunc) {
  var a, i, idx, j, len;
  if (!compFunc) {
    return arr.indexOf(value);
  }
  idx = -1;
  for (i = j = 0, len = arr.length; j < len; i = ++j) {
    a = arr[i];
    if (CUI.isFunction(compFunc)) {
      if (compFunc(a, value)) {
        idx = i;
        break;
      }
    } else if (a[compFunc](value)) {
      idx = i;
      break;
    }
  }
  return idx;
};

findInArray = function(value, arr, compFunc) {
  var idx;
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    return void 0;
  } else {
    return arr[idx];
  }
};

addToArray = function(value, arr, compFunc) {
  var idx;
  assert(CUI.isArray(arr), "addToArray", "Second parameter needs to be an Array", {
    value: value,
    array: arr,
    compFunc: compFunc
  });
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    arr.push(value);
    return arr.length - 1;
  } else {
    return idx;
  }
};

utoa = function(str) {
  return window.btoa(unescape(encodeURIComponent(str)));
};

atou = function(str) {
  return decodeURIComponent(escape(window.atob(str)));
};

String.prototype.startsWith = function(s) {
  return this.substr(0, s.length) === s;
};

String.prototype.endsWith = function(s) {
  return this.substr(this.length - s.length) === s;
};

Date.prototype.getWeek = function(us) {
  var current_ms, d, day_offset, days_week_in_next_year, first_day, first_day_of_week_ms, next_year_jan_1st, start_day, start_on_jan_1st, week_no, week_offset;
  if (us == null) {
    us = false;
  }
  if (us) {
    start_day = 0;
    start_on_jan_1st = true;
    days_week_in_next_year = 6;
  } else {
    start_day = 1;
    start_on_jan_1st = false;
    days_week_in_next_year = 3;
  }
  day_offset = 24 * 60 * 60 * 1000;
  week_offset = day_offset * 7;
  d = new Date(this);
  d.setUTCHours(0, 0, 0, 0);
  current_ms = d.getTime();
  next_year_jan_1st = new Date(d);
  next_year_jan_1st.setUTCFullYear(d.getUTCFullYear() + 1, 0, 1);
  d.setUTCMonth(0, 1);
  first_day = d.getUTCDay();
  first_day_of_week_ms = d.getTime() - ((first_day - start_day + 7) % 7) * day_offset;
  if ((first_day === 5 || first_day === 6 || first_day === 0) && !start_on_jan_1st) {
    first_day_of_week_ms += week_offset;
  }
  d.setTime(first_day_of_week_ms);
  if ((next_year_jan_1st.getTime() - current_ms) / day_offset <= days_week_in_next_year) {
    week_no = 1;
  } else {
    week_no = Math.floor((current_ms - first_day_of_week_ms) / week_offset) + 1;
  }
  return week_no;
};

getMs = function() {
  return (new Date()).getTime();
};

RegExp.escape = function(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var CUI;

CUI = (function() {
  function CUI() {}

  CUI.__readyFuncs = [];

  CUI.__themes = [];

  CUI.start = function() {
    var trigger_viewport_resize;
    this.CSS = new CUI.CSSLoader();
    this.getPathToScript();
    trigger_viewport_resize = (function(_this) {
      return function() {
        console.info("CUI: trigger viewport resize.");
        return Events.trigger({
          type: "viewport-resize"
        });
      };
    })(this);
    Events.listen({
      type: "resize",
      node: window,
      call: (function(_this) {
        return function(ev, info) {
          console.info("CUI: caught window resize event.");
          if (CUI.__ng__ && !CUI.browser.ie) {
            trigger_viewport_resize();
          } else {
            CUI.scheduleCallback({
              ms: 500,
              call: trigger_viewport_resize
            });
          }
        };
      })(this)
    });
    Events.listen({
      type: "drop",
      node: document.documentElement,
      call: function(ev) {
        return ev.preventDefault();
      }
    });
    Events.listen({
      type: "keyup",
      node: window,
      capture: true,
      call: function(ev) {
        if (ev.getKeyboard() === "C+U+I") {
          return CUI.toaster({
            text: "CUI!"
          });
        }
      }
    });
    Events.listen({
      type: "keydown",
      node: window,
      call: function(ev) {
        var j, len1, node, ref, ref1;
        if (ev.getKeyboard() === "c+") {
          CUI.toaster({
            text: "CUI!"
          });
        }
        if (ev.keyCode() === 8) {
          ref = CUI.DOM.elementsUntil(ev.getTarget(), null, document.documentElement);
          for (j = 0, len1 = ref.length; j < len1; j++) {
            node = ref[j];
            if ((ref1 = node.tagName) === "INPUT" || ref1 === "TEXTAREA") {
              return;
            }
            if (node.getAttribute("contenteditable") === "true") {
              return;
            }
          }
          ev.preventDefault();
        }
      }
    });
    document.body.scrollTop = 0;
    CUI.Template.loadFile("css/icons.svg").done((function(_this) {
      return function() {
        Template.load();
        if (!Template.nodeByName["cui-base"]) {
          return CUI.Template.loadTemplateFile("cui.html").done(function() {
            return _this.ready();
          });
        } else {
          return _this.ready();
        }
      };
    })(this));
    return this;
  };

  CUI.getPathToScript = function() {
    var idx, j, len1, m, ref, s;
    if (!this.pathToScript) {
      ref = DOM.matchSelector(document.documentElement, "script");
      for (idx = j = 0, len1 = ref.length; j < len1; idx = ++j) {
        s = ref[idx];
        if (m = s.src.match("(.*/)cui\.js$")) {
          this.pathToScript = m[1];
          this.script = s;
          break;
        }
      }
      assert(this.pathToScript, "CUI", "Could not determine script path.");
    }
    return this.pathToScript;
  };

  CUI.ready = function(func) {
    var j, len1, ref, results1;
    if (func instanceof Function) {
      if (this.__ready) {
        return func.call(this);
      } else {
        return this.__readyFuncs.push(func);
      }
    } else {
      this.__ready = true;
      ref = this.__readyFuncs;
      results1 = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        func = ref[j];
        results1.push(func.call(this));
      }
      return results1;
    }
  };

  CUI.defaults = {
    FileUpload: {
      name: "files[]"
    },
    debug: true,
    asserts: true,
    asserts_alert: 'js',
    "class": {}
  };

  CUI.resolvedPromise = function() {
    var dfr;
    dfr = new CUI.Deferred();
    dfr.resolve.apply(dfr, arguments);
    return dfr.promise();
  };

  CUI.rejectedPromise = function() {
    var dfr;
    dfr = new CUI.Deferred();
    dfr.reject.apply(dfr, arguments);
    return dfr.promise();
  };

  CUI.chainedCall = function() {
    var __this, args, dfr, get_args, get_return_value, idx, init_next, return_values;
    idx = 0;
    __this = this;
    get_args = function(_arguments) {
      var _args, arg, j, len1;
      _args = [];
      for (j = 0, len1 = _arguments.length; j < len1; j++) {
        arg = _arguments[j];
        _args.push(arg);
      }
      return _args;
    };
    get_return_value = function(_arguments) {
      var _args;
      _args = get_args(_arguments);
      if (_args.length === 0) {
        return void 0;
      } else if (_args.length === 1) {
        return _args[0];
      } else {
        return _args;
      }
    };
    args = get_args(arguments);
    return_values = [];
    init_next = (function(_this) {
      return function() {
        var ret;
        if (idx === args.length) {
          dfr.resolve.apply(dfr, return_values);
          return;
        }
        if (CUI.isFunction(args[idx])) {
          if (__this !== CUI) {
            ret = args[idx].call(__this);
          } else {
            ret = args[idx]();
          }
        } else {
          ret = args[idx];
        }
        idx++;
        if (isPromise(ret)) {
          ret.done(function() {
            return_values.push(get_return_value(arguments));
            return init_next();
          }).fail(function() {
            return_values.push(get_return_value(arguments));
            return dfr.reject.apply(dfr, return_values);
          });
        } else {
          return_values.push(ret);
          init_next();
        }
      };
    })(this);
    dfr = new CUI.Deferred();
    init_next();
    return dfr.promise();
  };

  CUI.chunkWork = function(_opts) {
    var chunk_size, dfr, idx, len, next_chunk, opts, timeout;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "CUI.chunkWork", {
      items: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v);
        }
      },
      chunk_size: {
        mandatory: true,
        "default": 10,
        check: function(v) {
          return v >= 1;
        }
      },
      timeout: {
        mandatory: true,
        "default": 0,
        check: function(v) {
          return v >= -1;
        }
      },
      call: {
        mandatory: true,
        check: function(v) {
          return v instanceof Function;
        }
      }
    });
    chunk_size = opts.chunk_size;
    timeout = opts.timeout;
    assert(this !== CUI, "CUI.chunkWork", "Cannot call CUI.chunkWork with 'this' not set to the caller.");
    idx = 0;
    len = opts.items.length;
    next_chunk = (function(_this) {
      return function() {
        var go_on, progress, ret;
        progress = (idx + 1) + " - " + Math.min(len, idx + chunk_size) + " / " + len;
        dfr.notify({
          progress: progress,
          idx: idx,
          len: len,
          chunk_size: chunk_size
        });
        go_on = function() {
          if (idx + chunk_size >= len) {
            dfr.resolve();
          } else {
            idx = idx + chunk_size;
            if (timeout === -1) {
              next_chunk();
            } else {
              CUI.setTimeout({
                ms: timeout,
                call: next_chunk
              });
            }
          }
        };
        ret = opts.call.call(_this, opts.items.slice(idx, idx + opts.chunk_size), idx, len);
        if (ret === false) {
          dfr.reject();
          return;
        }
        if (isPromise(ret)) {
          ret.fail(dfr.reject).done(go_on);
        } else {
          go_on();
        }
      };
    })(this);
    dfr = new CUI.Deferred();
    CUI.setTimeout({
      ms: Math.min(0, timeout),
      call: (function(_this) {
        return function() {
          if (len > 0) {
            return next_chunk();
          } else {
            return dfr.resolve();
          }
        };
      })(this)
    });
    return dfr.promise();
  };

  CUI.chunkWorkOLD = function(objects, chunkSize, timeout) {
    var dfr, do_next_chunk, idx;
    if (chunkSize == null) {
      chunkSize = 10;
    }
    if (timeout == null) {
      timeout = 0;
    }
    dfr = new CUI.Deferred();
    idx = 0;
    do_next_chunk = (function(_this) {
      return function() {
        var chunk;
        chunk = 0;
        while (idx < objects.length && (chunk < chunkSize || chunkSize === 0)) {
          if (dfr.state() === "rejected") {
            return;
          }
          dfr.notify(objects[idx], idx);
          if (idx === objects.length - 1) {
            dfr.resolve();
            return;
          }
          idx++;
          chunk++;
        }
        if (idx < objects.length) {
          return CUI.setTimeout(do_next_chunk, timeout);
        }
      };
    })(this);
    if (objects.length === 0) {
      CUI.setTimeout((function(_this) {
        return function() {
          if (dfr.state() === "rejected") {
            return;
          }
          return dfr.resolve();
        };
      })(this));
    } else {
      CUI.setTimeout(do_next_chunk);
    }
    return dfr;
  };

  CUI.proxyMethods = function(target, source, methods) {
    var j, k, len1, results1;
    results1 = [];
    for (j = 0, len1 = methods.length; j < len1; j++) {
      k = methods[j];
      results1.push(target.prototype[k] = source.prototype[k]);
    }
    return results1;
  };

  CUI.__timeouts = [];

  CUI.__timeoutCallbacks = [];

  CUI.__callTimeoutChangeCallbacks = function() {
    var cb, j, len1, ref, tracked;
    tracked = this.countTimeouts();
    ref = this.__timeoutCallbacks;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      cb = ref[j];
      cb(tracked);
    }
  };

  CUI.__removeTimeout = function(timeout) {
    if (removeFromArray(timeout, this.__timeouts)) {
      if (timeout.track) {
        this.__callTimeoutChangeCallbacks();
      }
    }
  };

  CUI.__getTimeoutById = function(timeoutID, ignoreNotFound) {
    var j, len1, ref, timeout;
    if (ignoreNotFound == null) {
      ignoreNotFound = false;
    }
    ref = this.__timeouts;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      timeout = ref[j];
      if (timeout.id === timeoutID) {
        return timeout;
      }
    }
    assert(ignoreNotFound, "CUI.__getTimeoutById", "Timeout #" + timeoutID + " not found.");
    return null;
  };

  CUI.resetTimeout = function(timeoutID) {
    var old_real_id, tid, timeout;
    timeout = this.__getTimeoutById(timeoutID);
    assert(!timeout.__isRunning, "CUI.resetTimeout", "Timeout " + timeoutID + " cannot be resetted while running.", {
      timeout: timeout
    });
    if (typeof timeout.onReset === "function") {
      timeout.onReset(timeout);
    }
    window.clearTimeout(timeout.real_id);
    old_real_id = timeout.real_id;
    tid = this.__startTimeout(timeout);
    return tid;
  };

  CUI.registerTimeoutChangeCallback = function(cb) {
    return this.__timeoutCallbacks.push(cb);
  };

  CUI.setTimeout = function(_func, ms, track) {
    var func, onDone, onReset, timeout;
    if (ms == null) {
      ms = 0;
    }
    if (CUI.isPlainObject(_func)) {
      ms = _func.ms || 0;
      track = _func.track;
      func = _func.call;
      onDone = _func.onDone;
      onReset = _func.onReset;
    } else {
      func = _func;
    }
    if (isNull(track)) {
      if (ms === 0) {
        track = false;
      } else {
        track = true;
      }
    }
    assert(CUI.isFunction(func), "CUI.setTimeout", "Function needs to be a Function (opts.call)", {
      parameter: _func
    });
    timeout = {
      call: (function(_this) {
        return function() {
          timeout.__isRunning = true;
          func();
          _this.__removeTimeout(timeout);
          return typeof timeout.onDone === "function" ? timeout.onDone(timeout) : void 0;
        };
      })(this),
      ms: ms,
      func: func,
      track: track,
      onDone: onDone,
      onReset: onReset
    };
    this.__timeouts.push(timeout);
    if (track && ms > 0) {
      this.__callTimeoutChangeCallbacks();
    }
    return this.__startTimeout(timeout);
  };

  CUI.__scheduledCallbacks = [];

  CUI.scheduleCallback = function(_opts) {
    var cb, dfr, idx, opts, timeoutID;
    opts = CUI.Element.readOpts(_opts, "CUI.scheduleCallback", {
      call: {
        mandatory: true,
        check: Function
      },
      ms: {
        "default": 0,
        check: function(v) {
          return isInteger(v) && v >= 0;
        }
      },
      track: {
        "default": false,
        check: Boolean
      }
    });
    idx = idxInArray(opts.call, this.__scheduledCallbacks, function(v) {
      return v.call === opts.call;
    });
    if (idx > -1 && CUI.isTimeoutRunning(this.__scheduledCallbacks[idx].timeoutID)) {
      idx = -1;
    }
    if (idx === -1) {
      idx = this.__scheduledCallbacks.length;
    } else {
      CUI.resetTimeout(this.__scheduledCallbacks[idx].timeoutID);
      return this.__scheduledCallbacks[idx].promise;
    }
    dfr = new CUI.Deferred();
    timeoutID = CUI.setTimeout({
      ms: opts.ms,
      track: opts.track,
      call: (function(_this) {
        return function() {
          opts.call();
          return dfr.resolve();
        };
      })(this)
    });
    cb = this.__scheduledCallbacks[idx] = {
      call: opts.call,
      timeoutID: timeoutID,
      promise: dfr.promise()
    };
    dfr.done((function(_this) {
      return function() {
        return removeFromArray(opts.call, _this.__scheduledCallbacks, function(v) {
          return v.call === opts.call;
        });
      };
    })(this));
    return cb.promise;
  };

  CUI.scheduleCallbackCancel = function(_opts) {
    var idx, opts;
    opts = CUI.Element.readOpts(_opts, "CUI.scheduleCallbackCancel", {
      call: {
        mandatory: true,
        check: Function
      }
    });
    idx = idxInArray(opts.call, this.__scheduledCallbacks, function(v) {
      return v.call === opts.call;
    });
    if (idx > -1 && !CUI.isTimeoutRunning(this.__scheduledCallbacks[idx].timeoutID)) {
      console.error("cancel timeout...", this.__scheduledCallbacks[idx].timeoutID);
      CUI.clearTimeout(this.__scheduledCallbacks[idx].timeoutID);
      this.__scheduledCallbacks.splice(idx, 1);
      return true;
    } else {
      return false;
    }
  };

  CUI.utf8ArrayBufferToString = function(arrayBuffer) {
    var array, c, char2, char3, i, len, out;
    out = [];
    array = new Uint8Array(arrayBuffer);
    len = array.length;
    i = 0;
    while (i < len) {
      c = array[i++];
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out.push(String.fromCharCode(c));
          break;
        case 12:
        case 13:
          char2 = array[i++];
          out.push(String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F)));
          break;
        case 14:
          char2 = array[i++];
          char3 = array[i++];
          out.push(String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
      }
    }
    return out.join("");
  };

  CUI.__startTimeout = function(timeout) {
    var real_id;
    real_id = window.setTimeout(timeout.call, timeout.ms);
    if (!timeout.id) {
      timeout.id = real_id;
    }
    timeout.real_id = real_id;
    return timeout.id;
  };

  CUI.countTimeouts = function() {
    var j, len1, ref, timeout, tracked;
    tracked = 0;
    ref = this.__timeouts;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      timeout = ref[j];
      if (timeout.track) {
        tracked++;
      }
    }
    return tracked;
  };

  CUI.clearTimeout = function(timeoutID) {
    var timeout;
    timeout = this.__getTimeoutById(timeoutID, true);
    if (!timeout) {
      return;
    }
    window.clearTimeout(timeout.real_id);
    this.__removeTimeout(timeout);
    return timeout.id;
  };

  CUI.isTimeoutRunning = function(timeoutID) {
    var timeout;
    timeout = this.__getTimeoutById(timeoutID, true);
    if (!(timeout != null ? timeout.__isRunning : void 0)) {
      return false;
    } else {
      return true;
    }
  };

  CUI.setInterval = function(func, ms) {
    return window.setInterval(func, ms);
  };

  CUI.clearInterval = function(interval) {
    return window.clearInterval(interval);
  };

  CUI.startWebdriverTest = function() {
    var a;
    a = $("body");
    return a.addClass("cui-webdriver-test");
  };

  CUI.mergeMap = function(targetMap, mergeMap) {
    var k, v;
    for (k in mergeMap) {
      v = mergeMap[k];
      if (!targetMap.hasOwnProperty(k)) {
        targetMap[k] = v;
      } else if (CUI.isPlainObject(targetMap[k]) && CUI.isPlainObject(v)) {
        CUI.mergeMap(targetMap[k], v);
      }
    }
    return targetMap;
  };

  CUI.getParameterByName = function(name, search) {
    var regex, results;
    if (search == null) {
      search = document.location.search;
    }
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
    results = regex.exec(search);
    if (results === null) {
      return "";
    } else {
      return decodeURIComponent(results[1].replace(/\+/g, " "));
    }
  };

  CUI.setSessionStorage = function(key, value) {
    return this.__setStorage("sessionStorage", key, value);
  };

  CUI.getSessionStorage = function(key) {
    if (key == null) {
      key = null;
    }
    return this.__getStorage("sessionStorage", key);
  };

  CUI.clearSessionStorage = function() {
    return this.__clearStorage("sessionStorage");
  };

  CUI.setLocalStorage = function(key, value) {
    return this.__setStorage("localStorage", key, value);
  };

  CUI.getLocalStorage = function(key) {
    if (key == null) {
      key = null;
    }
    return this.__getStorage("localStorage", key);
  };

  CUI.clearLocalStorage = function() {
    return this.__clearStorage("localStorage");
  };

  CUI.__storage = {
    localStorage: null,
    sessionStorage: null
  };

  CUI.__setStorage = function(skey, key, value) {
    var data, e, error;
    data = this.__getStorage(skey);
    if (value === void 0) {
      delete data[key];
    } else {
      data[key] = value;
    }
    try {
      window[skey].setItem("CUI", JSON.stringify(data));
    } catch (error) {
      e = error;
      console.warn("CUI.__setStorage: Storage not available.", e);
      this.__storage[skey] = JSON.stringify(data);
    }
    return data;
  };

  CUI.__getStorage = function(skey, key) {
    var data, data_json, e, error;
    if (key == null) {
      key = null;
    }
    try {
      data_json = window[skey].getItem("CUI");
    } catch (error) {
      e = error;
      console.warn("CUI.__getStorage: Storage not available.", e);
      data_json = this.__storage[skey];
    }
    if (data_json) {
      data = JSON.parse(data_json);
    } else {
      data = {};
    }
    if (key !== null) {
      return data[key];
    } else {
      return data;
    }
  };

  CUI.__clearStorage = function(skey) {
    var e, error;
    try {
      return window[skey].removeItem("CUI");
    } catch (error) {
      e = error;
      console.warn("CUI.__clearStorage: Storage not available.", e);
      return this.__storage[skey] = null;
    }
  };

  CUI.encodeUrlData = function(params, replacer, connect, connect_pair) {
    var _v, encode_func, j, k, len1, url, v;
    if (replacer == null) {
      replacer = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    url = [];
    if (replacer) {
      if (CUI.isFunction(replacer)) {
        encode_func = replacer;
      } else {
        encode_func = function(v) {
          return CUI.stringMapReplace(v + "", replace_map);
        };
      }
    } else {
      encode_func = function(v) {
        return encodeURIComponent(v);
      };
    }
    for (k in params) {
      v = params[k];
      if (CUI.isArray(v)) {
        for (j = 0, len1 = v.length; j < len1; j++) {
          _v = v[j];
          url.push(encode_func(k) + connect_pair + encode_func(_v));
        }
      } else if (!isEmpty(v)) {
        url.push(encode_func(k) + connect_pair + encode_func(v));
      } else if (v !== void 0) {
        url.push(encode_func(k));
      }
    }
    return url.join(connect);
  };

  CUI.encodeURIComponentNicely = function(str) {
    var j, len1, ref, s, v;
    if (str == null) {
      str = "";
    }
    s = [];
    ref = (str + "").split("");
    for (j = 0, len1 = ref.length; j < len1; j++) {
      v = ref[j];
      if (v === "," || v === ":") {
        s.push(v);
      } else {
        s.push(encodeURIComponent(v));
      }
    }
    return s.join("");
  };

  CUI.decodeURIComponentNicely = function(v) {
    return decodeURIComponent(v);
  };

  CUI.decodeUrlData = function(url, replacer, connect, connect_pair, use_array) {
    var decode_func, j, key, len1, pair, params, part, ref, value;
    if (replacer == null) {
      replacer = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    if (use_array == null) {
      use_array = false;
    }
    params = {};
    if (replacer) {
      if (CUI.isFunction(replacer)) {
        decode_func = replacer;
      } else {
        decode_func = function(v) {
          return CUI.stringMapReplace(v + "", replacer);
        };
      }
    } else {
      decode_func = function(v) {
        return decodeURIComponent(v);
      };
    }
    ref = url.split(connect);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      part = ref[j];
      if (part.length === 0) {
        continue;
      }
      if (part.indexOf(connect_pair) > -1) {
        pair = part.split(connect_pair);
        key = decode_func(pair[0]);
        value = decode_func(pair[1]);
      } else {
        key = decode_func(part);
        value = "";
      }
      if (use_array) {
        if (!params[key]) {
          params[key] = [];
        }
        params[key].push(value);
      } else {
        params[key] = value;
      }
    }
    return params;
  };

  CUI.decodeUrlDataArray = function(url, replace_map, connect, connect_pair) {
    if (replace_map == null) {
      replace_map = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    return this.decodeUrlData(url, replace_map, connect, connect_pair, true);
  };

  CUI.revertMap = function(map) {
    var k, map_reverted, v;
    map_reverted = {};
    for (k in map) {
      v = map[k];
      map_reverted[v] = k;
    }
    return map_reverted;
  };

  CUI.stringMapReplace = function(s, map) {
    var key, regex;
    regex = [];
    for (key in map) {
      if (isEmpty(key)) {
        continue;
      }
      regex.push(key.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"));
    }
    if (regex.length > 0) {
      return s.replace(new RegExp(regex.join('|'), "g"), function(word) {
        return map[word];
      });
    } else {
      return s;
    }
  };

  CUI.isFunction = function(v) {
    return v && typeof v === "function";
  };

  CUI.isPlainObject = function(v) {
    var ref;
    return v && typeof v === "object" && ((ref = v.constructor) != null ? ref.prototype.hasOwnProperty("isPrototypeOf") : void 0);
  };

  CUI.isEmptyObject = function(v) {
    var k;
    for (k in v) {
      return false;
    }
    return true;
  };

  CUI.isMap = function(v) {
    return this.isPlainObject(v);
  };

  CUI.isArray = function(v) {
    return Array.isArray(v);
  };

  CUI.isString = function(s) {
    return typeof s === "string";
  };

  CUI.downloadData = function(data, fileName) {
    var blob, url;
    blob = new Blob([data], {
      type: "octet/stream"
    });
    url = window.URL.createObjectURL(blob);
    this.__downloadDataElement.href = url;
    this.__downloadDataElement.download = fileName;
    this.__downloadDataElement.click();
    return window.URL.revokeObjectURL(url);
  };

  CUI.urlRegex = new RegExp("^" + "(?:(?:(ftp|ftps|https|http))://|)" + "(?:(\\S+?)(?::(\\S*))?@)?" + "((?:(?:" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(?:[a-z\\u00a1-\\uffff0-9-*][a-z\\u00a1-\\uffff0-9-]*\\.)*" + "(?:[a-z\\u00a1-\\uffff]{2,})" + "))|)" + "(?::(\\d{2,5}))?" + "(?:([/?#]\\S*))?" + "$", "i");

  CUI.evalCode = function(code) {
    var script;
    script = document.createElement("script");
    script.text = code;
    return document.head.appendChild(script).parentNode.removeChild(script);
  };

  CUI.appendToUrl = function(url, data) {
    var key, value;
    for (key in data) {
      value = data[key];
      if (value === void 0) {
        continue;
      }
      if (url.match(/\?/)) {
        url += "&";
      } else {
        url += "?";
      }
      url += encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    return url;
  };

  CUI.parseLocation = function(url) {
    var _match, match, p;
    if (!CUI.isFunction(url != null ? url.match : void 0) || url.length === 0) {
      return null;
    }
    match = url.match(this.urlRegex);
    if (!match) {
      return null;
    }
    p = {
      protocol: match[1] || "",
      user: match[2] || "",
      password: match[3] || "",
      hostname: match[4] || "",
      port: match[5] || "",
      path: match[6] || "",
      origin: ""
    };
    if (p.hostname) {
      if (!p.protocol) {
        p.protocol = "http";
      }
      p.origin = p.protocol + "://" + p.hostname;
      if (p.port) {
        p.origin += ":" + p.port;
      }
      p.url = p.protocol + "://";
      if (p.user) {
        p.url = p.url + p.user + ":" + p.password + "@";
      }
      p.url = p.url + p.hostname;
      if (p.port) {
        p.url = p.url + ":" + p.port;
      }
    } else {
      p.url = "";
    }
    if (p.path.length > 0) {
      _match = p.path.match(/(.*?)(|\?.*?)(|\#.*)$/);
      p.pathname = _match[1];
      p.search = _match[2];
      if (p.search === "?") {
        p.search = "";
      }
      p.fragment = _match[3];
    } else {
      p.search = "";
      p.pathname = "";
      p.fragment = "";
    }
    p.href = p.origin + p.path;
    p.hash = p.fragment;
    if (p.login) {
      p.auth = btoa(p.user + ":" + p.password);
    }
    p.url = p.url + p.path;
    return p;
  };

  CUI.error = function() {
    console.warn("CUI.error is deprecated, use console.error.");
    return console.error.apply(console, arguments);
  };

  CUI.debug = function() {
    console.warn("CUI.debug is deprecated, use console.debug.");
    return console.debug.apply(console, arguments);
  };

  CUI.info = function() {
    console.warn("CUI.info is deprecated, use console.info.");
    return console.info.apply(console, arguments);
  };

  CUI.warn = function() {
    console.warn("CUI.warn is deprecated, use console.warn.");
    return console.warn.apply(console, arguments);
  };

  CUI.escapeAttribute = function(data) {
    if (isNull(data) || !isString(data)) {
      return "";
    }
    data = data.replace(/"/g, "&quot;").replace(/\'/g, "&#39;");
    return data;
  };

  return CUI;

})();

CUI.browser = {
  opera: (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0,
  firefox: typeof InstallTrigger !== 'undefined',
  safari: Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
  ie: /*@cc_on!@*/false || !!document.documentMode,
  chrome: !!window.chrome && !!window.chrome.webstore
};

CUI.browser.edge = !CUI.browser.ie && !!window.StyleMedia;

CUI.browser.blink = (CUI.browser.chrome || CUI.browser.opera) && !!window.CSS;

CUI.ready((function(_this) {
  return function() {
    var fn, i, j, k, nodes;
    for (k in CUI.browser) {
      if (CUI.browser[k]) {
        document.body.classList.add("cui-browser-" + k);
      }
    }
    if (window.marked) {
      CUI.defaults.marked_opts = {
        renderer: new marked.Renderer(),
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: true,
        smartLists: true,
        smartypants: false
      };
    }
    fn = function(i) {
      CUI["$" + i] = function() {
        var arg, idx, l, len1, results1;
        if (arguments.length === 1) {
          window["$" + i] = arguments[0];
          console.debug("$" + i + " = ", arguments[0]);
          return;
        }
        results1 = [];
        for (idx = l = 0, len1 = arguments.length; l < len1; idx = ++l) {
          arg = arguments[idx];
          window["$" + i + idx] = arg;
          results1.push(console.debug("$" + i + idx + " = ", arg));
        }
        return results1;
      };
    };
    for (i = j = 1; j <= 9; i = ++j) {
      fn(i);
    }
    if (typeof marked !== "undefined" && marked !== null) {
      marked.setOptions(CUI.defaults.marked_opts);
    }
    nodes = CUI.DOM.htmlToNodes("<!-- CUI.CUI --><a style='display: none;'></a><!-- /CUI.CUI -->");
    CUI.__downloadDataElement = nodes[1];
    return CUI.DOM.append(document.body, nodes);
  };
})(this));

if (!window.addEventListener) {
  alert("Your browser is not supported. Please update to a current version of Google Chrome, Mozilla Firefox or Internet Explorer.");
} else {
  window.addEventListener("load", (function(_this) {
    return function() {
      return CUI.start();
    };
  })(this));
}
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var $, $a, $audio, $b, $div, $element, $h1, $h2, $h3, $h4, $h5, $h6, $i, $img, $label, $li, $p, $pre, $source, $span, $table, $table_one_row, $td, $text, $textEmpty, $th, $tr, $tr_one_row, $ul, $video, jQuery,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.defaults.jQueryCompat = 1;

CUI.jQueryCompat = (function() {
  function jQueryCompat(input) {
    var fn, item, j, k, key, len, len1, nodes, ref;
    if (!input) {
      return CUI.jQueryCompat.__noopNode();
    }
    if (input instanceof Array || input instanceof NodeList || input instanceof HTMLCollection) {
      nodes = [];
      for (j = 0, len = input.length; j < len; j++) {
        item = input[j];
        assert(item instanceof Node, "jQueryCompat", "Wenn called with Array, only Nodes are supported.", {
          item: item,
          input: input
        });
        nodes.push(CUI.jQueryCompat(item));
      }
      nodes.last = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("last", nodes);
          if (nodes.length === 0) {
            return CUI.jQueryCompat.__noopNode();
          }
          return nodes[nodes.length - 1];
        };
      })(this);
      nodes.first = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("first", nodes);
          if (nodes.length === 0) {
            return CUI.jQueryCompat.__noopNode();
          }
          return nodes[0];
        };
      })(this);
      ref = CUI.jQueryCompat.__noopKeys;
      fn = (function(_this) {
        return function(key) {
          if (key === "css" || key === "hide" || key === "show" || key === "remove" || key === "pf_hide" || key === "pf_show" || key === "scrollIntoView" || key === "addClass" || key === "removeClass" || key === "removeAttr" || key === "detach") {
            nodes[key] = function() {
              var l, len2, node;
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                node[key].apply(node, arguments);
              }
              return nodes;
            };
            return;
          }
          if (key === "attr") {
            nodes[key] = function(prop, value) {
              var l, len2, node, ref1;
              if (value !== void 0) {
                for (l = 0, len2 = nodes.length; l < len2; l++) {
                  node = nodes[l];
                  node[key].apply(node, arguments);
                }
                return nodes;
              } else {
                return (ref1 = nodes[0]) != null ? ref1.attr.apply(nodes[0], arguments) : void 0;
              }
            };
            return;
          }
          if (key === "hasClass") {
            nodes[key] = function() {
              var has_class, l, len2, node;
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                has_class = node[key].apply(node, arguments);
                if (has_class) {
                  return true;
                }
              }
              return false;
            };
            return;
          }
          if (key === "find") {
            nodes[key] = function() {
              var found_nodes, l, len2, node;
              if (nodes.length === 0) {
                return nodes;
              }
              found_nodes = [];
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                found_nodes.push.apply(found_nodes, node.find.apply(node, arguments));
              }
              return found_nodes;
            };
            return;
          }
          return nodes[key] = function() {
            return console.error("Unsupported Function on jQuery Compat Array:", key);
          };
        };
      })(this);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        key = ref[k];
        if (key === "0" || key === "last" || key === "first") {
          continue;
        }
        fn(key);
      }
      return nodes;
    }
    if (isString(input)) {
      nodes = CUI.DOM.matchSelector(document.documentElement, input);
      if (nodes.length === 0) {
        return CUI.jQueryCompat.__noopNode();
      } else if (nodes.length === 1) {
        return CUI.jQueryCompat(nodes[0]);
      } else {
        return CUI.jQueryCompat(nodes);
      }
    }
    return CUI.jQueryCompat.__wrapNode(input);
  }

  jQueryCompat.__warn = function() {
    var args, error_args, prop;
    prop = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!CUI.defaults.jQueryCompat || CUI.defaults.jQueryCompat === 1) {
      return;
    }
    error_args = ["jQueryCompat: " + prop];
    if (CUI.defaults.jQueryCompat >= 4) {
      error_args.push.apply(error_args, args);
    }
    if (CUI.defaults.jQueryCompat === 2) {
      return console.warn.apply(console.warn, error_args);
    } else {
      return console.error.apply(console.error, error_args);
    }
  };

  jQueryCompat.__funcWraps = {};

  jQueryCompat.__noopKeys = ["css", "text", "textContent", "closest", "outerHeight", "outerWidth", "rect", "offset", "cssInt", "cssFloat", "cssEdgeSpace", "hide", "show", "html", "val", "replaceWidth", "scrollIntoView", "empty", "append", "prepend", "appendTo", "remove", "parents", "removeAttr", "removeClass", "addClass", "hasClass", "is", "find", "before", "after", "attr", "last", "first", "relativePosition", "prop", "detach"];

  jQueryCompat.__noopNode = function() {
    var j, key, len, node, ref;
    node = CUI.DOM.element("DIV");
    Object.defineProperty(node, "0", {
      enumerable: true,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("[0]", node);
          return node;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[0] unable to set value.");
        };
      })(this)
    });
    node.length = 0;
    ref = this.__noopKeys;
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if (key === "find") {
        node[key] = (function(_this) {
          return function() {
            _this.__warn(key, "Noop node.");
            return [];
          };
        })(this);
      }
      node[key] = (function(_this) {
        return function() {
          _this.__warn(key, "Noop node.");
        };
      })(this);
    }
    return node;
  };

  jQueryCompat.__wrapNode = function(node) {
    var ref, ref1, ref2;
    assert(node instanceof Node, "jQueryCompat", "Node needs to be instance of Node.", {
      node: node
    });
    if (!CUI.defaults.jQueryCompat) {
      return;
    }
    if (node.__jQueryCompatNode__) {
      return node;
    }
    node.__jQueryCompatNode__ = true;
    Object.defineProperty(node, "length", {
      enumerable: false,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn(".length", node);
          if (CUI.defaults.jQueryCompat > 1) {
            console.error("jQueryCompat: .length accessed on node. Returning 1.", node);
          }
          return 1;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[length] unable to set value.");
        };
      })(this)
    });
    Object.defineProperty(node, "0", {
      enumerable: true,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("[0]", node);
          return node;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[0] unable to set value.");
        };
      })(this)
    });
    node.css = (function(_this) {
      return function(style, value) {
        CUI.jQueryCompat.__warn("css", node, style);
        if (CUI.isPlainObject(style)) {
          return CUI.DOM.setStyle(node, style);
        } else if (value === void 0) {
          return CUI.DOM.getComputedStyle(node)[style];
        } else {
          return CUI.DOM.setStyleOne(node, style, value);
        }
      };
    })(this);
    if ((ref = node.nodeName) !== "BODY" && ref !== "A") {
      node.text = (function(_this) {
        return function(value) {
          CUI.jQueryCompat.__warn("text", node);
          if (isEmpty(value)) {
            return node.textContent;
          }
          node.textContent = value;
          return node;
        };
      })(this);
    }
    if (!node.remove) {
      node.remove = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("remove", node);
          return CUI.DOM.remove(node);
        };
      })(this);
    }
    node.parent = (function(_this) {
      return function() {
        var parent;
        CUI.jQueryCompat.__warn("parent", node);
        parent = node.parentNode;
        if (!parent) {
          return CUI.jQueryCompat.__noopNode();
        }
        return CUI.jQueryCompat(parent);
      };
    })(this);
    node.last = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("last", node);
        return node;
      };
    })(this);
    node.first = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("first", node);
        return node;
      };
    })(this);
    node.closest = (function(_this) {
      return function(selector) {
        return CUI.jQueryCompat(CUI.DOM.closest(node, selector));
      };
    })(this);
    node.outerHeight = (function(_this) {
      return function(includeMargin) {
        if (includeMargin == null) {
          includeMargin = false;
        }
        if (includeMargin) {
          return CUI.DOM.getDimensions(node).marginBoxHeight;
        } else {
          return CUI.DOM.getDimensions(node).borderBoxHeight;
        }
      };
    })(this);
    node.outerWidth = (function(_this) {
      return function(includeMargin) {
        if (includeMargin == null) {
          includeMargin = false;
        }
        if (includeMargin) {
          return CUI.DOM.getDimensions(node).marginBoxWidth;
        } else {
          return CUI.DOM.getDimensions(node).borderBoxWidth;
        }
      };
    })(this);
    node.rect = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("rect", node);
        return CUI.DOM.getRect(node);
      };
    })(this);
    node.offset = (function(_this) {
      return function() {
        var rect;
        CUI.jQueryCompat.__warn("offset", node);
        rect = CUI.DOM.getRect(node);
        return {
          top: rect.top,
          left: rect.left
        };
      };
    })(this);
    node.cssInt = (function(_this) {
      return function(prop, check) {
        var i, s;
        if (check == null) {
          check = true;
        }
        CUI.jQueryCompat.__warn("cssInt", node);
        s = CUI.DOM.getComputedStyle(node)[prop];
        if (s === void 0 || s === "") {
          return 0;
        }
        assert(!check || s.match(/px$/), "cssInt", "css(\"" + prop + "\") did not return \"px\" but \"" + s + "\".");
        i = parseInt(s);
        if (isNaN(i)) {
          return 0;
        } else {
          return i;
        }
      };
    })(this);
    node.cssFloat = (function(_this) {
      return function(prop, check) {
        var i, s;
        if (check == null) {
          check = true;
        }
        CUI.jQueryCompat.__warn("cssFloat", node);
        s = CUI.DOM.getComputedStyle(node)[prop];
        if (s === void 0 || s === "") {
          return 0;
        }
        assert(!check || s.match(/px$/), "cssFloat", "css(\"" + prop + "\") did not return \"px\" but \"" + s + "\".");
        i = parseFloat(s);
        if (isNaN(i)) {
          return 0;
        } else {
          return i;
        }
      };
    })(this);
    node.cssEdgeSpace = function(dir, includeMargin) {
      var access, dim, j, key, keys, len, value;
      if (includeMargin == null) {
        includeMargin = false;
      }
      CUI.jQueryCompat.__warn("cssEdgeSpace", node);
      dim = CUI.DOM.getDimensions(node);
      keys = ["border", "padding"];
      if (includeMargin) {
        keys.push("margin");
      }
      value = 0;
      access = toCamel(dir, true);
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        value = value + dim[key + access];
      }
      return value;
    };
    node.hide = function() {
      return CUI.DOM.hideElement(node);
    };
    node.show = function() {
      return CUI.DOM.showElement(node);
    };
    node.html = function(value) {
      CUI.jQueryCompat.__warn("html", node, value);
      if (value === void 0) {
        node.innerHTML;
      } else {
        node.innerHTML = value;
      }
      return node;
    };
    if ((ref1 = node.nodeName) === "INPUT") {
      node.val = function(value) {
        CUI.jQueryCompat.__warn("val", node);
        if (value === void 0) {
          return node.value;
        } else {
          return node.value = value;
        }
      };
    }
    node.replaceWith = function(new_node) {
      CUI.jQueryCompat.__warn("replaceWith", node, new_node);
      return CUI.DOM.replaceWith(node, new_node);
    };
    node.empty = function() {
      CUI.jQueryCompat.__warn("empty", node);
      return CUI.DOM.empty(node);
    };
    node.append = function() {
      var content, more_content;
      content = arguments[0], more_content = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      CUI.jQueryCompat.__warn("append", node, content);
      if (isString(content) && content.trim().startsWith("<") && content.indexOf(">") > -1) {
        console.error("jQueryCompat.append: Unable to append HTML. Use CUI.DOM.htmlToNodes(...). Possible HTML: ", content);
      }
      CUI.DOM.append(node, content);
      if (more_content.length > 0) {
        console.warn("jQueryCompat.append: Multiple parameters are deprecated.", {
          more_content: more_content
        });
        CUI.DOM.append(node, more_content);
      }
      return node;
    };
    node.prepend = function(content) {
      CUI.jQueryCompat.__warn("prepend", node, content);
      return CUI.DOM.prepend(node, content);
    };
    node.appendTo = function(node_appendTo) {
      CUI.jQueryCompat.__warn("appendTo", node, node_appendTo);
      CUI.DOM.append(node_appendTo, node);
      return node;
    };
    node.prependTo = function(node_prependTo) {
      CUI.jQueryCompat.__warn("prependTo", node, node_prependTo);
      CUI.DOM.prepend(node_prependTo, node);
      return node;
    };
    node.parents = function(selector) {
      CUI.jQueryCompat.__warn("parents", node, selector);
      return CUI.jQueryCompat(CUI.DOM.parents(node, selector));
    };
    node.removeAttr = function(attr) {
      return CUI.DOM.removeAttribute(node, attr);
    };
    if ((ref2 = node.nodeName) === "DIV") {
      node.width = function(value) {
        CUI.jQueryCompat.__warn("width", node, value);
        return DOM.width(node, value);
      };
      node.height = function(value) {
        CUI.jQueryCompat.__warn("height", node, value);
        return DOM.height(node, value);
      };
    }
    node.removeClass = function(cls) {
      CUI.jQueryCompat.__warn("removeClass", node);
      return CUI.DOM.removeClass(node, cls);
    };
    node.addClass = function(cls) {
      CUI.jQueryCompat.__warn("addClass", node, cls);
      return CUI.DOM.addClass(node, cls);
    };
    node.hasClass = function(cls) {
      CUI.jQueryCompat.__warn("hasClass", node, cls);
      return CUI.DOM.hasClass(node, cls);
    };
    node.is = function(selector) {
      CUI.jQueryCompat.__warn("is", node, selector);
      return CUI.DOM.is(node, selector);
    };
    node.find = function(selector) {
      CUI.jQueryCompat.__warn("find", node);
      return CUI.jQueryCompat(CUI.DOM.matchSelector(node, selector));
    };
    node.before = function(node_before) {
      return CUI.DOM.insertBefore(node, node_before);
    };
    node.after = function(node_after) {
      return CUI.DOM.insertAfter(node, node_after);
    };
    node.attr = function(prop, value) {
      CUI.jQueryCompat.__warn("attr|prop", node, prop, value);
      if (CUI.isPlainObject(prop)) {
        return CUI.DOM.setAttributeMap(node, prop);
      } else if (value === void 0) {
        return CUI.DOM.getAttribute(node, prop);
      } else {
        return CUI.DOM.setAttribute(node, prop, value);
      }
    };
    node.relativePosition = function() {
      return CUI.DOM.getRelativePosition(node);
    };
    node.prop = node.attr;
    node.pf_hide = function() {
      CUI.jQueryCompat.__warn("pf_hide", node);
      return CUI.DOM.hideElement(node);
    };
    node.pf_show = function() {
      CUI.jQueryCompat.__warn("pf_show", node);
      return CUI.DOM.showElement(node);
    };
    node.detach = function() {
      CUI.jQueryCompat.__warn("detach", node);
      return node.remove();
    };
    return node;
  };

  jQueryCompat.isPlainObject = function(obj) {
    CUI.jQueryCompat.__warn("isPlainObject");
    return CUI.isPlainObject(obj);
  };

  jQueryCompat.isEmptyObject = function(obj) {
    CUI.jQueryCompat.__warn("isEmptyObject");
    return CUI.isEmptyObject(obj);
  };

  jQueryCompat.isFunction = function(obj) {
    CUI.jQueryCompat.__warn("isFunction");
    return CUI.isFunction(obj);
  };

  jQueryCompat.isArray = function(obj) {
    CUI.jQueryCompat.__warn("isArray");
    return CUI.isArray(obj);
  };

  jQueryCompat.inArray = function(value, arr) {
    return arr.indexOf(value);
  };

  jQueryCompat.each = function(obj, callback) {
    var idx, item, j, key, len, value;
    if (CUI.isArray(obj)) {
      for (idx = j = 0, len = obj.length; j < len; idx = ++j) {
        item = obj[idx];
        callback(idx, item);
      }
      return;
    }
    if (CUI.isPlainObject(obj)) {
      for (key in obj) {
        value = obj[key];
        callback(key, value);
      }
      return;
    }
    return assert(false, "jQueryCompat.each: obj needs to be Array or Map.", {
      obj: obj
    });
  };

  return jQueryCompat;

})();

jQuery = (function(superClass) {
  extend(jQuery, superClass);

  function jQuery(input) {
    CUI.jQueryCompat.__warn("jQuery|$", input);
    return jQuery.__super__.constructor.call(this, input);
  }

  return jQuery;

})(CUI.jQueryCompat);

$ = jQuery;

$element = function(tagName, cls, attrs, no_tables) {
  var node;
  if (attrs == null) {
    attrs = {};
  }
  if (no_tables == null) {
    no_tables = false;
  }
  if (!CUI.__ng__) {
    no_tables = false;
  }
  if (!isEmpty(cls)) {
    attrs["class"] = cls;
  }
  if (no_tables) {
    if (isEmpty(cls)) {
      attrs["class"] = "cui-" + tagName;
    } else {
      attrs["class"] = "cui-" + tagName + " " + cls;
    }
    tagName = "div";
  }
  node = CUI.DOM.element(tagName, attrs);
  return CUI.jQueryCompat.__wrapNode(node);
};

$div = function(cls, attrs) {
  return $element("div", cls, attrs);
};

$video = function(cls, attrs) {
  return $element("video", cls, attrs);
};

$audio = function(cls, attrs) {
  return $element("audio", cls, attrs);
};

$source = function(cls, attrs) {
  return $element("source", cls, attrs);
};

$span = function(cls, attrs) {
  return $element("span", cls, attrs);
};

$table = function(cls, attrs) {
  return $element("table", cls, attrs, true);
};

$img = function(cls, attrs) {
  return $element("img", cls, attrs);
};

$tr = function(cls, attrs) {
  return $element("tr", cls, attrs, true);
};

$th = function(cls, attrs) {
  return $element("th", cls, attrs, true);
};

$td = function(cls, attrs) {
  return $element("td", cls, attrs, true);
};

$i = function(cls, attrs) {
  return $element("i", cls, attrs);
};

$p = function(cls, attrs) {
  return $element("p", cls, attrs);
};

$pre = function(cls, attrs) {
  return $element("pre", cls, attrs);
};

$ul = function(cls, attrs) {
  return $element("ul", cls, attrs);
};

$a = function(cls, attrs) {
  return $element("a", cls, attrs);
};

$b = function(cls, attrs) {
  return $element("b", cls, attrs);
};

$li = function(cls, attrs) {
  return $element("li", cls, attrs);
};

$label = function(cls, attrs) {
  return $element("label", cls, attrs);
};

$h1 = function(cls, attrs) {
  return $element("h1", cls, attrs);
};

$h2 = function(cls, attrs) {
  return $element("h2", cls, attrs);
};

$h3 = function(cls, attrs) {
  return $element("h3", cls, attrs);
};

$h4 = function(cls, attrs) {
  return $element("h4", cls, attrs);
};

$h5 = function(cls, attrs) {
  return $element("h5", cls, attrs);
};

$h6 = function(cls, attrs) {
  return $element("h6", cls, attrs);
};

$text = function(text, cls, attrs) {
  var s;
  s = $span(cls, attrs);
  s.textContent = text;
  return s;
};

$textEmpty = function(text) {
  var s;
  s = $span("italic");
  s.textContent = text;
  return s;
};

$table_one_row = function() {
  return $table().append($tr_one_row.apply(this, arguments));
};

$tr_one_row = function() {
  var _a, a, append, j, k, len, len1, tr;
  tr = $tr();
  append = function(__a) {
    var add_content, td;
    td = $td().appendTo(tr);
    add_content = (function(_this) {
      return function(___a) {
        var a, j, len;
        if (CUI.isArray(___a)) {
          for (j = 0, len = ___a.length; j < len; j++) {
            a = ___a[j];
            add_content(a);
          }
        } else if (___a != null ? ___a.DOM : void 0) {
          td.append(___a.DOM);
        } else if (!isNull(___a)) {
          td.append(___a);
        }
      };
    })(this);
    add_content(__a);
  };
  for (j = 0, len = arguments.length; j < len; j++) {
    a = arguments[j];
    if (CUI.isArray(a)) {
      for (k = 0, len1 = a.length; k < len1; k++) {
        _a = a[k];
        append(_a);
      }
    } else {
      append(a);
    }
  }
  return tr;
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Deferred = (function() {
  function Deferred() {
    this.__state = "pending";
    this.__callbacks = [];
    this.notify = (function(_this) {
      return function() {
        return _this.__notify.apply(_this, arguments);
      };
    })(this);
    this.resolve = (function(_this) {
      return function() {
        return _this.__resolve.apply(_this, arguments);
      };
    })(this);
    this.reject = (function(_this) {
      return function() {
        return _this.__reject.apply(_this, arguments);
      };
    })(this);
    this.__uniqueId = CUI.Deferred.uniqueId++;
    this.__runningCallbacks = null;
    this.__finished_args = null;
  }

  Deferred.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Deferred.prototype.__callback = function(types, args) {
    var cb, idx, ref, ref1;
    this.__runningCallbacks = true;
    idx = 0;
    while (idx < this.__callbacks.length) {
      cb = this.__callbacks[idx];
      if (ref = cb.type, indexOf.call(types, ref) >= 0) {
        cb.func.apply(this, args);
        if ((ref1 = cb.type) === "done" || ref1 === "always" || ref1 === "fail") {
          this.__callbacks.splice(idx, 1);
          continue;
        }
      }
      idx++;
    }
    this.__runningCallbacks = false;
    return this;
  };

  Deferred.prototype.__register = function(type, func) {
    assert(CUI.isFunction(func), "Deferred." + type + ": Callback needs to be Function.", {
      callback: func
    });
    if (this.__state === "rejected" && type === "done") {
      return;
    }
    if (this.__state === "resolved" && type === "fail") {
      return;
    }
    this.__callbacks.push({
      type: type,
      func: func
    });
    if (this.__state !== "pending" && !this.__runningCallbacks) {
      switch (this.__state) {
        case "resolved":
          this.__callback(["done", "always"], this.__finished_args);
          break;
        case "rejected":
          this.__callback(["fail", "always"], this.__finished_args);
      }
    }
    return this;
  };

  Deferred.prototype.done = function(func) {
    this.__register("done", func);
    return this;
  };

  Deferred.prototype.fail = function(func) {
    this.__register("fail", func);
    return this;
  };

  Deferred.prototype.always = function(func) {
    this.__register("always", func);
    return this;
  };

  Deferred.prototype.progress = function(func) {
    this.__register("progress", func);
    return this;
  };

  Deferred.prototype.__notify = function() {
    assert(this.__state === "pending", "CUI.Deferred.notify", "Cannot notify state " + this.__state + ".");
    this.__callback(["progress"], arguments);
    return this;
  };

  Deferred.prototype.__resolve = function() {
    assert(this.__state === "pending", "CUI.Deferred.resolve", "Cannot resolve state " + this.__state + ".");
    this.__finished_args = arguments;
    this.__state = "resolved";
    this.__callback(["done", "always"], arguments);
    return this;
  };

  Deferred.prototype.__reject = function() {
    assert(this.__state === "pending", "CUI.Deferred.reject", "Cannot reject state " + this.__state + ".");
    this.__finished_args = arguments;
    this.__state = "rejected";
    this.__callback(["fail", "always"], arguments);
    return this;
  };

  Deferred.prototype.state = function() {
    return this.__state;
  };

  Deferred.prototype.promise = function() {
    return new CUI.Promise(this);
  };

  Deferred.uniqueId = 0;

  return Deferred;

})();
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.Promise = (function() {
  function Promise(__deferred) {
    this.__deferred = __deferred;
    assert(this.__deferred instanceof CUI.Deferred, "new Promise", "parameter needs to be instanceof CUI.Deferred", {
      parameter: this.__deferred
    });
  }

  Promise.prototype.done = function() {
    this.__deferred.done.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.fail = function() {
    this.__deferred.fail.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.always = function() {
    this.__deferred.always.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.progress = function() {
    this.__deferred.progress.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.state = function() {
    return this.__deferred.state.apply(this.__deferred, arguments);
  };

  Promise.prototype.getUniqueId = function() {
    return this.__deferred.getUniqueId();
  };

  return Promise;

})();
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.when = (function(_this) {
  return function() {
    var _arg, _idx, add_promise, arg, dfr, done_count, done_values, fn, i, idx, j, k, len, len1, len2, promise, promises;
    promises = [];
    add_promise = function(promise, idx) {
      assert(isPromise(promise) || isDeferred(promise), "CUI.when", "arg[" + idx + "] needs to be instanceof CUI.Promise or CUI.Deferred.", {
        arg: promise
      });
      promises.push(promise);
    };
    for (idx = i = 0, len = arguments.length; i < len; idx = ++i) {
      arg = arguments[idx];
      if (arg instanceof Array) {
        for (_idx = j = 0, len1 = arg.length; j < len1; _idx = ++j) {
          _arg = arg[_idx];
          add_promise(_arg, idx + "[" + _idx + "]");
        }
      } else {
        add_promise(arg, idx);
      }
    }
    if (promises.length === 0) {
      return CUI.resolvedPromise();
    }
    dfr = new CUI.Deferred();
    done_values = [];
    done_count = 0;
    fn = function(idx) {
      promise.done(function() {
        var l, len3;
        done_count++;
        switch (arguments.length) {
          case 0:
            done_values[idx] = void 0;
            break;
          case 1:
            done_values[idx] = arguments[0];
            break;
          default:
            done_values[idx] = [];
            for (l = 0, len3 = arguments.length; l < len3; l++) {
              arg = arguments[l];
              done_values[idx].push(arg);
            }
        }
        if (done_count === promises.length) {
          dfr.resolve.apply(dfr, done_values);
        }
      });
      promise.fail(function() {
        if (dfr.state() !== "rejected") {
          dfr.reject.apply(dfr, arguments);
        }
      });
      return promise.progress(function() {
        if (dfr.state() === "pending") {
          dfr.notify.apply(dfr, arguments);
        }
      });
    };
    for (idx = k = 0, len2 = promises.length; k < len2; idx = ++k) {
      promise = promises[idx];
      fn(idx);
    }
    return dfr.promise();
  };
})(this);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.decide = (function(_this) {
  return function(decision) {
    var dfr;
    dfr = new CUI.Deferred();
    if (isPromise(decision)) {
      decision.done(dfr.resolve);
      decision.fail(dfr.reject);
    } else if (decision === false) {
      dfr.reject(false);
    } else {
      dfr.resolve(decision);
    }
    return dfr.promise();
  };
})(this);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.Dummy = (function() {
  function Dummy() {
    this.__uniqueId = CUI.Dummy.uniqueId++;
    this.__cls = getObjectClass(this);
  }

  Dummy.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Dummy.uniqueId = 0;

  return Dummy;

})();

CUI.Dummy;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.Element = (function() {
  function Element(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    this.__uniqueId = CUI.Element.uniqueId++;
    this.__cls = getObjectClass(this);
    this.__destroyed = false;
    this.__check_map = {};
    this.__mapped_keys = [];
    this.initOpts();
    if (CUI.Element.__dont_read_opts) {
      return;
    }
    this.readOpts();
    if (!this.__initOptsCalled) {
      CUI.warn("new " + this.__cls + ": CUI.Element::initOpts not called.", {
        opts: this.opts
      });
    }
    if (typeof this._onConstruct === "function") {
      this._onConstruct(this);
    }
    return;
  }

  Element.prototype.getElementClass = function() {
    return this.__cls;
  };

  Element.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Element.prototype.getOpts = function() {
    return this.opts;
  };

  Element.prototype.getOpt = function(key) {
    return this.opts[key];
  };

  Element.prototype.hasOpt = function(key) {
    return this.opts.hasOwnProperty(key);
  };

  Element.prototype.getSetOpt = function(key) {
    return this["_" + key];
  };

  Element.prototype.hasSetOpt = function(key) {
    return this.hasOwnProperty("_" + key);
  };

  Element.prototype.initOpts = function() {
    this.__initOptsCalled = true;
    return this.addOpts({
      debug: {},
      onConstruct: {
        check: Function
      },
      onDestroy: {
        check: Function
      }
    });
  };

  Element.prototype.copy = function() {
    return new window[this.__cls](this.opts);
  };

  Element.prototype.mergeOpt = function(key, check_map) {
    var k, opt, v;
    if (check_map == null) {
      check_map = {};
    }
    opt = this.__check_map[key] || {};
    for (k in check_map) {
      v = check_map[k];
      opt[k] = v;
    }
    return this.addOpt(key, opt, "mergeOpt");
  };

  Element.prototype.removeOpt = function(key) {
    return delete this.__check_map[key];
  };

  Element.prototype.addOpt = function(key, check_map, fn) {
    if (fn == null) {
      fn = "addOpt";
    }
    assert(isString(key), this.__cls + "." + fn, "key needs to be String", {
      key: key,
      check_map: check_map
    });
    if (isNull(check_map)) {
      return;
    }
    assert(CUI.isPlainObject(check_map), this.__cls + "." + fn, "check_map needs to be Map", {
      key: key,
      check_map: check_map
    });
    this.__check_map[key] = check_map;
    return this;
  };

  Element.prototype.addOpts = function(map) {
    var k, v;
    assert(CUI.isPlainObject(map), this.__cls + ".addOpts", "Parameter needs to be Map", {
      map: map
    });
    for (k in map) {
      v = map[k];
      this.addOpt(k, v);
    }
    return this;
  };

  Element.prototype.mergeOpts = function(map) {
    var k, v;
    assert(CUI.isPlainObject(map), this.__cls + ".mergeOpts", "Parameter needs to be Map", {
      map: map
    });
    for (k in map) {
      v = map[k];
      this.mergeOpt(k, v);
    }
    return this;
  };

  Element.prototype.getCheckMap = function() {
    return this.__check_map;
  };

  Element.prototype.readOpts = function(opts, cls, check_map) {
    if (opts == null) {
      opts = this.opts;
    }
    if (cls == null) {
      cls = this.__cls;
    }
    if (check_map == null) {
      check_map = this.__check_map;
    }
    return CUI.Element.readOpts.call(this, opts, cls, check_map, true);
  };

  Element.prototype.readOptsFromAttr = function(str) {
    var i, key, key_value, len, opts, ref, ref1, value;
    opts = {};
    if (!(str != null ? str.split : void 0)) {
      return opts;
    }
    ref = str.split(";");
    for (i = 0, len = ref.length; i < len; i++) {
      key_value = ref[i];
      if (isEmpty(key_value.trim())) {
        continue;
      }
      ref1 = key_value.split(":"), key = ref1[0], value = ref1[1];
      key = key.trim();
      value = value != null ? value.trim() : void 0;
      assert(!isEmpty(key) && !isEmpty(value), this.__cls + ".readOptsFromAttr", "Parsing error in \"" + str + "\".");
      if (value === "true") {
        value = true;
      } else if (value === "false") {
        value = false;
      } else if (!isNaN(parseInt(value))) {
        value = parseInt(value);
      }
      opts[key] = value;
    }
    return opts;
  };

  Element.prototype.proxy = function(element, methods) {
    var fn1, i, len, method;
    assert(element instanceof CUI.Element, "CUI.Element.proxy", "element given must be instance of CUI.Element.", {
      element: element,
      methods: methods
    });
    assert(CUI.isArray(methods), "Element.proxy", "methods given must be Array.", {
      element: element,
      methods: methods
    });
    fn1 = (function(_this) {
      return function(method) {
        return _this[method] = function() {
          return element[method].apply(element, arguments);
        };
      };
    })(this);
    for (i = 0, len = methods.length; i < len; i++) {
      method = methods[i];
      fn1(method);
    }
    return this;
  };

  Element.prototype.destroy = function() {
    var i, k, len, ref;
    assert(this.__mapped_keys, getObjectClass(this) + ".destroy", "__mapped_keys not found, that means the top level constructor was not called.", {
      element: this
    });
    ref = this.__mapped_keys;
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      delete ("@_" + k);
    }
    this.__mapped_keys = [];
    if (typeof this._onDestroy === "function") {
      this._onDestroy(this);
    }
    return this.__destroyed = true;
  };

  Element.prototype.isDestroyed = function() {
    return this.__destroyed;
  };

  Element.uniqueId = 0;

  Element.getOptKeys = function() {
    var element;
    CUI.Element.__dont_read_opt = true;
    element = new this;
    delete CUI.Element.__dont_read_opts;
    return Object.keys(element.getCheckMap());
  };

  Element.readOpts = function(opts, cls, check_map, map_values) {
    var _check, check, err, exists, k, mandatory, post, set_opts, v, value;
    if (map_values !== true && map_values !== false) {
      if (this !== Element) {
        assert(this !== window, "CUI.Element.readOpts", "this cannot be window.");
        map_values = true;
      }
    }
    if (!CUI.defaults.asserts) {
      set_opts = {};
      for (k in check_map) {
        v = check_map[k];
        if (opts.hasOwnProperty(k) && opts[k] !== void 0) {
          set_opts[k] = this["_" + k] = opts[k];
          if (map_values) {
            this.__mapped_keys.push(k);
          }
        } else if (v.hasOwnProperty("default")) {
          set_opts[k] = this["_" + k] = v["default"];
          if (map_values) {
            this.__mapped_keys.push(k);
          }
        }
      }
      return set_opts;
    }
    assert(CUI.isPlainObject(opts), cls, "opts needs to be PlainObject.", {
      opts: opts,
      check_map: check_map
    });
    assert(CUI.isPlainObject(check_map), cls, "check_map needs to be PlainObject.", {
      opts: opts,
      check_map: check_map
    });
    set_opts = {};
    for (k in check_map) {
      v = check_map[k];
      if (opts.hasOwnProperty(k) && opts[k] !== void 0) {
        value = opts[k];
        exists = true;
      } else if (v.hasOwnProperty("default")) {
        value = v["default"];
        exists = true;
      } else {
        exists = false;
      }
      if (CUI.isFunction(v.mandatory)) {
        mandatory = v.mandatory.call(this, value);
      } else {
        mandatory = v.mandatory;
      }
      if (!exists) {
        if (mandatory) {
          assert(false, cls, "opts." + k + " needs to be set.", {
            opts: opts,
            check_map: check_map
          });
        } else {
          continue;
        }
      } else if (v.deprecated) {
        if (v.deprecated.length > 0) {
          post = v.deprecated;
        } else {
          post = "";
        }
        console.error(cls + ": opts." + k + " is deprecated.", value);
      }
      if (v.check && (!isNull(value) || mandatory)) {
        if (CUI.isArray(v.check)) {
          assert(v.check.indexOf(value) > -1, cls, "opts." + k + " needs to be one of [\"" + (v.check.join('\",\"')) + "\"].", {
            opts: opts
          });
        } else if (v.check === Boolean || v.check === String || v.check === Function || v.check === Array) {
          assertInstanceOf.call(this, k, v.check, void 0, value);
        } else if (CUI.isFunction(v.check) && !v.check.__super__) {
          assert(isEmpty(v.check.name) || v.check.name === "check", cls, k + ".check is \"" + v.check.name + "\" but has no \"__super__\" method. Use \"extends CUI.Element\" or \"extends CUI.Dummy\" to fix that.", {
            opts: opts,
            key: k,
            value: v
          });
          check = v.check.call(this, value);
          if (!(isNull(check) || isBoolean(check) || isString(check))) {
            _check = check;
            console.error("CUI.Element.readOpts: check needs to return Boolean, null, undefined or String.", "opts:", opts, "opt:", v, "return:", _check);
            if (_check) {
              check = true;
            } else {
              check = false;
            }
          }
          if (check !== true) {
            if (isString(check)) {
              err = check;
            } else {
              err = "needs to match\n\n" + v.check.toString();
            }
            assert(false, cls, "opts." + k + ": " + err + ".", {
              opts: opts
            });
          }
        } else if (CUI.isPlainObject(v.check)) {
          value = CUI.Element.readOpts(value, cls + " [opts." + k + "]", v.check);
        } else if (isNull(value) && mandatory) {
          assert(false, cls, "opts." + k + " is mandatory, but is " + value + ".", {
            opts: opts
          });
        } else {
          assertInstanceOf.call(this, k, v.check, void 0, value);
        }
      }
      if (map_values) {
        this["_" + k] = value;
        if (this instanceof CUI.Element) {
          this.__mapped_keys.push(k);
        }
      }
      set_opts[k] = value;
    }
    for (k in opts) {
      v = opts[k];
      if (v !== void 0 && !set_opts.hasOwnProperty(k) && !k.startsWith("_")) {
        console.error(cls + ": opts." + k + ", not supported. check_map: ", check_map, "opts:", opts);
      }
    }
    return set_opts;
  };

  return Element;

})();
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.XHR = (function(superClass) {
  extend(XHR, superClass);

  function XHR() {
    return XHR.__super__.constructor.apply(this, arguments);
  }

  XHR.prototype.getGroup = function() {
    return "Core";
  };

  XHR.prototype.initOpts = function() {
    XHR.__super__.initOpts.call(this);
    this.addOpts({
      method: {
        mandatory: true,
        "default": "GET",
        check: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
      },
      url: {
        mandatory: true,
        check: String,
        check: function(v) {
          return v.trim().length > 0;
        }
      },
      user: {
        check: String
      },
      password: {
        check: String
      },
      responseType: {
        mandatory: true,
        "default": "json",
        check: ["", "text", "json", "blob", "arraybuffer"]
      },
      timeout: {
        check: function(v) {
          return v >= 0;
        }
      },
      form: {
        check: "PlainObject"
      },
      url_data: {
        check: "PlainObject"
      },
      body: {},
      json_data: {},
      json_pretty: {
        "default": false,
        check: function(v) {
          return v === false || v === true || isString(v);
        }
      },
      headers: {
        mandatory: true,
        "default": {},
        check: "PlainObject"
      },
      withCredentials: {
        mandatory: true,
        "default": false,
        check: Boolean
      }
    });
    return this;
  };

  XHR.readyStates = {
    0: "UNSENT",
    1: "OPENED",
    2: "HEADERS_RECEIVED",
    3: "LOADING",
    4: "DONE"
  };

  XHR.statusText = {
    "-1": "abort",
    "-2": "timeout",
    "-3": "network_failure"
  };

  XHR.prototype.readOpts = function() {
    var k, ref, set, v;
    XHR.__super__.readOpts.call(this);
    this.__xhr = new XMLHttpRequest();
    this.__xhr.withCredentials = this._withCredentials;
    this.__readyStatesSeen = [this.readyState()];
    this.__registerEvents("download");
    this.__registerEvents("upload");
    this.__headers = {};
    ref = this._headers;
    for (k in ref) {
      v = ref[k];
      this.__headers[k.toLowerCase()] = v;
    }
    if (this._form) {
      if (!this.opts.method) {
        this._method = "POST";
      }
    }
    if (this._url_data) {
      this.__url = CUI.appendToUrl(this._url, this._url_data);
    } else {
      this.__url = this._url;
    }
    set = 0;
    if (this._form) {
      set = set + 1;
    }
    if (this._json_data) {
      set = set + 1;
      if (this.__headers['content-type'] === void 0) {
        this.__headers['content-type'] = 'application/json; charset=utf-8';
      }
    }
    if (this._body) {
      set = set + 1;
    }
    assert(set <= 1, "new CUI.XHR", "opts.form, opts.json_data, opts.body are mutually exclusive.");
    return this;
  };

  XHR.prototype.__registerEvents = function(type) {
    var fn, fn1, i, k, keys, len, xhr;
    keys = ["loadStart", "progress", "abort", "error", "load", "loadend", "timeout"];
    if (type === "upload") {
      xhr = this.__xhr.upload;
    } else {
      keys.push("readyStateChange");
      xhr = this.__xhr;
    }
    fn1 = (function(_this) {
      return function(fn, k) {
        return xhr.addEventListener(k.toLowerCase(), function(ev) {
          return _this[fn](ev);
        });
      };
    })(this);
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      fn = "__" + type + "_" + k;
      if (!this[fn]) {
        continue;
      }
      fn1(fn, k);
    }
    return this;
  };

  XHR.prototype.__setStatus = function(__status) {
    this.__status = __status;
    this.__xhr.CUI_status = this.__status;
    return this.__xhr.CUI_statusText = this.statusText();
  };

  XHR.prototype.__download_abort = function() {
    this.__setStatus(-1);
    return console.warn("Aborted:", this.__readyStatesSeen, this);
  };

  XHR.prototype.__download_timeout = function() {
    this.__setStatus(-2);
    return console.warn("Timeout:", this.__readyStatesSeen, this);
  };

  XHR.prototype.__download_loadend = function() {
    if (this.isSuccess()) {
      this.__dfr.resolve(this.response(), this.status(), this.statusText());
    } else {
      if (!this.status() && !this.__status) {
        this.__setStatus(-3);
        CUI.debug("status", this.__status);
      }
      this.__dfr.reject(this.response(), this.status(), this.statusText());
    }
    return this;
  };

  XHR.prototype.__download_readyStateChange = function() {
    return pushOntoArray(this.readyState(), this.__readyStatesSeen);
  };

  XHR.prototype.__progress = function(ev, type) {
    var loaded, percent, total;
    if (this.readyState() === "DONE") {
      return;
    }
    loaded = ev.loaded;
    total = ev.total;
    if (ev.lengthComputable) {
      percent = Math.floor(loaded / total * 100);
    } else {
      percent = -1;
    }
    this.__dfr.notify(type, loaded, total, percent);
    return this;
  };

  XHR.prototype.__upload_progress = function(ev) {
    return this.__progress(ev, "upload");
  };

  XHR.prototype.__download_progress = function(ev) {
    return this.__progress(ev, "download");
  };

  XHR.prototype.abort = function() {
    return this.__xhr.abort();
  };

  XHR.prototype.isSuccess = function() {
    if (this.__url.startsWith("file:///") && this.__readyStatesSeen.join(",") === "UNSENT,OPENED,HEADERS_RECEIVED,LOADING,DONE") {
      return true;
    } else {
      return this.__xhr.status >= 200 && this.__xhr.status < 300 || this.__xhr.status === 304;
    }
  };

  XHR.prototype.status = function() {
    if (this.__status < 0) {
      return this.__status;
    } else {
      return this.__xhr.status;
    }
  };

  XHR.prototype.statusText = function() {
    if (this.__status < 0) {
      return CUI.XHR.statusText[this.__status + ""];
    } else {
      return this.__xhr.statusText;
    }
  };

  XHR.prototype.response = function() {
    var e, error, res, rest;
    if (this._responseType === "json" && this.__xhr.responseType === "") {
      try {
        res = JSON.parse(this.__xhr.response);
      } catch (error) {
        e = error;
        rest = this.__xhr.response;
      }
    } else {
      res = this.__xhr.response;
    }
    if (this._responseType === "json") {
      this.__xhr.responseJSON = res;
    }
    return res;
  };

  XHR.prototype.start = function() {
    var data, k, ref, ref1, send_data, v;
    this.__xhr.open(this._method, this.__url, true, this._user, this._password);
    ref = this.__headers;
    for (k in ref) {
      v = ref[k];
      this.__xhr.setRequestHeader(k, v);
    }
    this.__xhr.responseType = this._responseType;
    this.__xhr.timeout = this._timeout;
    if (this._form) {
      data = new FormData();
      ref1 = this._form;
      for (k in ref1) {
        v = ref1[k];
        data.append(k, v);
      }
      send_data = data;
    } else if (this._json_data) {
      if (this._json_pretty) {
        if (this._json_pretty === true) {
          send_data = JSON.stringify(this._json_data, null, "\t");
        } else {
          send_data = JSON.stringify(this._json_data, null, this._json_pretty);
        }
      } else {
        send_data = JSON.stringify(this._json_data);
      }
    } else if (this._body) {
      send_data = this._body;
    } else {
      send_data = void 0;
    }
    this.__dfr = new CUI.Deferred();
    this.__xhr.send(send_data);
    return this.__dfr.promise();
  };

  XHR.prototype.getXHR = function() {
    return this.__xhr;
  };

  XHR.prototype.getAllResponseHeaders = function() {
    var header, headers, i, len, ref;
    headers = [];
    ref = this.__xhr.getAllResponseHeaders().split("\r\n");
    for (i = 0, len = ref.length; i < len; i++) {
      header = ref[i];
      if (header.trim().length === 0) {
        continue;
      }
      headers.push(header);
    }
    return headers;
  };

  XHR.prototype.getResponseHeaders = function() {
    var header, i, key, len, map, match, ref;
    map = {};
    ref = this.getAllResponseHeaders();
    for (i = 0, len = ref.length; i < len; i++) {
      header = ref[i];
      match = header.match(/^(.*?): (.*)$/);
      key = match[1].toLowerCase();
      if (!map[key]) {
        map[key] = [];
      }
      map[key].push(match[2]);
    }
    return map;
  };

  XHR.prototype.getResponseHeader = function(key) {
    var ref;
    return (ref = this.getResponseHeaders()[key.toLowerCase()]) != null ? ref[0] : void 0;
  };

  XHR.prototype.readyState = function() {
    return CUI.XHR.readyStates[this.__xhr.readyState];
  };

  return XHR;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.DragDropSelect = (function(superClass) {
  extend(DragDropSelect, superClass);

  function DragDropSelect(opts) {
    this.opts = opts != null ? opts : {};
    DragDropSelect.__super__.constructor.call(this, this.opts);
    this.init();
  }

  DragDropSelect.prototype.initOpts = function() {
    DragDropSelect.__super__.initOpts.call(this);
    this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return CUI.DOM.isNode(v);
        }
      }
    });
    return this;
  };

  DragDropSelect.prototype.readOpts = function() {
    var ref;
    DragDropSelect.__super__.readOpts.call(this);
    this.cls = CUI[this.__cls].cls;
    assert(this.cls, "new " + this.__cls, this.__cls + ".cls is not set.", {
      opts: this.opts
    });
    this.element = this._element;
    if ((ref = DragDropSelect.getInstance(this.element, this.cls)) != null) {
      ref.destroy();
    }
    DOM.data(this.element, "drag-drop-select-" + this.cls, this);
    return DOM.addClass(this.element, this.getClass());
  };

  DragDropSelect.prototype.getClass = function() {
    return "cui-drag-drop-select cui-drag-drop-select-" + this.cls;
  };

  DragDropSelect.prototype.destroy = function() {
    DOM.removeClass(this.element, this.getClass());
    DOM.removeData(this.element, "drag-drop-select-" + this.cls);
    Events.ignore({
      instance: this
    });
    return DragDropSelect.__super__.destroy.call(this);
  };

  DragDropSelect.prototype.init = function() {
    throw "overwrite Drag.init";
  };

  DragDropSelect.destroy = function(node, cls) {
    var inst;
    if (cls == null) {
      cls = this.cls;
    }
    inst = this.getInstance(node, cls);
    return inst != null ? inst.destroy() : void 0;
  };

  DragDropSelect.getInstance = function(node, cls) {
    if (cls == null) {
      cls = this.cls;
    }
    assert(cls !== "DragDropSelect", "DragDropSelect.getInstance", "cls cannot be DragDropSelect");
    return DOM.data(node, "drag-drop-select-" + cls);
  };

  return DragDropSelect;

})(CUI.Element);

CUI.ready((function(_this) {
  return function() {
    Events.registerEvent({
      type: "cui-drop",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragenter",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragend",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragleave",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragover",
      bubble: true
    });
    Events.registerEvent({
      type: "dragover-scroll",
      bubble: true,
      eventClass: CUI.DragoverScrollEvent
    });
    return Events.listen({
      type: "dragover-scroll",
      node: document,
      selector: "div.cui-drag-scroll,div.cui-drag-drop-select",
      call: function(ev, info) {
        var clientX, clientY, d, dim, el, is_body, oldScrollLeft, oldScrollTop, originalEvent, rect, ref, ref1, ref2, ref3, scrollLeft, scrollSpeed, scrollTop, scrollX, scrollY, threshold;
        originalEvent = ev.getOriginalEvent();
        scrollSpeed = ev.getCount() * 0.01 + 0.9;
        threshold = 30;
        el = ev.getCurrentTarget();
        dim = CUI.DOM.getDimensions(el);
        if (CUI.DOM.is(el, "body,html")) {
          is_body = true;
          rect = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            height: dim.height,
            width: dim.width
          };
        } else {
          rect = dim.clientBoundingRect;
        }
        scrollTop = 0;
        scrollLeft = 0;
        if (el.scrollWidth > rect.width) {
          scrollX = el.scrollLeft;
          clientX = originalEvent.clientX();
          if ((0 < (ref = (d = clientX - rect.left)) && ref < threshold)) {
            scrollLeft = -(threshold - d) * scrollSpeed;
          } else if ((0 < (ref1 = (d = rect.right - clientX - dim.verticalScrollbarWidth)) && ref1 < threshold)) {
            scrollLeft = (threshold - d) * scrollSpeed;
          }
          ev.stopPropagation();
        }
        if (el.scrollHeight > rect.height) {
          scrollY = el.scrollTop;
          clientY = originalEvent.clientY();
          if ((0 < (ref2 = (d = clientY - rect.top)) && ref2 < threshold)) {
            scrollTop = -(threshold - d) * scrollSpeed;
          } else if ((0 < (ref3 = (d = rect.bottom - clientY - dim.horizontalScrollbarHeight)) && ref3 < threshold)) {
            scrollTop = (threshold - d) * scrollSpeed;
          }
        }
        if (!(scrollTop || scrollLeft)) {
          return;
        }
        oldScrollTop = el.scrollTop;
        oldScrollLeft = el.scrollLeft;
        if (scrollTop) {
          el.scrollTop += scrollTop;
        }
        if (scrollLeft) {
          el.scrollLeft += scrollLeft;
        }
        if (is_body) {
          if (!originalEvent.scrollPageY) {
            originalEvent.scrollPageY = 0;
          }
          originalEvent.scrollPageY += el.scrollTop - oldScrollTop;
          if (!originalEvent.scrollPageX) {
            originalEvent.scrollPageX = 0;
          }
          originalEvent.scrollPageX += originalEvent.scrollLeft - oldScrollLeft;
        }
        return ev.stopPropagation();
      }
    });
  };
})(this));
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Draggable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

globalDrag = null;

CUI.Draggable = (function(superClass) {
  extend(Draggable, superClass);

  function Draggable() {
    return Draggable.__super__.constructor.apply(this, arguments);
  }

  Draggable.cls = "draggable";

  Draggable.prototype.initOpts = function() {
    Draggable.__super__.initOpts.call(this);
    return this.addOpts({
      dragClass: {
        "default": "cui-dragging",
        check: String
      },
      helper: {
        "default": "clone",
        check: function(v) {
          return v === "clone" || isElement(v) || CUI.isFunction(v) || null;
        }
      },
      helper_contain_element: {
        check: function(v) {
          return isElement(v);
        }
      },
      helper_set_pos: {
        check: Function
      },
      get_cursor: {
        check: Function
      },
      support_touch: {
        check: Boolean
      },
      dragend: {
        check: Function
      },
      dragstop: {
        check: Function
      },
      dragstart: {
        check: Function
      },
      dragging: {
        check: Function
      },
      create: {
        "default": function() {
          return true;
        },
        check: Function
      },
      axis: {
        check: ["x", "y"]
      },
      threshold: {
        "default": 2,
        check: function(v) {
          return v >= 0;
        }
      },
      selector: {
        check: (function(_this) {
          return function(v) {
            return isString(v) || CUI.isFunction(v);
          };
        })(this)
      }
    });
  };

  Draggable.prototype.readOpts = function() {
    Draggable.__super__.readOpts.call(this);
    this.__autoRepeatTimeout = null;
    if (this.supportTouch()) {
      this.__event_types = {
        start: ["mousedown", "touchstart"],
        end: ["mouseup", "touchend"],
        move: ["mousemove", "touchmove"]
      };
    } else {
      this.__event_types = {
        start: ["mousedown"],
        end: ["mouseup"],
        move: ["mousemove"]
      };
    }
    return this;
  };

  Draggable.prototype.getClass = function() {
    if (!this._selector) {
      return "cui-draggable " + Draggable.__super__.getClass.call(this);
    } else {
      return Draggable.__super__.getClass.call(this);
    }
  };

  Draggable.prototype.supportTouch = function() {
    return !!this._support_touch;
  };

  Draggable.prototype.__killTimeout = function() {
    if (this.__autoRepeatTimeout) {
      CUI.clearTimeout(this.__autoRepeatTimeout);
      this.__autoRepeatTimeout = null;
    }
    return this;
  };

  Draggable.prototype.__cleanup = function() {
    this.__killTimeout();
    if (this.__ref) {
      Events.ignore({
        instance: this.__ref
      });
      this.__ref = null;
    }
    if ((globalDrag != null ? globalDrag.instance : void 0) === this) {
      globalDrag = null;
    }
  };

  Draggable.prototype.destroy = function() {
    Draggable.__super__.destroy.call(this);
    CUI.DOM.remove(globalDrag != null ? globalDrag.helperNode : void 0);
    this.__cleanup();
    return this;
  };

  Draggable.prototype.init = function() {
    assert(!this._helper_contain_element || CUI.DOM.closest(this._element, this._helper_contain_element), "new Draggable", "opts.helper_contain_element needs to be parent of opts.element", {
      opts: this.opts
    });
    DOM.addClass(this.element, "no-user-select");
    return Events.listen({
      type: this.__event_types.start,
      node: this.element,
      capture: true,
      instance: this,
      selector: this._selector,
      call: (function(_this) {
        return function(ev) {
          var $target, dim, position, target, target_dim;
          if (ev.getButton() > 0 && ev.getType() === "mousedown") {
            return;
          }
          if (window.globalDrag) {
            return;
          }
          position = elementGetPosition(getCoordinatesFromEvent(ev), $(ev.getTarget()));
          dim = DOM.getDimensions(ev.getTarget());
          if (dim.clientWidthScaled > 0 && position.left - dim.scrollLeftScaled > dim.clientWidthScaled) {
            console.warn("Mousedown on a vertical scrollbar, not starting drag.");
            return;
          }
          if (dim.clientHeightScaled > 0 && position.top - dim.scrollTopScaled > dim.clientHeightScaled) {
            console.warn("Mousedown on a horizontal scrollbar, not starting drag.");
            return;
          }
          target = ev.getCurrentTarget();
          target_dim = DOM.getDimensions(target);
          if (!DOM.isInDOM(target) || target_dim.clientWidth === 0 || target_dim.clientHeight === 0) {
            return;
          }
          if (CUI.DOM.closest(ev.getTarget(), "input,textarea,select")) {
            return;
          }
          $target = $(target);
          _this.init_drag(ev, $target);
        };
      })(this)
    });
  };

  Draggable.prototype.init_drag = function(ev, $target) {
    var dragover_count, dragover_scroll, end_drag, init, k, moveEvent, overwrite_options, point, position, v;
    overwrite_options = {};
    globalDrag = typeof this._create === "function" ? this._create(ev, overwrite_options, $target) : void 0;
    if (globalDrag === false) {
      return;
    }
    for (k in overwrite_options) {
      v = overwrite_options[k];
      this["_" + k] = v;
    }
    if (isNull(globalDrag) || globalDrag === true) {
      globalDrag = {};
    }
    assert(CUI.isPlainObject(globalDrag), "CUI.Draggable.init_drag", "returned data must be a plain object", {
      data: globalDrag
    });
    point = getCoordinatesFromEvent(ev);
    position = elementGetPosition(point, $target);
    init = {
      $source: $target,
      startEvent: ev,
      startCoordinates: point,
      instance: this,
      startScroll: {
        top: $target[0].scrollTop,
        left: $target[0].scrollLeft
      },
      start: position,
      threshold: this._threshold
    };
    for (k in init) {
      v = init[k];
      window.globalDrag[k] = v;
    }
    this.before_drag(ev, $target);
    this.__ref = new CUI.Dummy();
    dragover_count = 0;
    moveEvent = null;
    dragover_scroll = (function(_this) {
      return function() {
        var pointTarget;
        pointTarget = moveEvent.getPointTarget() || moveEvent.getTarget();
        Events.trigger({
          type: "dragover-scroll",
          node: pointTarget,
          count: dragover_count,
          originalEvent: moveEvent
        });
        dragover_count = dragover_count + 1;
        _this.__killTimeout();
        return _this.__autoRepeatTimeout = CUI.setTimeout({
          ms: 100,
          track: false,
          call: dragover_scroll
        });
      };
    })(this);
    Events.listen({
      node: document,
      type: this.__event_types.move,
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          var coordinates, diff, pointTarget;
          if (!globalDrag) {
            return;
          }
          ev.preventDefault();
          if (CUI.browser.firefox) {
            pointTarget = ev.getPointTarget();
          } else {
            pointTarget = ev.getTarget();
          }
          $target = $(pointTarget);
          if (globalDrag.ended) {
            return;
          }
          coordinates = getCoordinatesFromEvent(ev);
          diff = {
            x: coordinates.pageX - globalDrag.startCoordinates.pageX,
            y: coordinates.pageY - globalDrag.startCoordinates.pageY,
            eventPoint: coordinates
          };
          switch (_this.get_axis()) {
            case "x":
              diff.y = 0;
              break;
            case "y":
              diff.x = 0;
          }
          diff.bare_x = diff.x;
          diff.bare_y = diff.y;
          diff.x += globalDrag.$source.scrollLeft - globalDrag.startScroll.left;
          diff.y += globalDrag.$source.scrollTop - globalDrag.startScroll.top;
          if (Math.abs(diff.x) >= globalDrag.threshold || Math.abs(diff.y) >= globalDrag.threshold || globalDrag.dragStarted) {
            globalDrag.dragDiff = diff;
            if (!globalDrag.dragStarted) {
              globalDrag.startEvent.preventDefault();
              _this.__startDrag(ev, $target, diff);
              if (_this._get_cursor) {
                document.body.setAttribute("data-cursor", _this._get_cursor(globalDrag));
              } else {
                document.body.setAttribute("data-cursor", _this.getCursor());
              }
            }
            moveEvent = ev;
            dragover_scroll();
            _this.do_drag(ev, $target, diff);
            if (typeof _this._dragging === "function") {
              _this._dragging(ev, window.globalDrag, diff);
            }
          }
        };
      })(this)
    });
    end_drag = (function(_this) {
      return function(ev, stop) {
        var has_same_parents, noClickKill, start_target, start_target_parents;
        if (stop == null) {
          stop = false;
        }
        start_target = globalDrag.$source;
        start_target_parents = CUI.DOM.parents(start_target);
        globalDrag.ended = true;
        document.body.removeAttribute("data-cursor");
        if (stop) {
          globalDrag.stopped = true;
          _this.stop_drag(ev);
          if (typeof _this._dragstop === "function") {
            _this._dragstop(ev, globalDrag, _this);
          }
        } else {
          _this.end_drag(ev);
          if (typeof _this._dragend === "function") {
            _this._dragend(ev, globalDrag, _this);
          }
        }
        if (_this.isDestroyed()) {
          return;
        }
        noClickKill = globalDrag.noClickKill;
        _this.__cleanup();
        if (noClickKill) {
          return;
        }
        has_same_parents = function() {
          var i, idx, len, p, parents_now;
          parents_now = CUI.DOM.parents(start_target);
          for (idx = i = 0, len = start_target_parents.length; i < len; idx = ++i) {
            p = start_target_parents[idx];
            if (parents_now[idx] !== p) {
              return false;
            }
          }
          return true;
        };
        if (!has_same_parents || !CUI.DOM.isInDOM(ev.getTarget())) {
          return;
        }
        Events.listen({
          type: "click",
          capture: true,
          only_once: true,
          node: window,
          call: function(ev) {
            return ev.stop();
          }
        });
      };
    })(this);
    Events.listen({
      node: document,
      type: ["keyup"],
      capture: true,
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          if (!globalDrag.dragStarted) {
            _this.__cleanup();
            return;
          }
          if (ev.keyCode() === 27) {
            end_drag(ev, true);
            return ev.stop();
          }
        };
      })(this)
    });
    Events.listen({
      node: document,
      type: this.__event_types.end,
      capture: true,
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          if (!globalDrag) {
            return;
          }
          if (!globalDrag.dragStarted) {
            _this.__cleanup();
            return;
          }
          end_drag(ev);
          return ev.stop();
        };
      })(this)
    });
  };

  Draggable.prototype.getCursor = function() {
    return "grabbing";
  };

  Draggable.prototype.__startDrag = function(ev, $target, diff) {
    if (typeof this._dragstart === "function") {
      this._dragstart(ev, window.globalDrag);
    }
    this.init_helper(ev, $target, diff);
    globalDrag.$source.addClass(this._dragClass);
    this.start_drag(ev, $target, diff);
    return globalDrag.dragStarted = true;
  };

  Draggable.prototype.before_drag = function() {};

  Draggable.prototype.start_drag = function(ev, $target, diff) {};

  Draggable.prototype.do_drag = function(ev, $target, diff) {
    this.position_helper(ev, $target, diff);
    if (globalDrag.dragoverTarget && globalDrag.dragoverTarget[0] !== $target[0]) {
      Events.trigger({
        type: "cui-dragleave",
        node: globalDrag.dragoverTarget,
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
      globalDrag.dragoverTarget = null;
    }
    if (!globalDrag.dragoverTarget) {
      globalDrag.dragoverTarget = $target;
      Events.trigger({
        type: "cui-dragenter",
        node: globalDrag.dragoverTarget,
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
    }
    Events.trigger({
      node: globalDrag.dragoverTarget,
      type: "cui-dragover",
      info: {
        globalDrag: globalDrag,
        originalEvent: ev
      }
    });
  };

  Draggable.prototype.cleanup_drag = function(ev) {
    if (this.isDestroyed()) {
      return;
    }
    globalDrag.$source.removeClass(this._dragClass);
    return CUI.DOM.remove(globalDrag.helperNode);
  };

  Draggable.prototype.stop_drag = function(ev) {
    this.__finish_drag(ev);
    return this.cleanup_drag(ev);
  };

  Draggable.prototype.__finish_drag = function(ev) {
    if (!globalDrag.dragoverTarget) {
      return;
    }
    CUI.Events.trigger({
      node: globalDrag.dragoverTarget,
      type: "cui-dragleave",
      info: {
        globalDrag: globalDrag,
        originalEvent: ev
      }
    });
    if (!globalDrag.stopped) {
      CUI.Events.trigger({
        type: "cui-drop",
        node: globalDrag.dragoverTarget,
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
    }
    CUI.Events.trigger({
      node: globalDrag.dragoverTarget,
      type: "cui-dragend",
      info: {
        globalDrag: globalDrag,
        originalEvent: ev
      }
    });
    globalDrag.dragoverTarget = null;
    return this;
  };

  Draggable.prototype.end_drag = function(ev) {
    if (this.isDestroyed()) {
      return;
    }
    this.__finish_drag(ev);
    this.cleanup_drag(ev);
    return this;
  };

  Draggable.prototype.get_helper_pos = function(ev, gd, diff) {
    return {
      top: globalDrag.helperNodeStart.top + diff.y,
      left: globalDrag.helperNodeStart.left + diff.x,
      width: globalDrag.helperNodeStart.width,
      height: globalDrag.helperNodeStart.height
    };
  };

  Draggable.prototype.get_helper_contain_element = function() {
    return this._helper_contain_element;
  };

  Draggable.prototype.position_helper = function(ev, $target, diff) {
    var dim_contain, helper_contain_element, helper_pos, new_height, new_width, pos;
    if (!globalDrag.helperNode) {
      return;
    }
    helper_pos = this.get_helper_pos(ev, globalDrag, diff);
    pos = {
      x: helper_pos.left,
      y: helper_pos.top,
      w: helper_pos.width,
      h: helper_pos.height
    };
    helper_contain_element = this.get_helper_contain_element(ev, $target, diff);
    if (helper_contain_element) {
      dim_contain = CUI.DOM.getDimensions(helper_contain_element);
      if (dim_contain.clientWidth === 0 || dim_contain.clientHeight === 0) {
        console.warn('Draggable[position_helper]: Containing element has no dimensions.', helper_contain_element);
      }
      Draggable.limitRect(pos, {
        min_x: dim_contain.viewportLeft + dim_contain.borderLeftWidth,
        max_x: dim_contain.viewportRight - dim_contain.borderRightWidth - globalDrag.helperNodeStart.marginHorizontal,
        min_y: dim_contain.viewportTop + dim_contain.borderTopWidth,
        max_y: dim_contain.viewportBottom - dim_contain.borderBottomWidth - globalDrag.helperNodeStart.marginVertical
      });
    } else {
      dim_contain = globalDrag.helperNodeStart.body_dim;
      Draggable.limitRect(pos, {
        min_x: dim_contain.borderLeftWidth,
        max_x: dim_contain.scrollWidth - dim_contain.borderRightWidth - globalDrag.helperNodeStart.marginHorizontal,
        min_y: dim_contain.borderTopWidth,
        max_y: dim_contain.scrollHeight - dim_contain.borderBottomWidth - globalDrag.helperNodeStart.marginVertical
      });
    }
    helper_pos.top = pos.y;
    helper_pos.left = pos.x;
    helper_pos.dragDiff = {
      x: helper_pos.left - globalDrag.helperNodeStart.left,
      y: helper_pos.top - globalDrag.helperNodeStart.top
    };
    if (helper_pos.width !== globalDrag.helperNodeStart.width) {
      new_width = helper_pos.width;
    }
    if (helper_pos.height !== globalDrag.helperNodeStart.height) {
      new_height = helper_pos.height;
    }
    CUI.DOM.setStyle(globalDrag.helperNode, {
      transform: globalDrag.helperNodeStart.transform + " translateX(" + helper_pos.dragDiff.x + "px) translateY(" + helper_pos.dragDiff.y + "px)"
    });
    CUI.DOM.setDimensions(globalDrag.helperNode, {
      borderBoxWidth: new_width,
      borderBoxHeight: new_height
    });
  };

  Draggable.prototype.getCloneSourceForHelper = function() {
    return globalDrag.$source;
  };

  Draggable.prototype.get_axis = function() {
    return this._axis;
  };

  Draggable.prototype.get_helper = function(ev, gd, diff) {
    return this._helper;
  };

  Draggable.prototype.get_init_helper_pos = function(node, gd, offset) {
    if (offset == null) {
      offset = {
        top: 0,
        left: 0
      };
    }
    return {
      top: gd.startCoordinates.pageY - offset.top,
      left: gd.startCoordinates.pageX - offset.left
    };
  };

  Draggable.prototype.init_helper = function(ev, $target, diff) {
    var clone_source, dim, helper, hn, offset, set_dim, start;
    helper = this.get_helper(ev, window.globalDrag, diff);
    if (!helper) {
      return;
    }
    if (helper === "clone") {
      clone_source = this.getCloneSourceForHelper();
      hn = clone_source.cloneNode(true);
      hn.classList.remove("cui-selected");
      offset = {
        top: globalDrag.start.top,
        left: globalDrag.start.left
      };
    } else if (CUI.isFunction(helper)) {
      hn = globalDrag.helperNode = helper(globalDrag);
      set_dim = null;
    } else {
      hn = globalDrag.helperNode = helper;
    }
    if (!hn) {
      return;
    }
    globalDrag.helperNode = hn;
    CUI.DOM.addClass(hn, "cui-drag-drop-select-helper");
    document.body.appendChild(hn);
    start = this.get_init_helper_pos(hn, globalDrag, offset);
    CUI.DOM.setStyle(hn, start);
    if (helper === "clone") {
      set_dim = DOM.getDimensions(clone_source);
      DOM.setDimensions(hn, {
        marginBoxWidth: set_dim.marginBoxWidth,
        marginBoxHeight: set_dim.marginBoxHeight
      });
    }
    dim = DOM.getDimensions(hn);
    start.width = dim.borderBoxWidth;
    start.height = dim.borderBoxHeight;
    start.marginTop = dim.marginTop;
    start.marginLeft = dim.marginLeft;
    start.marginVertical = dim.marginVertical;
    start.marginHorizontal = dim.marginHorizontal;
    start.transform = dim.computedStyle.transform;
    if (start.transform === 'none') {
      start.transform = '';
    }
    start.body_dim = CUI.DOM.getDimensions(document.body);
    return globalDrag.helperNodeStart = start;
  };

  Draggable.limitRect = function(pos, limitRect, defaults) {
    var diff, i, k, key, len, mkey, ref, skey, v, value;
    if (defaults == null) {
      defaults = {};
    }
    pos.fix = pos.fix || [];
    for (k in defaults) {
      v = defaults[k];
      if (isUndef(pos[k])) {
        pos[k] = v;
      }
    }
    ref = ["min_w", "max_w", "min_h", "max_h", "min_x", "max_x", "min_y", "max_y"];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      value = limitRect[key];
      if (isUndef(value)) {
        continue;
      }
      assert(!isNaN(value), (getObjectClass(this)) + ".limitRect", "key " + key + " in pos isNaN", {
        pos: pos,
        defaults: defaults,
        limitRect: limitRect
      });
      skey = key.substring(4);
      mkey = key.substring(0, 3);
      if (key === "max_x") {
        value -= pos.w;
      }
      if (key === "max_y") {
        value -= pos.h;
      }
      diff = pos[skey] - value;
      if (mkey === "min") {
        if (diff >= 0) {
          continue;
        }
      }
      if (mkey === "max") {
        if (diff <= 0) {
          continue;
        }
      }
      if (skey === "y" && indexOf.call(pos.fix, "n") >= 0) {
        pos.h -= diff;
        continue;
      }
      if (skey === "x" && indexOf.call(pos.fix, "w") >= 0) {
        pos.w -= diff;
        continue;
      }
      pos[skey] -= diff;
      if (skey === "h" && indexOf.call(pos.fix, "s") >= 0) {
        pos.y += diff;
      }
      if (skey === "w" && indexOf.call(pos.fix, "e") >= 0) {
        pos.x += diff;
      }
      if (skey === "x" && indexOf.call(pos.fix, "e") >= 0) {
        pos.w += diff;
      }
      if (skey === "y" && indexOf.call(pos.fix, "s") >= 0) {
        pos.h += diff;
      }
    }
    return pos;
  };

  return Draggable;

})(CUI.DragDropSelect);

Draggable = CUI.Draggable;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Droppable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Droppable = (function(superClass) {
  extend(Droppable, superClass);

  function Droppable() {
    return Droppable.__super__.constructor.apply(this, arguments);
  }

  Droppable.cls = "droppable";

  Droppable.prototype.initOpts = function() {
    Droppable.__super__.initOpts.call(this);
    return this.addOpts({
      accept: {
        check: Function
      },
      drop: {
        "default": (function(_this) {
          return function(ev, info) {
            var pos;
            pos = info.dropTargetPos || "on";
            return CUI.alert({
              markdown: true,
              text: "You dropped me **" + pos + "**: " + CUI.DOM.getAttribute(info.dropTarget, "class")
            });
          };
        })(this),
        check: Function
      },
      hoverClass: {
        "default": "cui-droppable",
        check: String
      },
      dropHelper: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      targetHelper: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      selector: {
        check: (function(_this) {
          return function(v) {
            return isString(v) || CUI.isFunction(v);
          };
        })(this)
      }
    });
  };

  Droppable.prototype.accept = function(ev, info) {
    return typeof this._accept === "function" ? this._accept(ev, info) : void 0;
  };

  Droppable.prototype.destroy = function() {
    this.removeHelper();
    return Droppable.__super__.destroy.call(this);
  };

  Droppable.prototype.readOpts = function() {
    Droppable.__super__.readOpts.call(this);
    if (this._targetHelper) {
      assert(this._selector, "new Droppable", "opts.targetHelper needs opts.selector to be set.", {
        opts: this.opts
      });
    }
    if (this._dropHelper) {
      assert(!this._selector || this._targetHelper, "new Droppable", "opts.dropHelper does only work without opts.selector or with opts.targetHelper and opts.selector. needs opts.selector to be set.", {
        opts: this.opts
      });
      this.__dropHelper = CUI.DOM.element("DIV", {
        "class": "cui-droppable-drop-helper"
      });
    }
  };

  Droppable.prototype.removeHelper = function() {
    var el, i, len, ref;
    this.resetMargin();
    if (this.__selectedTarget) {
      CUI.DOM.removeClass(this.__selectedTarget, this._hoverClass);
      this.__selectedTarget = null;
    }
    if (this.__dropHelper) {
      CUI.DOM.remove(this.__dropHelper);
    }
    if (this._targetHelper) {
      ref = CUI.DOM.findElements(this._element, this._selector);
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        el.classList.remove("cui-droppable-target-helper");
      }
    }
    this.__dropTarget = void 0;
    return this.__dropTargetPos = void 0;
  };

  Droppable.prototype.resetMargin = function() {
    if (!this.__resetMargin) {
      return;
    }
    this.__resetMargin.classList.remove(this.__resetMargin.__target_helper_class);
    delete this.__resetMargin.__target_helper_class;
    delete this.__resetMargin;
    return delete this.__saveZoneDims;
  };

  Droppable.prototype.insideSaveZone = function(coord) {
    var buf, i, len, ref, ref1, ref2, zone;
    if (!this.__saveZoneDims) {
      return false;
    }
    buf = 5;
    ref = this.__saveZoneDims;
    for (i = 0, len = ref.length; i < len; i++) {
      zone = ref[i];
      if (((zone.viewportTopMargin - buf) <= (ref1 = coord.pageY) && ref1 <= (zone.viewportBottomMargin + buf)) && ((zone.viewportLeftMargin - buf) <= (ref2 = coord.pageX) && ref2 <= (zone.viewportRightMargin + buf))) {
        return true;
      }
    }
    return false;
  };

  Droppable.prototype.syncDropHelper = function() {
    var dim, drop_helper_dim;
    dim = CUI.DOM.getDimensions(this._element);
    document.body.appendChild(this.__dropHelper);
    CUI.DOM.setDimensions(this.__dropHelper, {
      contentBoxWidth: dim.borderBoxWidth,
      contentBoxHeight: dim.borderBoxHeight
    });
    drop_helper_dim = CUI.DOM.getDimensions(this.__dropHelper);
    return CUI.DOM.setStyle(this.__dropHelper, {
      position: "absolute",
      top: dim.viewportTop - drop_helper_dim.borderTopWidth - drop_helper_dim.marginTop,
      left: dim.viewportLeft - drop_helper_dim.borderLeftWidth - drop_helper_dim.marginLeft
    });
  };

  Droppable.prototype.syncTargetHelper = function(ev, info) {
    var acceptable, coord, dim, dropTarget, dropTargetPos, el, helper_cls, i, last_dim, len, new_target, ref, target;
    target = ev.getTarget();
    coord = getCoordinatesFromEvent(info.originalEvent);
    if (ev.getType() === "cui-dragleave") {
      new_target = info.originalEvent.getTarget();
      if (CUI.DOM.closest(new_target, ".cui-drag-drop-select-droppable") !== this._element) {
        this.removeHelper();
        return true;
      }
      if (this._targetHelper || !this._selector) {
        return;
      }
    }
    acceptable = (function(_this) {
      return function(dropTarget, dropTargetPos) {
        info.dropTarget = dropTarget;
        if (_this._targetHelper) {
          info.dropTargetPos = dropTargetPos;
        }
        if (_this.accept(ev, info) === false) {
          _this.removeHelper();
          return false;
        } else {
          return true;
        }
      };
    })(this);
    if (this.__dropTarget === void 0) {
      last_dim = null;
      this.__axis = null;
      ref = CUI.DOM.findElements(this._element, this._selector);
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        dim = CUI.DOM.getDimensions(el);
        if (last_dim && !this.__axis) {
          if (last_dim.viewportLeft === dim.viewportLeft) {
            this.__axis = "y";
          }
          if (last_dim.viewportTop === dim.viewportTop) {
            this.__axis = "x";
          }
        }
        if (this._targetHelper) {
          el.classList.add("cui-droppable-target-helper");
        }
        last_dim = dim;
      }
      if (!this.__axis) {
        this.__axis = "x";
      }
      this.__dropTargetPos = null;
      this.__dropTarget = null;
    }
    CUI.DOM.removeClass(this.__selectedTarget, this._hoverClass);
    if (this._selector) {
      this.__selectedTarget = CUI.DOM.closest(target, this._selector);
    } else {
      this.__selectedTarget = this._element;
    }
    if (!this._targetHelper) {
      if (!acceptable(this.__selectedTarget)) {
        this.removeHelper();
        if (this._selector && !this.__selectedTarget) {
          return true;
        }
        return;
      }
      this.__dropTarget = this.__selectedTarget;
      this.__dropTargetPos = null;
      CUI.DOM.addClass(this.__selectedTarget, this._hoverClass);
      if (this.__dropHelper) {
        this.syncDropHelper();
      }
      return;
    }
    if (!this.__selectedTarget) {
      if (this.insideSaveZone(coord)) {
        console.info("Inside save zone...");
        return;
      }
      this.resetMargin();
      if (this.__dropHelper) {
        if (!acceptable(this._element)) {
          return;
        }
        this.__dropTarget = this._element;
        this.__dropTargetPos = null;
        this.syncDropHelper();
      } else {
        console.info("No selected target, no dropHelper...");
        this.removeHelper();
        return true;
      }
      return;
    }
    CUI.DOM.remove(this.__dropHelper);
    dim = CUI.DOM.getDimensions(this.__selectedTarget);
    if ((this.__axis === "x" && coord.pageX > dim.viewportCenterLeft) || (this.__axis === "y" && coord.pageY > dim.viewportCenterTop)) {
      dropTargetPos = "after";
    } else {
      dropTargetPos = "before";
    }
    dropTarget = this.__selectedTarget;
    if (!acceptable(dropTarget, dropTargetPos)) {
      this.removeHelper();
      return;
    }
    this.__dropTarget = dropTarget;
    this.__dropTargetPos = dropTargetPos;
    helper_cls = "cui-droppable-target-helper-" + this.__axis + "--" + this.__dropTargetPos;
    if (this.__resetMargin === this.__selectedTarget && this.__selectedTarget.__target_helper_class === helper_cls) {

    } else {
      this.resetMargin();
      this.__saveZoneDims = [CUI.DOM.getDimensions(this.__selectedTarget)];
      this.__selectedTarget.__target_helper_class = helper_cls;
      this.__selectedTarget.addClass(this.__selectedTarget.__target_helper_class);
      this.__saveZoneDims.push(CUI.DOM.getDimensions(this.__selectedTarget));
      this.__resetMargin = this.__selectedTarget;
    }
  };

  Droppable.prototype.init = function() {
    Events.listen({
      node: this.element,
      type: "cui-dragend",
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          return _this.removeHelper();
        };
      })(this)
    });
    Events.listen({
      node: this.element,
      type: "cui-drop",
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          if (!_this.__dropTarget) {
            return;
          }
          info.dropTarget = _this.__dropTarget;
          if (_this._targetHelper) {
            info.dropTargetPos = _this.__dropTargetPos;
          }
          if (_this.accept(ev, info) !== false) {
            ev.stopPropagation();
            CUI.setTimeout({
              call: function() {
                return _this._drop(ev, info);
              }
            });
          }
        };
      })(this)
    });
    return Events.listen({
      node: this.element,
      type: ["cui-dragover", "cui-dragenter", "cui-dragleave"],
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          _this.syncTargetHelper(ev, info);
          ev.stopPropagation();
        };
      })(this)
    });
  };

  return Droppable;

})(CUI.DragDropSelect);

Droppable = CUI.Droppable;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Lasso, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

globalDrag = null;

CUI.Lasso = (function(superClass) {
  extend(Lasso, superClass);

  function Lasso() {
    return Lasso.__super__.constructor.apply(this, arguments);
  }

  Lasso.cls = "lasso";

  Lasso.prototype.initOpts = function() {
    Lasso.__super__.initOpts.call(this);
    this.addOpts({
      filter: {
        check: String
      },
      selected: {
        "default": function(ev, info) {
          return alert("You lassoed " + info.elements.length + " elements.");
        },
        check: Function
      },
      lasso_filter: {
        check: String
      },
      lassoed_element_class: {
        "default": "cui-selected",
        check: String
      }
    });
    return this.removeOpt("helper");
  };

  Lasso.prototype.readOpts = function() {
    Lasso.__super__.readOpts.call(this);
    return this._helper = null;
  };

  Lasso.prototype.init = function() {
    Lasso.__super__.init.call(this);
    this.element.addClass("cui-lasso-area");
    return this.position = null;
  };

  Lasso.prototype.start_drag = function(ev, $target, diff) {
    if (!CUI.DOM.isInDOM(this.element[0])) {
      throw "DragDropSelect: Creating lasso failed, element is not in DOM.";
    }
    globalDrag.lasso = $div("cui-lasso");
    globalDrag.lasso.appendTo(this.element);
    return globalDrag.elements = [];
  };

  Lasso.prototype.getCursor = function() {
    return "default";
  };

  Lasso.prototype.do_drag = function(ev, $target, diff) {
    var el, height, i, j, lassoed_elements, left, len, len1, over, ref, top, width;
    left = 0;
    top = 0;
    width = 0;
    height = 0;
    if (diff.x <= 0) {
      left = globalDrag.start.left + diff.x;
      width = -diff.x;
      over = -left;
      if (over > 0) {
        width -= over;
        left = 0;
      }
    } else {
      left = globalDrag.start.left;
      width = diff.x;
      over = left + width - this.element[0].scrollWidth;
      if (over > 0) {
        width -= over;
      }
    }
    if (diff.y <= 0) {
      top = globalDrag.start.top + diff.y;
      height = -diff.y;
      over = -top;
      if (over > 0) {
        height -= over;
        top = 0;
      }
    } else {
      top = globalDrag.start.top;
      height = diff.y;
      over = top + height - this.element[0].scrollHeight;
      if (over > 0) {
        height -= over;
      }
    }
    lassoed_elements = this.get_lassoed_elements();
    for (i = 0, len = lassoed_elements.length; i < len; i++) {
      el = lassoed_elements[i];
      if (indexOf.call(globalDrag.elements, el) < 0) {
        globalDrag.elements.push(el);
        CUI.DOM.toggleClass(el, this._lassoed_element_class);
      }
    }
    ref = globalDrag.elements.slice(0);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      el = ref[j];
      if (indexOf.call(lassoed_elements, el) < 0) {
        removeFromArray(el, globalDrag.elements);
        CUI.DOM.toggleClass(el, this._lassoed_element_class);
      }
    }
    return window.globalDrag.lasso.css("transform", "translate3d(" + left + "px," + top + "px,0) scale(" + width + "," + height + ")");
  };

  Lasso.prototype.get_lassoed_elements = function() {
    var do_overlap, el, get_dim, i, j, k, lassoed, lassoed_el, len, len1, len2, parents, ref, ref1, ref2;
    get_dim = function(el) {
      var dim;
      dim = el.getBoundingClientRect();
      return dim;
    };
    do_overlap = function(dims1, dims2) {
      var h1, h2, w1, w2, x1, x2, y1, y2;
      x1 = dims1.left;
      y1 = dims1.top;
      w1 = dims1.width;
      h1 = dims1.height;
      x2 = dims2.left;
      y2 = dims2.top;
      w2 = dims2.width;
      h2 = dims2.height;
      return !(y2 + h2 <= y1 || y1 + h1 <= y2 || x2 + w2 <= x1 || x1 + w1 <= x2);
    };
    globalDrag.lasso_dim = get_dim(globalDrag.lasso);
    lassoed = [];
    if (this._lasso_filter) {
      ref = CUI.DOM.matchSelector(globalDrag.$source, this._lasso_filter);
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        if (!do_overlap(globalDrag.lasso_dim, get_dim(el))) {
          continue;
        }
        if (this._filter) {
          lassoed_el = CUI.DOM.closest(el, this._filter, globalDrag.$source);
        } else {
          parents = CUI.DOM.parentsUntil(el, globalDrag.$source);
          lassoed_el = parents[parents.length - 2];
        }
        if (lassoed_el) {
          pushOntoArray(lassoed_el, lassoed);
        }
      }
    } else if (this._filter) {
      ref1 = CUI.DOM.matchSelector(globalDrag.$source, this._filter);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        el = ref1[j];
        if (do_overlap(globalDrag.lasso_dim, get_dim(el))) {
          pushOntoArray(el, lassoed);
        }
      }
    } else {
      ref2 = globalDrag.$source.children;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        el = ref2[k];
        if (do_overlap(globalDrag.lasso_dim, get_dim(el))) {
          lassoed.push(el);
        }
      }
    }
    return lassoed;
  };

  Lasso.prototype.stop_drag = function(ev) {
    var el, i, len, ref;
    ref = globalDrag.elements.slice(0);
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      removeFromArray(el, globalDrag.elements);
      CUI.DOM.toggleClass(el, this._lassoed_element_class);
    }
    return Lasso.__super__.stop_drag.call(this, ev);
  };

  Lasso.prototype.cleanup_drag = function(ev) {
    Lasso.__super__.cleanup_drag.call(this, ev);
    return globalDrag.lasso.remove();
  };

  Lasso.prototype.end_drag = function(ev) {
    this._selected(ev, globalDrag);
    return Lasso.__super__.end_drag.call(this, ev);
  };

  return Lasso;

})(CUI.Draggable);

Lasso = CUI.Lasso;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Sortable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Sortable = (function(superClass) {
  extend(Sortable, superClass);

  function Sortable() {
    return Sortable.__super__.constructor.apply(this, arguments);
  }

  Sortable.cls = "sortable";

  Sortable.prototype.initOpts = function() {
    Sortable.__super__.initOpts.call(this);
    this.addOpts({
      sorted: {
        mandatory: true,
        "default": function(ev, from_idx, to_idx) {
          return alert("You sorted item " + from_idx + " to " + to_idx + ".");
        },
        check: Function
      }
    });
    this.removeOpt("helper_contain_element");
    return this.mergeOpt("selector", {
      "default": function(target, node) {
        var els;
        els = CUI.DOM.elementsUntil(target, null, node);
        if (!els) {
          return null;
        }
        if (els.length > 1) {
          return els[els.length - 2];
        } else {
          return null;
        }
      }
    });
  };

  Sortable.prototype.readOpts = function() {
    Sortable.__super__.readOpts.call(this);
    return this._helper_contain_element = this._element;
  };

  Sortable.prototype.get_child_number = function(child) {
    var c, i, idx, len, ref;
    ref = this.element.children;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      c = ref[idx];
      if (c === child) {
        return idx;
      }
    }
    return null;
  };

  Sortable.prototype.move_element = function(source_idx, dest_idx) {
    var $dest, $source;
    $source = this.element.children[source_idx];
    $dest = this.element.children[dest_idx];
    if (source_idx === dest_idx) {
      return;
    }
    if (source_idx < dest_idx) {
      globalDrag.noClickKill = true;
      CUI.DOM.insertAfter($dest, $source);
    } else if (source_idx > dest_idx) {
      globalDrag.noClickKill = true;
      CUI.DOM.insertBefore($dest, $source);
    }
    CUI.DOM.syncAnimatedClone(this.element);
    return this;
  };

  Sortable.prototype.start_drag = function(ev, $target, diff) {
    globalDrag.sort_source = this.__findClosestSon(globalDrag.$source);
    globalDrag.sort_source.classList.add("cui-sortable-placeholder");
    globalDrag.start_idx = this.get_child_number(globalDrag.sort_source);
    CUI.DOM.addClass(this.element, 'cui-sorting');
    return CUI.DOM.initAnimatedClone(this.element);
  };

  Sortable.prototype.getCloneSourceForHelper = function() {
    return this.__findClosestSon(globalDrag.$source);
  };

  Sortable.prototype.__findClosestSon = function($target) {
    var parents;
    parents = CUI.DOM.parentsUntil($target, null, this.element);
    if (parents[parents.length - 1] === window) {
      return null;
    }
    switch (parents.length) {
      case 0:
        return null;
      case 1:
        return $target;
      default:
        return parents[parents.length - 2];
    }
  };

  Sortable.prototype.do_drag = function(ev, $target, diff) {
    var dest_idx, source_idx, target_child;
    this.position_helper(ev, $target, diff);
    target_child = this.__findClosestSon($target);
    if (!target_child) {
      return;
    }
    source_idx = this.get_child_number(globalDrag.sort_source);
    dest_idx = this.get_child_number(target_child);
    return this.move_element(source_idx, dest_idx);
  };

  Sortable.prototype.stop_drag = function(ev) {
    Sortable.__super__.stop_drag.call(this, ev);
    return this.__end_drag(ev, true);
  };

  Sortable.prototype.end_drag = function(ev) {
    Sortable.__super__.end_drag.call(this, ev);
    return this.__end_drag(ev, false);
  };

  Sortable.prototype.cleanup_drag = function(ev) {
    Sortable.__super__.cleanup_drag.call(this, ev);
    CUI.DOM.removeClass(this.element, 'cui-sorting');
    globalDrag.sort_source.classList.remove("cui-sortable-placeholder");
    return CUI.DOM.removeAnimatedClone(this.element);
  };

  Sortable.prototype.__end_drag = function(ev, stopped) {
    var curr_idx;
    curr_idx = this.get_child_number(globalDrag.sort_source);
    if (globalDrag.start_idx === curr_idx) {
      return;
    }
    if (stopped) {
      this.move_element(curr_idx, globalDrag.start_idx);
    } else {
      this._sorted(ev, globalDrag.start_idx, curr_idx);
    }
  };

  return Sortable;

})(CUI.Draggable);

Sortable = CUI.Sortable;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Movable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Movable = (function(superClass) {
  extend(Movable, superClass);

  function Movable() {
    return Movable.__super__.constructor.apply(this, arguments);
  }

  Movable.cls = "movable";

  Movable.prototype.initOpts = function() {
    Movable.__super__.initOpts.call(this);
    this.addOpts({
      limitRect: {
        "default": {},
        check: function(v) {
          return CUI.isPlainObject(v) || v instanceof Function;
        }
      },
      onPositioned: {
        check: Function
      },
      onPosition: {
        check: Function
      },
      start_drag: {
        check: Function
      },
      do_drag: {
        check: Function
      }
    });
    return this.removeOpt("helper");
  };

  Movable.prototype.readOpts = function() {
    Movable.__super__.readOpts.call(this);
    return this._helper = null;
  };

  Movable.prototype.getLimitRect = function() {
    if (CUI.isFunction(this._limitRect)) {
      return this._limitRect();
    } else {
      return this._limitRect;
    }
  };

  Movable.prototype.setElementCss = function(pos) {
    var setCss;
    assert(CUI.isPlainObject(pos), getObjectClass(this), "opts.position must return a PlainObject containing any of x, y, w, h", {
      pos: pos
    });
    setCss = {};
    if (!isEmpty(pos.x)) {
      setCss.left = pos.x;
    }
    if (!isEmpty(pos.y)) {
      setCss.top = pos.y;
    }
    if (!isEmpty(pos.w)) {
      setCss.marginBoxWidth = pos.w;
    }
    if (!isEmpty(pos.h)) {
      setCss.marginBoxHeight = pos.h;
    }
    CUI.DOM.setDimensions(this.element[0], setCss);
    return typeof this._onPositioned === "function" ? this._onPositioned(pos) : void 0;
  };

  Movable.prototype.init_drag = function(ev, $target) {
    if (CUI.DOM.closest(ev.getTarget(), ".cui-resizable-handle")) {
      return;
    }
    return Movable.__super__.init_drag.call(this, ev, $target);
  };

  Movable.prototype.before_drag = function() {
    var dim;
    dim = CUI.DOM.getDimensions(this.element[0]);
    this.start = {
      x: dim.left || 0,
      y: dim.top || 0,
      w: dim.marginBoxWidth,
      h: dim.marginBoxHeight
    };
    return this;
  };

  Movable.prototype.start_drag = function(ev, $target, diff) {
    if (this._start_drag) {
      this._start_drag(ev, $target, diff, this);
    }
    return this;
  };

  Movable.prototype.do_drag = function(ev, $target, diff) {
    var pos, ref;
    if (this._do_drag) {
      this._do_drag(ev, $target, diff, this);
      return this;
    }
    pos = {
      x: diff.x + this.start.x,
      y: diff.y + this.start.y,
      w: this.start.w,
      h: this.start.h
    };
    if (this._onPosition) {
      ref = this._onPosition(pos.x, pos.y, this.start, diff), pos.x = ref[0], pos.y = ref[1];
    } else {
      this.limitRect(pos, this.start);
    }
    this.setElementCss(pos);
    return this;
  };

  Movable.prototype.limitRect = function(pos, defaults, limitRect) {
    if (defaults == null) {
      defaults = {};
    }
    if (limitRect == null) {
      limitRect = this.getLimitRect();
    }
    return Draggable.limitRect(pos, limitRect, defaults);
  };

  return Movable;

})(CUI.Draggable);

Movable = CUI.Movable;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var globalDrag,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Resizable = (function(superClass) {
  extend(Resizable, superClass);

  function Resizable() {
    this.getResizePos = bind(this.getResizePos, this);
    return Resizable.__super__.constructor.apply(this, arguments);
  }

  Resizable.cls = "resizable";

  Resizable.prototype.initOpts = function() {
    Resizable.__super__.initOpts.call(this);
    return this.removeOpt("selector");
  };

  Resizable.prototype.readOpts = function() {
    Resizable.__super__.readOpts.call(this);
    return this._selector = ".cui-resizable-handle";
  };

  Resizable.prototype.init = function() {
    var d, i, len, ref, results;
    Resizable.__super__.init.call(this);
    ref = ["ne", "nw", "se", "sw", "s", "n", "e", "w"];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      d = ref[i];
      results.push(this.element.append(CUI.DOM.element("DIV", {
        "cui-drag-drop-select-resizable": d,
        "class": "cui-resizable-handle cui-resizable-handle-" + d
      })));
    }
    return results;
  };

  Resizable.prototype.before_drag = function(ev, $target) {
    Resizable.__super__.before_drag.call(this, ev, $target);
    return globalDrag.resize = $target.attr("cui-drag-drop-select-resizable");
  };

  Resizable.prototype.init_drag = function(ev, $target) {
    return Draggable.prototype.init_drag.call(this, ev, $target);
  };

  Resizable.prototype.start_drag = function(ev, $target, diff) {
    if (this._start_drag) {
      return this._start_drag(ev, $target, diff, this);
    }
  };

  Resizable.prototype.do_drag = function(ev, $target, diff) {
    if (this._do_drag) {
      return this._do_drag(ev, $target, diff, this);
    }
    return this.setElementCss(this.getResizePos(this.start, diff));
  };

  Resizable.prototype.getResizePos = function(start, diff, limitRect) {
    var pos;
    if (limitRect == null) {
      limitRect = this.getLimitRect();
    }
    switch (globalDrag.resize) {
      case "se":
        pos = {
          w: start.w + diff.x,
          h: start.h + diff.y,
          fix: ["n", "w"]
        };
        break;
      case "sw":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          h: start.h + diff.y,
          fix: ["n", "e"]
        };
        break;
      case "ne":
        pos = {
          w: start.w + diff.x,
          y: start.y + diff.y,
          h: start.h - diff.y,
          fix: ["s", "e"]
        };
        break;
      case "nw":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          y: start.y + diff.y,
          h: start.h - diff.y,
          fix: ["e", "s"]
        };
        break;
      case "s":
        pos = {
          h: start.h + diff.y,
          fix: ["n"]
        };
        break;
      case "n":
        pos = {
          h: start.h - diff.y,
          y: start.y + diff.y,
          fix: ["s"]
        };
        break;
      case "e":
        pos = {
          w: start.w + diff.x,
          fix: ["w"]
        };
        break;
      case "w":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          fix: ["e"]
        };
    }
    return this.limitRect(pos, start, limitRect);
  };

  return Resizable;

})(CUI.Movable);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Dragscroll = (function(superClass) {
  extend(Dragscroll, superClass);

  function Dragscroll() {
    return Dragscroll.__super__.constructor.apply(this, arguments);
  }

  Dragscroll.prototype.initOpts = function() {
    Dragscroll.__super__.initOpts.call(this);
    this.removeOpt("helper");
    return this.addOpts({
      scroll_element: {
        check: function(v) {
          return isElement(v);
        }
      }
    });
  };

  Dragscroll.prototype.readOpts = function() {
    Dragscroll.__super__.readOpts.call(this);
    if (this._scroll_element) {
      return this.__scroll_element = this._scroll_element;
    } else {
      return this.__scroll_element = this._element;
    }
  };

  Dragscroll.prototype.supportTouch = function() {
    if (this._support_touch !== void 0) {
      return Dragscroll.__super__.supportTouch.call(this);
    } else {
      return true;
    }
  };

  Dragscroll.prototype.start_drag = function() {
    return this.__scroll = {
      top: this.__scroll_element.scrollTop,
      left: this.__scroll_element.scrollLeft
    };
  };

  Dragscroll.prototype.do_drag = function(ev, $target, diff) {
    var scrollLeft, scrollTop;
    scrollTop = this.__scroll.top - diff.bare_y;
    scrollLeft = this.__scroll.left - diff.bare_x;
    this.__scroll_element.scrollTop = scrollTop;
    return this.__scroll_element.scrollLeft = scrollLeft;
  };

  return Dragscroll;

})(CUI.Draggable);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Event = (function(superClass) {
  extend(Event, superClass);

  function Event(opts) {
    this.opts = opts != null ? opts : {};
    Event.__super__.constructor.call(this, this.opts);
    if (this._require_node_in_dom) {
      console.debug("require node in dom", this.isInDOM(), this.__node);
      assert(this.isInDOM(), "new Event", "node is not in DOM, unable to create event.", {
        opts: this.opts
      });
    }
    this.__propagationStopped = false;
    this.__propagationImmediateStopped = false;
    this.__preventDefault = false;
    this.__dragPrevented = false;
  }

  Event.prototype.initOpts = function() {
    Event.__super__.initOpts.call(this);
    return this.addOpts({
      type: {
        mandatory: true,
        check: function(v) {
          return isString(v) && !isEmpty(v) && v.split(/\s+/).length === 1;
        }
      },
      node: {
        "default": document.documentElement,
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      require_node_in_dom: {
        "default": false,
        mandatory: true,
        check: Boolean
      },
      bubble: {
        "default": false,
        check: Boolean
      },
      sink: {
        "default": false,
        check: Boolean
      },
      exclude_self: {
        "default": false,
        check: Boolean
      },
      info: {
        "default": {},
        check: "PlainObject"
      },
      prevent_default: {
        "default": false,
        check: Boolean
      },
      onProgress: {
        check: Function
      }
    });
  };

  Event.prototype.readOpts = function() {
    Event.__super__.readOpts.call(this);
    this.__node = DOM.getNode(this._node);
    if (this._preventDefault) {
      this.preventDefault();
    }
    this.__listenerClass = null;
    this.__progress_counter = 0;
    return this.__isInDOM = null;
  };

  Event.prototype.setListener = function(listener) {
    if (!this.__listenerClass) {
      this.__listenerClass = listener.getElementClass();
    } else {
      assert(this.__listenerClass === listener.getElementClass(), "Event.setListener", "listener class cannot change during an events life cycle.", {
        listener: listener,
        listenerClass: this.__listenerClass
      });
    }
    return this;
  };

  Event.prototype.progress = function(listener, ret) {
    this.__progress_counter++;
    if (typeof this._onProgress === "function") {
      this._onProgress(listener, ret, this.__progress_counter);
    }
    return this.__progress_counter;
  };

  Event.prototype.isExcludeSelf = function() {
    return this._exclude_self;
  };

  Event.prototype.setPhase = function(__phase) {
    this.__phase = __phase;
  };

  Event.prototype.getPhase = function() {
    return this.__phase;
  };

  Event.prototype.getType = function() {
    return this._type;
  };

  Event.prototype.getDebug = function() {
    return this._type + "[" + this.getUniqueId() + "#" + this.__progress_counter + "]";
  };

  Event.prototype.getInfo = function() {
    return this._info;
  };

  Event.prototype.getNode = function() {
    return this.__node;
  };

  Event.prototype.getElement = function() {
    return DOM.data(this.getNode(), "element");
  };

  Event.prototype.isBubble = function() {
    return this._bubble;
  };

  Event.prototype.isSink = function() {
    return this._sink;
  };

  Event.prototype.isInDOM = function() {
    if (this.__isInDOM !== null) {
      return this.__isInDOM;
    } else if (this.__node === document || this.__node === window) {
      return this.__isInDOM = true;
    } else {
      return this.__isInDOM = DOM.isInDOM(this.__node);
    }
  };

  Event.prototype.setNativeEvent = function(NativeEvent) {
    assert(NativeEvent instanceof window.Event, "CUI.Event.setNativeEvent", "Event needs to be instanceof Event", {
      Event: NativeEvent
    });
    this.__NativeEvent = NativeEvent;
    return this;
  };

  Event.prototype.getNativeEvent = function() {
    return this.__NativeEvent;
  };

  Event.prototype.getPointTarget = function() {
    return document.elementFromPoint(this.clientX(), this.clientY());
  };

  Event.prototype.getTarget = function() {
    var ref;
    return this.__target || ((ref = this.getNativeEvent()) != null ? ref.target : void 0);
  };

  Event.prototype.setTarget = function(tg) {
    return this.__target = tg;
  };

  Event.prototype.getCurrentTarget = function() {
    return this.__currentTarget || this.getTarget();
  };

  Event.prototype.setCurrentTarget = function(ct) {
    return this.__currentTarget = ct;
  };

  Event.prototype.getModifiers = function() {
    var k, mods, ref, v;
    mods = [];
    ref = {
      meta: "Meta",
      ctrl: "Control",
      alt: "Alt",
      shift: "Shift"
    };
    for (k in ref) {
      v = ref[k];
      if (this[k + "Key"]()) {
        mods.push(v);
      }
    }
    return mods;
  };

  Event.prototype.hasModifierKey = function(includeShift) {
    if (includeShift == null) {
      includeShift = false;
    }
    return this.metaKey() || this.ctrlKey() || this.altKey() || (includeShift && this.shiftKey());
  };

  Event.prototype.getButton = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.button : void 0;
  };

  Event.prototype.keyCode = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.which : void 0;
  };

  Event.prototype.metaKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.metaKey : void 0;
  };

  Event.prototype.ctrlKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.ctrlKey : void 0;
  };

  Event.prototype.altKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.altKey : void 0;
  };

  Event.prototype.shiftKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.shiftKey : void 0;
  };

  Event.prototype.clientX = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.clientX : void 0;
  };

  Event.prototype.clientY = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.clientY : void 0;
  };

  Event.prototype.pageX = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.pageX : void 0;
  };

  Event.prototype.pageY = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.pageY : void 0;
  };

  Event.prototype.stopImmediatePropagation = function() {
    var ref;
    this.__propagationImmediateStopped = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.stopImmediatePropagation();
    }
    return this;
  };

  Event.prototype.stopPropagation = function() {
    var ref;
    this.__propagationStopped = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.stopPropagation();
    }
    return this;
  };

  Event.prototype.preventDefault = function() {
    var ref;
    this.__defaultPrevented = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.preventDefault();
    }
    return this;
  };

  Event.prototype.isImmediatePropagationStopped = function() {
    return this.__propagationImmediateStopped;
  };

  Event.prototype.isPropagationStopped = function() {
    return this.__propagationStopped;
  };

  Event.prototype.isDefaultPrevented = function() {
    return this.__defaultPrevented;
  };

  Event.prototype.dispatch = function() {
    var ev, node;
    assert(!this.getNativeEvent(), "CUI.Event.dispatch", "Can only dispatch once.", {
      event: this
    });
    ev = document.createEvent("Event");
    ev.initEvent(this.getType(), this.isBubble(), true);
    ev.__cui_event = this;
    if (this.isExcludeSelf()) {
      node = DOM.parent(this.getNode());
    } else {
      node = this.getNode();
    }
    if (this.isDefaultPrevented()) {
      ev.preventDefault();
    }
    this.setNativeEvent(ev);
    node.dispatchEvent(ev);
    return ev;
  };

  Event.prototype.dump = function() {
    var mods, txt;
    txt = this.__cls + ": **" + this.getType() + "**";
    mods = this.getModifiers();
    if (mods.length > 0) {
      txt += " Modifiers: **" + mods.join("+") + "**";
    }
    return txt;
  };

  Event.prototype.stop = function() {
    this.preventDefault();
    this.stopPropagation();
    this.stopImmediatePropagation();
    return false;
  };

  Event.require = function(event, func) {
    var ev, ev_info, eventClass;
    if (CUI.isPlainObject(event)) {
      ev_info = Events.getEventType(event.type);
      if (ev_info.eventClass) {
        eventClass = ev_info.eventClass;
      } else {
        eventClass = CUI.Event;
      }
      CUI.mergeMap(event, ev_info);
      delete event.eventClass;
      delete event.listenerClass;
      ev = new eventClass(event);
    } else {
      ev = event;
    }
    assert(ev instanceof CUI.Event, "" + func, "event needs to be PlainObject or instance of CUI.Event.");
    return ev;
  };

  Event.createFromDOMEvent = function(event, eventClass) {
    var ev, ev_info;
    ev_info = CUI.Events.getEventType(event.type);
    if (!eventClass) {
      if (ev_info.eventClass) {
        eventClass = ev_info.eventClass;
      } else {
        eventClass = CUI.Event;
      }
    }
    ev = new eventClass({
      type: event.type,
      bubble: event.bubbles,
      node: event.target
    });
    ev.setNativeEvent(event);
    return ev;
  };

  return Event;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.MouseEvent = (function(superClass) {
  extend(MouseEvent, superClass);

  function MouseEvent() {
    return MouseEvent.__super__.constructor.apply(this, arguments);
  }

  MouseEvent.prototype.initOpts = function() {
    MouseEvent.__super__.initOpts.call(this);
    return this.addOpts({
      button: {
        check: function(v) {
          return v >= 0;
        }
      },
      pageX: {
        check: function(v) {
          return v > 0;
        }
      },
      pageY: {
        check: function(v) {
          return v > 0;
        }
      },
      clientX: {
        check: function(v) {
          return v > 0;
        }
      },
      clientY: {
        check: function(v) {
          return v > 0;
        }
      }
    });
  };

  MouseEvent.prototype.setNativeEvent = function(ev) {
    var i, k, len, prop, ref;
    ref = ["button", "pageX", "pageY", "clientX", "clientY"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      prop = "_" + k;
      if (this.hasOwnProperty(prop)) {
        ev[k] = this[prop];
      }
    }
    return MouseEvent.__super__.setNativeEvent.call(this, ev);
  };

  return MouseEvent;

})(CUI.Event);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.KeyboardEvent = (function(superClass) {
  extend(KeyboardEvent, superClass);

  function KeyboardEvent() {
    return KeyboardEvent.__super__.constructor.apply(this, arguments);
  }

  KeyboardEvent.prototype.getKeys = function() {
    return CUI.KeyboardEvent.__keys;
  };

  KeyboardEvent.prototype.getKeyboard = function() {
    var keys;
    keys = this.getModifiers();
    keys.push.apply(keys, this.getKeys());
    return keys.join("+");
  };

  KeyboardEvent.prototype.keyboardKey = function() {
    var key, s;
    key = this.keyCode();
    if (indexOf.call([96, 97, 98, 99, 100, 101, 102, 103, 104, 105], key) >= 0) {
      s = "Num" + String.fromCharCode(key - 48);
    }
    if (indexOf.call([112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123], key) >= 0) {
      s = "F" + String.fromCharCode(key - 111);
    } else {
      switch (key) {
        case 8:
          s = "Backspace";
          break;
        case 9:
          s = "Tab";
          break;
        case 13:
          s = "Return";
          break;
        case 16:
          s = "Shift";
          break;
        case 17:
          s = "Ctrl";
          break;
        case 18:
          s = "Alt";
          break;
        case 20:
          s = "CapsLock";
          break;
        case 27:
          s = "Esc";
          break;
        case 32:
          s = "Space";
          break;
        case 33:
          s = "PageUp";
          break;
        case 34:
          s = "PageDown";
          break;
        case 37:
          s = "Left";
          break;
        case 38:
          s = "Up";
          break;
        case 39:
          s = "Right";
          break;
        case 40:
          s = "Down";
          break;
        case 46:
          s = "Insert";
          break;
        case 46:
          s = "Delete";
          break;
        case 110:
          s = "Num.";
          break;
        case 144:
          s = "Numlock";
          break;
        case 111:
          s = "Num/";
          break;
        case 106:
          s = "Num*";
          break;
        case 107:
          s = "Num+";
          break;
        default:
          s = String.fromCharCode(key);
      }
    }
    return s;
  };

  KeyboardEvent.prototype.key = function() {
    return this.getNativeEvent().key;
  };

  KeyboardEvent.prototype.dump = function() {
    var keyboard, txt;
    txt = this.__cls + ": **" + this.getType() + "**";
    txt += " Key: **" + this.key() + "** KeyCode: **" + this.keyCode() + "**";
    keyboard = this.getKeyboard();
    if (keyboard.length > 0) {
      txt = txt + " Keyboard: **" + keyboard + "**";
    }
    return txt;
  };

  KeyboardEvent.isModifierKey = function(keyCode) {
    switch (keyCode) {
      case 16:
      case 17:
      case 18:
      case 91:
      case 93:
        return true;
      default:
        return false;
    }
  };

  KeyboardEvent.initKeyboardListener = function() {
    CUI.KeyboardEvent.__keys = [];
    CUI.KeyboardEvent.__modifier_keys = [];
    Events.listen({
      type: ["keydown"],
      node: window,
      capture: true,
      call: function(ev) {
        if (!KeyboardEvent.isModifierKey(ev.keyCode())) {
          pushOntoArray(ev.keyboardKey(), CUI.KeyboardEvent.__keys);
        }
      }
    });
    Events.listen({
      type: ["keyup"],
      node: window,
      capture: true,
      call: function(ev) {
        if (!KeyboardEvent.isModifierKey(ev.keyCode())) {
          removeFromArray(ev.keyboardKey(), CUI.KeyboardEvent.__keys);
        }
      }
    });
    return Events.listen({
      type: ["blur"],
      node: window,
      capture: true,
      call: function(ev) {
        return CUI.KeyboardEvent.__keys = [];
      }
    });
  };

  return KeyboardEvent;

})(CUI.Event);

CUI.ready((function(_this) {
  return function() {
    return CUI.KeyboardEvent.initKeyboardListener();
  };
})(this));
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.TouchEvent = (function(superClass) {
  extend(TouchEvent, superClass);

  function TouchEvent() {
    return TouchEvent.__super__.constructor.apply(this, arguments);
  }

  TouchEvent.prototype.initOpts = function() {
    TouchEvent.__super__.initOpts.call(this);
    return this.addOpts({
      button: {
        check: function(v) {
          return v >= 0;
        }
      },
      pageX: {
        check: function(v) {
          return v > 0;
        }
      },
      pageY: {
        check: function(v) {
          return v > 0;
        }
      },
      clientX: {
        check: function(v) {
          return v > 0;
        }
      },
      clientY: {
        check: function(v) {
          return v > 0;
        }
      }
    });
  };

  TouchEvent.prototype.setNativeEvent = function(ev) {
    var i, k, len, prop, ref;
    ref = ["button", "pageX", "pageY", "clientX", "clientY"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      prop = "_" + k;
      if (this.hasOwnProperty(prop)) {
        ev[k] = this[prop];
      }
    }
    return TouchEvent.__super__.setNativeEvent.call(this, ev);
  };

  return TouchEvent;

})(CUI.MouseEvent);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.CUIEvent = (function(superClass) {
  extend(CUIEvent, superClass);

  function CUIEvent() {
    return CUIEvent.__super__.constructor.apply(this, arguments);
  }

  return CUIEvent;

})(CUI.Event);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Listener = (function(superClass) {
  extend(Listener, superClass);

  function Listener() {
    return Listener.__super__.constructor.apply(this, arguments);
  }

  Listener.prototype.initOpts = function() {
    Listener.__super__.initOpts.call(this);
    return this.addOpts({
      type: {
        mandatory: true,
        check: function(v) {
          return isString(v) || CUI.isArray(v);
        }
      },
      node: {
        "default": document.documentElement,
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      call: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v);
        }
      },
      only_once: {
        check: Boolean
      },
      selector: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v);
        }
      },
      instance: {},
      capture: {
        "default": false,
        check: Boolean
      }
    });
  };

  Listener.prototype.readOpts = function() {
    var ev, i, len, ref, type;
    Listener.__super__.readOpts.call(this);
    if (isString(this._type)) {
      this.__types = this._type.split(/\s+/);
    } else {
      this.__types = this._type;
    }
    this.__node = CUI.DOM.getNode(this._node);
    ref = this.__types;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      ev = Events.getEventType(type);
    }
    if (isString(this._selector)) {
      assert(this.__node instanceof HTMLElement || this.__node === document, "new CUI.Listener", "opts.selector requires the node to be instance of HTMLElement.", {
        opts: this.opts
      });
    }
    this.__handleDOMEvent = (function(_this) {
      return function(ev) {
        return _this.handleDOMEvent(ev);
      };
    })(this);
    if (this._selector) {
      if (isString(this._selector)) {
        this.__selector = (function(_this) {
          return function(target, node) {
            return DOM.closestUntil(target, _this._selector, node);
          };
        })(this);
      } else {
        this.__selector = this._selector;
      }
    }
    this.registerDOMEvent();
    return this;
  };

  Listener.prototype.isCapture = function() {
    return this._capture;
  };

  Listener.prototype.getNode = function() {
    return this.__node;
  };

  Listener.prototype.getTypes = function() {
    return this.__types;
  };

  Listener.prototype.registerDOMEvent = function() {
    var _type, i, j, len, len1, ref, ref1, type;
    ref = this.getTypes();
    for (i = 0, len = ref.length; i < len; i++) {
      _type = ref[i];
      ref1 = Events.getEventTypeAliases(_type);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        type = ref1[j];
        this.__node.addEventListener(type, this.__handleDOMEvent, this.isCapture());
      }
    }
    return this;
  };

  Listener.prototype.handleDOMEvent = function(ev) {
    var currentTarget, event, ret;
    if (this.__selector) {
      currentTarget = this.__selector(ev.target, this.__node);
      if (!currentTarget) {
        return false;
      }
    } else {
      currentTarget = this.__node;
    }
    if (ev.__cui_event) {
      event = ev.__cui_event;
    } else {
      event = CUI.Event.createFromDOMEvent(ev);
      ev.__cui_event = event;
    }
    event.setCurrentTarget(currentTarget);
    if (this.isCapture()) {
      ret = this.handleEvent(event, "capture");
    } else {
      ret = this.handleEvent(event, "bubble");
    }
    return ret;
  };

  Listener.prototype.isOnlyOnce = function() {
    return this._only_once;
  };

  Listener.prototype.destroy = function() {
    var _type, i, j, len, len1, ref, ref1, type;
    if (this.isDestroyed()) {
      return;
    }
    Events.unregisterListener(this);
    ref = this.getTypes();
    for (i = 0, len = ref.length; i < len; i++) {
      _type = ref[i];
      ref1 = Events.getEventTypeAliases(_type);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        type = ref1[j];
        this.__node.removeEventListener(type, this.__handleDOMEvent, this.isCapture());
      }
    }
    return Listener.__super__.destroy.call(this);
  };

  Listener.prototype.matchesEvent = function(event) {
    var ev_node, i, len, parent, ref, ref1;
    assert(event instanceof CUI.Event, "CUI.Listener.matchesEvent", "event needs to be instance of CUI.Event.");
    delete this.__depth;
    if (ref = event.getType(), indexOf.call(this.getTypes(), ref) < 0) {
      return null;
    }
    ev_node = event.getNode();
    this.__depth = 0;
    if (this.isCapture()) {
      return null;
    }
    if (!event.isExcludeSelf() && !event.isBubble() && event.isInDOM()) {
      if (this.__node === ev_node) {
        return this.__depth;
      }
    }
    if (event.isSink()) {
      ref1 = DOM.parents(this.__node);
      for (i = 0, len = ref1.length; i < len; i++) {
        parent = ref1[i];
        this.__depth++;
        if (parent === ev_node) {
          return this.__depth;
        }
      }
    }
    delete this.__depth;
    return null;
  };

  Listener.prototype.getDepthFromLastMatchedEvent = function() {
    return this.__depth;
  };

  Listener.prototype.handleEvent = function(event, phase) {
    var info, inst, ret;
    assert(event instanceof CUI.Event, "CUI.Listener.handleEvent", "event needs to be instance of CUI.Event", {
      event: event
    });
    event.setPhase(phase);
    event.setListener(this);
    if (this.isOnlyOnce()) {
      this.destroy();
    }
    inst = this.getInstance();
    if (inst && inst instanceof CUI.Element && inst.isDestroyed()) {
      console.error("inst destroyed already..");
      this.destroy();
      return;
    }
    ret = this._call.call(this, event, event.getInfo());
    event.progress(this, ret);
    if (isPromise(ret)) {
      info = event.getInfo();
      if (!info.__waits) {
        assert(false, "CUI.Listener.handleEvent", "Event \"" + (event.getType()) + "\" to handle was not triggered by CUI.Events.trigger, but instead by a regular DOMEvent.\n\nMake sure that, if your handler returns a Promise, the event is triggered by Events.trigger.", {
          event: event,
          listener: this,
          "return": ret
        });
      }
      info.__waits.push(ret);
    }
    return ret;
  };

  Listener.prototype.getInstance = function() {
    return this._instance;
  };

  Listener.prototype.matchesFilter = function(filter) {
    var _type, filter_node, filtered, i, len, match, ref, ref1;
    if (filter instanceof CUI.Listener) {
      return filter === this;
    }
    assert(CUI.isPlainObject(filter), "CUI.Listener.matchesFilter", "filter needs to be PlainObject.");
    match = true;
    filtered = false;
    if (filter.node) {
      filter_node = DOM.getNode(filter.node);
      filtered = true;
      match = !!DOM.closestUntil(this.__node, filter_node);
    }
    if (match && filter.type) {
      filtered = true;
      if (CUI.isArray(filter.type)) {
        match = false;
        ref = filter.type;
        for (i = 0, len = ref.length; i < len; i++) {
          _type = ref[i];
          match = indexOf.call(this.__types, _type) >= 0;
          if (match) {
            break;
          }
        }
      } else {
        match = (ref1 = filter.type, indexOf.call(this.__types, ref1) >= 0);
      }
    }
    if (match && filter.call) {
      filtered = true;
      match = filter.call === this._call;
    }
    if (match && filter.instance) {
      filtered = true;
      match = filter.instance === this.getInstance();
    }
    assert(filtered, "Listener.matchesFilter", "Filter did not filter anything, make sure you have 'node', 'type', 'call', or 'instance' set.", {
      filter: filter
    });
    return match;
  };

  Listener.require = function(listener, func) {
    var ev, i, len, listen, listenerFunc, type, types;
    if (CUI.isPlainObject(listener)) {
      listenerFunc = null;
      if (!(listener.type instanceof Array)) {
        types = [listener.type];
      } else {
        types = listener.type;
      }
      for (i = 0, len = types.length; i < len; i++) {
        type = types[i];
        ev = Events.getEventType(type);
        assert(ev, "" + func, "listener.type needs to be registered", {
          listener: listener
        });
        if (ev.listenerClass) {
          assert(!listenerFunc || listenerFunc === ev.listenerClass, "" + func, "listenerFunction differs for different listener types.", {
            listener: listener
          });
          listenerFunc = ev.listenerClass;
        } else {
          assert(!listenerFunc || listenerFunc === CUI.Listener, "" + func, "listenerFunction differs for different listener types.", {
            listener: listener
          });
          listenerFunc = CUI.Listener;
        }
      }
      listen = new listenerFunc(listener);
    } else {
      listen = listener;
    }
    assert(listen instanceof CUI.Listener, "" + func, "listener needs to be PlainObject or instance of CUI.Listener.");
    return listen;
  };

  return Listener;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.WheelEvent = (function(superClass) {
  extend(WheelEvent, superClass);

  function WheelEvent() {
    return WheelEvent.__super__.constructor.apply(this, arguments);
  }

  WheelEvent.prototype.dump = function() {
    return WheelEvent.__super__.dump.call(this) + " wheelY: **" + this.wheelDeltaY() + "**";
  };

  WheelEvent.prototype.wheelDeltaY = function() {
    var ne;
    ne = this.getNativeEvent();
    if (!ne) {
      return 0;
    }
    return ne.deltaY || 0;
  };

  return WheelEvent;

})(CUI.MouseEvent);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Events,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Events = (function(superClass) {
  extend(Events, superClass);

  function Events() {
    return Events.__super__.constructor.apply(this, arguments);
  }

  Events.defaults = {
    maxWait: 1500
  };

  Events.__listeners = [];

  Events.__eventRegistry = {};

  Events.__getListenersForNode = function(node) {
    if (node === document || node === window) {
      return this.__listeners;
    } else {
      return DOM.data(node, "listeners");
    }
  };

  Events.__registerListener = function(listener) {
    var listeners, node;
    assert(listener instanceof CUI.Listener, "CUI.Events.__registerListener", "listener needs to be instance of Listener", {
      listener: listener
    });
    node = listener.getNode();
    listeners = this.__getListenersForNode(node);
    if (!listeners) {
      listeners = [];
      DOM.data(node, "listeners", listeners);
    }
    listeners.push(listener);
    if (node instanceof HTMLElement) {
      node.setAttribute("cui-events-listener-element", "cui-events-listener-element");
    }
    return this;
  };

  Events.getActiveListeners = function(doc) {
    var el, j, len, listeners, ref;
    if (doc == null) {
      doc = document;
    }
    if (doc === document) {
      listeners = this.__listeners.slice(0);
    } else {
      listeners = [];
      if (CUI.DOM.matches(doc, '[cui-events-listener-element]')) {
        listeners.push.apply(listeners, DOM.data(doc, "listeners"));
      }
    }
    ref = CUI.DOM.matchSelector(doc, "[cui-events-listener-element]");
    for (j = 0, len = ref.length; j < len; j++) {
      el = ref[j];
      listeners.push.apply(listeners, DOM.data(el, "listeners"));
    }
    return listeners;
  };

  Events.unregisterListener = function(listener) {
    var arr, node;
    node = listener.getNode();
    arr = this.__getListenersForNode(node);
    assert(arr, "CUI.Events.unregisterListeners", "Listeners not found for node.", {
      node: node,
      listener: listener
    });
    removeFromArray(listener, arr);
    if (arr.length === 0 && node instanceof HTMLElement) {
      node.removeAttribute("cui-events-listener-element");
      DOM.removeData(node, "listeners");
    }
    return this;
  };

  Events.wait = function(_opts) {
    var _node, dfr, dfrs, listeners, master_dfr, opts;
    opts = CUI.Element.readOpts(_opts, "Events.wait", {
      type: {
        mandatory: true,
        check: String
      },
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      maxWait: {
        "default": CUI.defaults["class"].Events.defaults.maxWait,
        check: function(v) {
          var i;
          i = parseInt(v);
          if (isNaN(i)) {
            return false;
          } else if (i === -1) {
            return true;
          } else if (i >= 0) {
            return true;
          } else {
            return false;
          }
        }
      }
    });
    dfrs = [];
    listeners = [];
    _node = DOM.getNode(opts.node);
    dfr = new CUI.Deferred();
    listeners.push(Events.listen({
      type: opts.type,
      node: _node,
      call: function() {
        dfr.resolve();
      }
    }));
    dfrs.push(dfr);
    master_dfr = new CUI.Deferred();
    master_dfr.always(function() {
      var j, len, listener;
      for (j = 0, len = listeners.length; j < len; j++) {
        listener = listeners[j];
        listener.destroy();
      }
    });
    CUI.when(dfrs).fail(function() {
      return master_dfr.reject();
    }).done(function() {
      return master_dfr.resolve();
    });
    if (opts.maxWait >= 0) {
      CUI.setTimeout(function() {
        var j, len;
        for (j = 0, len = dfrs.length; j < len; j++) {
          dfr = dfrs[j];
          if (dfr.state() === "pending") {
            dfr.reject();
          }
        }
      }, opts.maxWait);
    }
    return master_dfr.promise();
  };

  Events.listen = function(_listener) {
    var listener;
    listener = CUI.Listener.require(_listener, "CUI.Events.listen");
    this.__registerListener(listener);
    return listener;
  };

  Events.active = function(type) {
    var _type, j, k, l, len, len1, len2, llm, ln, ref, ref1, types;
    llm = {};
    ref = this.getActiveListeners();
    for (j = 0, len = ref.length; j < len; j++) {
      ln = ref[j];
      types = ln.getTypes();
      for (k = 0, len1 = types.length; k < len1; k++) {
        _type = types[k];
        if (!llm[_type]) {
          llm[_type] = [];
        }
        llm[_type].push(ln);
      }
    }
    if (type) {
      ref1 = llm[type];
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        ln = ref1[l];
        CUI.debug(type, ln.getNode()[0]);
      }
    } else {
      return Object.keys(llm).sort();
    }
  };

  Events.trigger = function(_event) {
    var bubble, ev_node, event, exclude, idx, info, j, k, l, len, len1, len2, len3, listener, listener_node, listener_node_parent, listener_node_parents, m, node, ref, ref1, sink, skip, stopNode, stopNodes, triggerListeners, waits;
    event = CUI.Event.require(_event, "CUI.Events.trigger");
    info = event.getInfo();
    waits = [];
    info.__waits = waits;
    bubble = event.isBubble();
    sink = event.isSink();
    exclude = event.isExcludeSelf();
    node = event.getNode();
    if (bubble || !event.isInDOM()) {
      event.dispatch();
    } else {
      event.setTarget(node);
    }
    if (exclude && !bubble && !sink) {
      assert(false, "CUI.Events.trigger", "Unable to trigger event with bubble == false, sink == false and exclude_self == true.", {
        event: event
      });
    }
    if (sink || (!sink && !bubble && !exclude && event.isInDOM())) {
      triggerListeners = [];
      ref = this.getActiveListeners();
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        listener = ref[idx];
        if (ref1 = event.getType(), indexOf.call(listener.getTypes(), ref1) < 0) {
          continue;
        }
        if (listener.matchesEvent(event) === null) {
          continue;
        }
        triggerListeners.push(listener);
      }
      triggerListeners.sort(function(a, b) {
        return compareIndex(a.getDepthFromLastMatchedEvent(), b.getDepthFromLastMatchedEvent());
      });
      stopNodes = [];
      ev_node = event.getNode();
      for (k = 0, len1 = triggerListeners.length; k < len1; k++) {
        listener = triggerListeners[k];
        listener_node = listener.getNode();
        if (listener_node && stopNodes.length > 0) {
          listener_node_parents = DOM.parents(listener_node);
          skip = false;
          for (l = 0, len2 = stopNodes.length; l < len2; l++) {
            stopNode = stopNodes[l];
            for (m = 0, len3 = listener_node_parents.length; m < len3; m++) {
              listener_node_parent = listener_node_parents[m];
              if (listener_node_parent === stopNode) {
                skip = true;
                break;
              }
            }
          }
          if (skip) {
            continue;
          }
        }
        event.setCurrentTarget(listener_node);
        listener.handleEvent(event, "sink");
        if (event.isImmediatePropagationStopped()) {
          break;
        }
        if (event.isPropagationStopped() && listener_node) {
          stopNodes.push(listener_node[0]);
        }
      }
    }
    return CUI.when(waits);
  };

  Events.ignore = function(filter, doc) {
    var j, len, listener, ref;
    if (doc == null) {
      doc = document;
    }
    ref = this.getActiveListeners(doc);
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      if (!filter || CUI.isEmptyObject(filter) || listener.matchesFilter(filter)) {
        listener.destroy();
      }
    }
    return this;
  };

  Events.dump = function(filter) {
    var j, len, listener, ref;
    if (filter == null) {
      filter = {};
    }
    ref = this.getActiveListeners();
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      if (CUI.isEmptyObject(filter) || listener.matchesFilter(filter)) {
        console.debug("Listener", listener.getTypes(), (listener.getNode() ? "NODE" : "-"), listener);
      }
    }
    return this;
  };

  Events.dumpTopLevel = function() {
    var j, k, len, len1, listener, ref, ref1;
    ref = this.__listeners;
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      console.debug("Listener [document, window]", listener.getTypes(), listener.getInstance());
    }
    ref1 = DOM.data(document.documentElement, "listeners");
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      listener = ref1[k];
      console.debug("Listener [document.documentElement]", listener.getTypes(), listener.getInstance(), listener);
    }
    return this;
  };

  Events.hasEventType = function(type) {
    return !!this.__eventRegistry[type];
  };

  Events.getEventType = function(type) {
    var ev;
    ev = this.__eventRegistry[type];
    assert(ev, "Unknown event type \"" + type + "\". Use Events.registerEvent to register this type.");
    return ev;
  };

  Events.getEventTypeAliases = function(type) {
    return this.getEventType(type).alias || [type];
  };

  Events.registerEvent = function(event, allow_array) {
    var j, k, len, len1, ref, ref1, register_other_type, type;
    if (allow_array == null) {
      allow_array = true;
    }
    if (!CUI.isArray(event.type) || !allow_array) {
      assert(isString(event != null ? event.type : void 0) && event.type.length > 0, "CUI.Events.registerEvent", "event.type must be String.", {
        event: event
      });
    }
    register_other_type = (function(_this) {
      return function(_type) {
        var _event;
        _event = copyObject(event, true);
        _event.type = _type;
        return _this.registerEvent(_event, false);
      };
    })(this);
    if (CUI.isArray(event.type)) {
      ref = event.type;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        register_other_type(type);
      }
    } else {
      if (event.hasOwnProperty("DOMEvent")) {
        CUI.error("event.DOMEvent is obsolete");
        delete event.DOMEvent;
      }
      if (event.hasOwnProperty("CUIEvent")) {
        CUI.error("event.CUIEvent is obsolete");
        delete event.CUIEvent;
      }
      this.__eventRegistry[event.type] = event;
      if (event.alias) {
        ref1 = event.alias;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          type = ref1[k];
          if (!this.__eventRegistry[type]) {
            register_other_type(type);
          }
        }
      }
    }
    return this;
  };

  Events.init = function() {
    var block, defaults, ev, events, ref, results, type;
    defaults = {
      BrowserEvents: {
        bubble: true
      },
      DOM: {
        bubble: true
      },
      CUI: {
        eventClass: CUI.CUIEvent,
        sink: true
      },
      KeyboardEvents: {
        eventClass: CUI.KeyboardEvent,
        bubble: true
      },
      MouseEvents: {
        eventClass: CUI.MouseEvent,
        bubble: true
      },
      TouchEvents: {
        eventClass: CUI.TouchEvent,
        bubble: true
      }
    };
    ref = {
      MouseEvents: {
        mousemove: {},
        mouseover: {},
        mouseout: {},
        mouseleave: {},
        mouseenter: {},
        wheel: {
          eventClass: CUI.WheelEvent,
          bubble: false
        },
        mousedown: {},
        mouseup: {},
        click: {},
        dblclick: {},
        contextmenu: {}
      },
      TouchEvents: {
        touchstart: {},
        touchend: {},
        touchmove: {},
        touchcancel: {},
        touchforchange: {},
        gesturestart: {},
        gestureend: {},
        gesturechange: {}
      },
      KeyboardEvents: {
        input: {
          bubble: false
        },
        keyup: {},
        keydown: {},
        keypress: {}
      },
      BrowserEvents: {
        beforeunload: {},
        unload: {},
        load: {},
        error: {},
        close: {},
        popstate: {},
        dragstart: {},
        dragover: {},
        dragleave: {},
        dragenter: {},
        message: {},
        fullscreenchange: {
          alias: "fullscreenchange mozfullscreenchange webkitfullscreenchange MSFullscreenChange".split(" ")
        },
        hashchange: {
          bubble: false
        },
        change: {
          bubble: false
        },
        focus: {
          bubble: false
        },
        blur: {
          bubble: false
        },
        paste: {
          bubble: false
        },
        dragover: {
          bubble: false
        },
        drop: {
          bubble: false
        },
        scroll: {
          bubble: false
        },
        selectstart: {
          bubble: false
        },
        animationstart: {
          alias: "animationstart MSAnimationStart webkitAnimationStart".split(" "),
          bubble: false
        },
        animationend: {
          alias: "animationend MSAnimationEnd webkitAnimationEnd".split(" "),
          bubble: false
        },
        transitionend: {
          alias: "transitionend webkitTransitionEnd MSTransitionEnd".split(" "),
          bubble: false
        },
        resize: {
          bubble: false
        }
      },
      DOM: {
        "content-resize": {
          eventClass: CUI.CUIEvent
        }
      },
      CUI: {
        "viewport-resize": {}
      }
    };
    results = [];
    for (block in ref) {
      events = ref[block];
      results.push((function() {
        var results1;
        results1 = [];
        for (type in events) {
          ev = events[type];
          CUI.mergeMap(ev, defaults[block]);
          ev.type = type;
          results1.push(this.registerEvent(ev));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return Events;

})(CUI.Element);

CUI.Events.init();

Events = CUI.Events;

CUI.defaults["class"].Events = CUI.Events;
// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DragoverScrollEvent = (function(superClass) {
  extend(DragoverScrollEvent, superClass);

  function DragoverScrollEvent() {
    return DragoverScrollEvent.__super__.constructor.apply(this, arguments);
  }

  DragoverScrollEvent.prototype.initOpts = function() {
    DragoverScrollEvent.__super__.initOpts.call(this);
    return this.addOpts({
      count: {
        mandatory: true,
        check: (function(_this) {
          return function(v) {
            return isPosInt(v);
          };
        })(this)
      },
      originalEvent: {
        mandatory: true,
        check: CUI.Event
      }
    });
  };

  DragoverScrollEvent.prototype.getCount = function() {
    return this._count;
  };

  DragoverScrollEvent.prototype.getOriginalEvent = function() {
    return this._originalEvent;
  };

  return DragoverScrollEvent;

})(CUI.Event);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DOM,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DOM = (function(superClass) {
  extend(DOM, superClass);

  function DOM() {
    return DOM.__super__.constructor.apply(this, arguments);
  }

  DOM.prototype.initOpts = function() {
    DOM.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        "default": "",
        check: String
      },
      attr: {
        "default": {},
        check: "PlainObject"
      }
    });
  };

  DOM.prototype.registerTemplate = function(template, add_default_classes) {
    if (add_default_classes == null) {
      add_default_classes = true;
    }
    assert(template instanceof Template, (getObjectClass(this)) + ".registerDOMElement", "template must be instance of Template but is " + (getObjectClass(template)) + ".", {
      template: template
    });
    if (this.__template) {
      CUI.warn((getObjectClass(this)) + ".registerDOMElement", "Already called before, destroying existing template", {
        template: this.__template
      });
      this.__template.destroy();
    }
    this.__template = template;
    return this.registerDOMElement(this.__template.DOM, add_default_classes);
  };

  DOM.prototype.getDOMElementClasses = function() {
    if (CUI.__ng__) {
      return "cui-" + (toDash(this.__cls));
    } else {
      return "cui-dom-element cui-" + (toDash(this.__cls)) + " ez-" + (toDash(this.__cls));
    }
  };

  DOM.prototype.registerDOMElement = function(_dom, add_default_classes) {
    if (add_default_classes == null) {
      add_default_classes = true;
    }
    this.DOM = _dom;
    if (add_default_classes) {
      CUI.DOM.addClass(this.DOM, this.getDOMElementClasses());
      DOM.setAttributeMap(this.DOM, this._attr);
    }
    if (this._class) {
      CUI.DOM.addClass(this.DOM, this._class);
    }
    CUI.DOM.setElement(this.DOM, this);
    return this;
  };

  DOM.prototype.getElementForLayer = function() {
    return this.DOM;
  };

  DOM.prototype.unregisterDOMElement = function() {
    CUI.DOM.removeClass(this.DOM, this.getDOMElementClasses());
    CUI.DOM.removeAttribute(this.DOM, "id");
    if (this._class) {
      CUI.DOM.removeClass(this.DOM, this._class);
    }
    DOM.removeData(this.DOM, "element");
    delete this.DOM;
    return this;
  };

  DOM.prototype.assertDOMElement = function(func) {
    return assert(this.DOM, this.__cls + "." + func, "registerDOMElement needs to be called before \"" + func + "\" is supported.");
  };

  DOM.prototype.assertTemplateElement = function(func) {
    return assert(this.__template, this.__cls + "." + func, "registerTemplateElement needs to be called before \"" + func + "\" is supported.");
  };

  DOM.prototype.addClass = function(cls) {
    assert(arguments.length === 1, "DOM.addClass", "Only one parameter allowed.");
    this.assertDOMElement("addClass");
    return CUI.DOM.addClass(this.DOM, cls);
  };

  DOM.prototype.setAria = function(attr, value) {
    this.assertDOMElement("setAria");
    return CUI.DOM.setAria(this.DOM, attr, value);
  };

  DOM.prototype.removeClass = function(cls) {
    assert(arguments.length === 1, "DOM.removeClass", "Only one parameter allowed.");
    this.assertDOMElement("removeClass");
    return CUI.DOM.removeClass(this.DOM, cls);
  };

  DOM.prototype.hide = function() {
    this.assertDOMElement("hide");
    return CUI.DOM.hideElement(this.DOM);
  };

  DOM.prototype.show = function() {
    this.assertDOMElement("show");
    return CUI.DOM.showElement(this.DOM);
  };

  DOM.prototype.hasClass = function(cls) {
    assert(arguments.length === 1, "DOM.hasClass", "Only one parameter allowed.");
    this.assertDOMElement("hasClass");
    return CUI.DOM.hasClass(this.DOM, cls);
  };

  DOM.prototype.isDestroyed = function(key) {
    var ref;
    return (ref = this.__template) != null ? ref.isDestroyed.call(this.__template, key) : void 0;
  };

  DOM.prototype.empty = function(key) {
    this.assertTemplateElement("empty");
    return this.__template.empty.call(this.__template, key);
  };

  DOM.prototype.replace = function(value, key) {
    this.assertTemplateElement("replace");
    return this.__template.replace.call(this.__template, value, key, this);
  };

  DOM.prototype.append = function(value, key) {
    this.assertTemplateElement("append");
    return this.__template.append.call(this.__template, value, key, this);
  };

  DOM.prototype.prepend = function(value, key) {
    this.assertTemplateElement("prepend");
    return this.__template.prepend.call(this.__template, value, key, this);
  };

  DOM.prototype.text = function(value, key) {
    this.assertTemplateElement("text");
    return this.__template.text.call(this.__template, value, key, this);
  };

  DOM.prototype.getFlexHandle = function(key, do_assert) {
    this.assertTemplateElement("getFlexHandle");
    return this.__template.getFlexHandle.call(this.__template, key, do_assert);
  };

  DOM.prototype.destroy = function() {
    var ref;
    DOM.__super__.destroy.call(this);
    if (this.__template) {
      if ((ref = this.__template) != null) {
        ref.destroy();
      }
    } else if (this.DOM) {
      DOM.remove(this.DOM);
    }
    return this;
  };

  DOM.setElement = function(element, inst) {
    CUI.jQueryCompat(element);
    return DOM.data(element, "element", inst);
  };

  DOM.data = function(node, key, data) {
    var k, ref, v;
    if (!node) {
      return void 0;
    }
    assert(node instanceof HTMLElement, "DOM.data", "node needs to be instance of HTMLElement", {
      node: node
    });
    if (key === void 0) {
      return node.__dom_data;
    }
    if (CUI.isPlainObject(key)) {
      for (k in key) {
        v = key[k];
        DOM.data(node, k, v);
      }
      return node;
    }
    if (data === void 0) {
      return (ref = node.__dom_data) != null ? ref[key] : void 0;
    }
    if (!node.__dom_data) {
      node.__dom_data = {};
    }
    node.__dom_data[key] = data;
    return node;
  };

  DOM.removeData = function(node, key) {
    if (!node) {
      return void 0;
    }
    if (node.__dom_data) {
      delete node.__dom_data[key];
      if (CUI.isEmptyObject(node.__dom_data)) {
        delete node.__dom_data;
      }
    }
    return DOM;
  };

  DOM.findElement = function(node, selector, nodeFilter, forward, siblingOnly) {
    var els;
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = false;
    }
    els = this.findElements(node, selector, nodeFilter, 1, forward, siblingOnly);
    if (els.length === 0) {
      return null;
    }
    return els[0];
  };

  DOM.findNextElement = function(node, selector, nodeFilter, forward, siblingOnly) {
    var el, sibling;
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = true;
    }
    el = this.findElement(node, selector, nodeFilter, forward, siblingOnly);
    if (el) {
      return el;
    }
    while (true) {
      node = node.parentNode;
      if (!node) {
        return null;
      }
      if (forward) {
        sibling = node.nextElementSibling;
      } else {
        sibling = node.previousElementSibling;
      }
      if (sibling) {
        break;
      }
    }
    return this.findNextElement(sibling, selector, nodeFilter, forward, false);
  };

  DOM.findPreviousElement = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findNextElement(node, selector, nodeFilter, false);
  };

  DOM.findNextVisibleElement = function(node, selector, forward) {
    if (forward == null) {
      forward = true;
    }
    return this.findNextElement(node, selector, ((function(_this) {
      return function(node) {
        return DOM.isVisible(node);
      };
    })(this)), forward);
  };

  DOM.findPreviousVisibleElement = function(node, selector) {
    return this.findNextVisibleElement(node, selector, false);
  };

  DOM.findNextSiblings = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findElements(node, selector, nodeFilter, null, true, true);
  };

  DOM.findPreviousSiblings = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findElements(node, selector, nodeFilter, null, false, true);
  };

  DOM.findElements = function(node, selector, nodeFilter, maxEls, forward, siblingOnly, elements) {
    var accept_node, check_node, child, sibling;
    if (node == null) {
      node = document.documentElement;
    }
    if (selector == null) {
      selector = null;
    }
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    if (maxEls == null) {
      maxEls = null;
    }
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = false;
    }
    if (!elements) {
      assert(node instanceof HTMLElement, "DOM.findElement", "node needs to be instanceof HTMLElement.", {
        node: node,
        selector: selector
      });
      elements = [];
      check_node = !siblingOnly;
    } else {
      check_node = true;
    }
    accept_node = !nodeFilter || nodeFilter(node);
    if (check_node && accept_node) {
      if (selector === null || DOM.matches(node, selector)) {
        elements.push(node);
        if (elements.length === maxEls) {
          return elements;
        }
      } else {

      }
    }
    if (forward) {
      child = node.firstElementChild;
      sibling = node.nextElementSibling;
    } else {
      child = node.lastElementChild;
      sibling = node.previousElementSibling;
    }
    if (child && !siblingOnly && accept_node) {
      this.findElements(child, selector, nodeFilter, maxEls, forward, siblingOnly, elements);
      if (elements.length === maxEls) {
        return elements;
      }
    }
    if (sibling) {
      this.findElements(sibling, selector, nodeFilter, maxEls, forward, siblingOnly, elements);
      if (elements.length === maxEls) {
        return elements;
      }
    }
    return elements;
  };

  DOM.firstElementChild = function(node, nodeFilter) {
    var child;
    child = node.firstElementChild;
    while (true) {
      if (!nodeFilter || nodeFilter(child)) {
        return child;
      }
      child = child.nextElementSibling;
      if (!child) {
        return null;
      }
    }
  };

  DOM.children = function(node, filter) {
    var child, children, i, idx, len1, ref;
    children = [];
    ref = node.children;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      child = ref[idx];
      if (!filter || this.is(child, filter)) {
        children.push(child);
      }
    }
    return children;
  };

  DOM.lastElementChild = function(node, nodeFilter) {
    var child;
    child = node.lastElementChild;
    while (true) {
      if (!nodeFilter || nodeFilter(child)) {
        return child;
      }
      child = child.previousElementSibling;
      if (!child) {
        return null;
      }
    }
  };

  DOM.nextElementSibling = function(node, nodeFilter) {
    var sibling;
    while (true) {
      sibling = node.nextElementSibling;
      if (!nodeFilter || nodeFilter(child)) {
        return sibling;
      }
      if (!sibling) {
        return null;
      }
    }
  };

  DOM.previousElementSibling = function(node, nodeFilter) {
    var sibling;
    while (true) {
      sibling = node.previousElementSibling;
      if (!nodeFilter || nodeFilter(child)) {
        return sibling;
      }
      if (!sibling) {
        return null;
      }
    }
  };

  DOM.removeAttribute = function(node, key) {
    if (!node) {
      return null;
    }
    node.removeAttribute(key);
    return node;
  };

  DOM.setAttribute = function(node, key, value) {
    if (!node) {
      return null;
    }
    if (isNull(value) || value === false) {
      return this.removeAttribute(node, key);
    }
    if (value === true) {
      node.setAttribute(key, key);
    } else {
      node.setAttribute(key, value);
    }
    return node;
  };

  DOM.hasAttribute = function(node, key) {
    if (!node) {
      return false;
    }
    return node.hasAttribute(key);
  };

  DOM.setAttributeMap = function(node, map) {
    var key, value;
    if (!node) {
      return null;
    }
    for (key in map) {
      value = map[key];
      CUI.DOM.setAttribute(node, key, value);
    }
    return node;
  };

  DOM.width = function(docElem, value) {
    if (docElem === document || docElem === window) {
      if (value !== void 0) {
        assert(false, "DOM.width", "Unable to set width on a non HTMLElement", {
          docElem: docElem
        });
      }
      return window.innerWidth;
    }
    if (value === void 0) {
      return this.getDimension(docElem, "contentBoxWidth");
    } else {
      return this.setDimension(docElem, "contentBoxWidth", value);
    }
  };

  DOM.height = function(docElem, value) {
    if (docElem === document || docElem === window) {
      if (value !== void 0) {
        assert(false, "DOM.height", "Unable to set width on a non HTMLElement", {
          docElem: docElem
        });
      }
      return window.innerHeight;
    }
    if (value === void 0) {
      return this.getDimension(docElem, "contentBoxHeight");
    } else {
      return this.setDimension(docElem, "contentBoxHeight", value);
    }
  };

  DOM.__append = function(node, content, append) {
    var append_node, idx, len;
    if (append == null) {
      append = true;
    }
    if (isNull(content)) {
      return node;
    }
    if (CUI.isArray(content) || content instanceof HTMLCollection || content instanceof NodeList) {
      idx = 0;
      len = content.length;
      while (idx < len) {
        this.__append(node, content[idx], append);
        if (len > content.length) {

        } else {
          idx++;
        }
        len = content.length;
      }
      return node;
    }
    switch (typeof content) {
      case "number":
      case "boolean":
        append_node = document.createTextNode(content + "");
        break;
      case "string":
        append_node = document.createTextNode(content);
        break;
      default:
        if (content.DOM) {
          append_node = content.DOM;
        } else {
          append_node = content;
        }
    }
    if (append) {
      assert(append_node instanceof Node, "DOM.append", "Content needs to be instanceof Node, string, boolean, or number.", {
        node: content
      });
      node.appendChild(append_node);
    } else {
      assert(append_node instanceof Node, "DOM.prepend", "Content needs to be instanceof Node, string, boolean, or number.", {
        node: content
      });
      node.insertBefore(content, node.firstChild);
    }
    return node;
  };

  DOM.prepend = function(node, content) {
    return this.__append(node, content, false);
  };

  DOM.append = function(node, content) {
    return this.__append(node, content);
  };

  DOM.getAttribute = function(node, key) {
    return node.getAttribute(key);
  };

  DOM.remove = function(element) {
    var ref, ref1;
    if (!element) {
      return null;
    }
    if (element.DOM) {
      if ((ref = element.parentNode) != null) {
        ref.removeChild(element.DOM);
      }
    } else {
      if ((ref1 = element.parentNode) != null) {
        ref1.removeChild(element);
      }
    }
    return element;
  };

  DOM.empty = function(node) {
    var last;
    if (!node) {
      return null;
    }
    assert(isElement(node), "DOM.empty", "top needs to be Element", {
      node: node
    });
    while (last = node.lastChild) {
      node.removeChild(last);
    }
    return node;
  };

  DOM.hasClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!element || !cls) {
      return null;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      if (element.classList.contains(_cls)) {
        return true;
      }
    }
    return false;
  };

  DOM.toggleClass = function(element, cls) {
    return this.setClass(element, cls, !this.hasClass(element, cls));
  };

  DOM.setClass = function(element, cls, on_off) {
    if (on_off) {
      this.addClass(element, cls);
    } else {
      this.removeClass(element, cls);
    }
    return on_off;
  };

  DOM.setAria = function(element, attr, value) {
    if (value === true) {
      return this.setAttribute(element, "aria-" + attr, "true");
    } else if (value === false) {
      return this.setAttribute(element, "aria-" + attr, "false");
    } else {
      return this.setAttribute(element, "aria-" + attr, value);
    }
  };

  DOM.addClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!cls || !element) {
      return element;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      element.classList.add(_cls);
    }
    return element;
  };

  DOM.removeClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!cls || !element) {
      return element;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      element.classList.remove(_cls);
    }
    return element;
  };

  DOM.getRelativeOffset = function(node, untilElem, ignore_margin) {
    var dim, dim_node, margin_key_left, margin_key_top, offset, parent;
    if (untilElem == null) {
      untilElem = null;
    }
    if (ignore_margin == null) {
      ignore_margin = false;
    }
    assert(isElement(node), "CUI.DOM.getRelativePosition", "Node needs to HTMLElement.", {
      node: node
    });
    dim_node = CUI.DOM.getDimensions(node);
    parent = node.parentNode;
    if (ignore_margin) {
      margin_key_top = "viewportTop";
      margin_key_left = "viewportLeft";
    } else {
      margin_key_top = "viewportTopMargin";
      margin_key_left = "viewportLeftMargin";
    }
    while (true) {
      dim = CUI.DOM.getDimensions(parent);
      if (parent === document.body || parent === document.documentElement || parent === document) {
        offset = {
          parent: parent,
          top: dim_node[margin_key_top] + document.body.scrollTop,
          left: dim_node[margin_key_left] + document.body.scrollLeft
        };
        break;
      }
      if (dim.canHaveScrollbar || parent === node.offsetParent || parent === untilElem) {
        offset = {
          parent: parent,
          top: dim_node[margin_key_top] - (dim.viewportTop + dim.borderTop) + dim.scrollTop,
          left: dim_node[margin_key_left] - (dim.viewportLeft + dim.borderTop) + dim.scrollLeft
        };
        break;
      }
      parent = parent.parentNode;
      if (!parent) {
        break;
      }
    }
    return offset;
  };

  DOM.hasAnimatedClone = function(node) {
    return !!node.__clone;
  };

  DOM.initAnimatedClone = function(node, selector) {
    var clone, clone_child, dim, div, i, idx, len1, offset, ref, watched_nodes;
    this.removeAnimatedClone(node);
    clone = node.cloneNode(true);
    node.__clone = clone;
    if (selector) {
      watched_nodes = CUI.DOM.matchSelector(node, selector);
      clone.__watched_nodes = CUI.DOM.matchSelector(clone, selector);
    } else {
      watched_nodes = CUI.DOM.children(node);
      clone.__watched_nodes = CUI.DOM.children(clone);
    }
    offset = CUI.DOM.getRelativeOffset(node);
    if (!CUI.DOM.isPositioned(offset.parent)) {
      node.__parent_saved_position = offset.parent.style.position;
      offset.parent.style.position = "relative";
    }
    CUI.DOM.setStyle(clone, {
      position: "absolute",
      "pointer-events": "none",
      top: offset.top,
      left: offset.left
    });
    node.style.opacity = "0";
    dim = DOM.getDimensions(node);
    CUI.DOM.addClass(clone, "cui-dom-animated-clone");
    div = CUI.DOM.element("div", {
      style: "position: absolute; opacity: 0; width: 1px; height: 1px;"
    });
    clone.appendChild(div);
    CUI.DOM.insertAfter(node, clone);
    CUI.DOM.setDimension(clone, "marginBoxWidth", dim.marginBoxWidth);
    CUI.DOM.setDimension(clone, "marginBoxHeight", dim.marginBoxHeight);
    ref = clone.__watched_nodes;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      clone_child = ref[idx];
      clone_child.__watched_node = watched_nodes[idx];
      CUI.DOM.setStyle(clone_child, {
        position: "absolute",
        margin: 0
      });
    }
    this.syncAnimatedClone(node);
    node.__clone.__syncScroll = (function(_this) {
      return function() {
        div.style.top = (node.scrollHeight - 1) + "px";
        div.style.left = (node.scrollWidth - 1) + "px";
        clone.scrollTop = node.scrollTop;
        return clone.scrollLeft = node.scrollLeft;
      };
    })(this);
    Events.listen({
      type: "scroll",
      instance: clone,
      node: node,
      call: (function(_this) {
        return function() {
          return node.__clone.__syncScroll();
        };
      })(this)
    });
    node.__clone.__syncScroll();
    return node;
  };

  DOM.syncAnimatedClone = function(node) {
    var child, clone, clone_child, i, idx, len1, offset_new, ref;
    clone = node.__clone;
    if (!clone) {
      return;
    }
    ref = clone.__watched_nodes;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      clone_child = ref[idx];
      child = clone_child.__watched_node;
      offset_new = this.getRelativeOffset(child, node, true);
      CUI.DOM.setStyle(clone_child, {
        top: offset_new.top,
        left: offset_new.left
      });
    }
    return node;
  };

  DOM.removeAnimatedClone = function(node) {
    if (node.hasOwnProperty("__parent_saved_position")) {
      node.style.position = node.__parent_saved_position || "";
      delete node.__parent_saved_position;
    }
    if (!node.__clone) {
      return;
    }
    Events.ignore({
      instance: node.__clone
    });
    node.style.opacity = "";
    node.__clone.remove();
    delete node.__clone;
    return node;
  };

  DOM.setAbsolutePosition = function(element, offset) {
    var correct_offset, dim, layer_parent_offset, offsetParent;
    assert(isElement(element), "DOM.setAbsolutePosition", "element needs to be a jQuery element", {
      element: element,
      offset: offset
    });
    assert(isNumber(offset != null ? offset.left : void 0) && isNumber(offset != null ? offset.top : void 0), "DOM.setAbsolutePosition", "offset.left and offset.top must be >= 0", {
      element: element,
      offset: offset
    });
    offsetParent = element.offsetParent;
    if (offsetParent === document.documentElement) {
      layer_parent_offset = {
        top: 0,
        left: 0
      };
      correct_offset = {
        top: document.body.scrollTop,
        left: document.body.scrollLeft
      };
    } else {
      dim = DOM.getDimensions(offsetParent);
      layer_parent_offset = {
        top: dim.top,
        left: dim.left
      };
      layer_parent_offset.top += dim.borderTopWidth;
      layer_parent_offset.left += dim.borderLeftWidth;
      correct_offset = {
        top: dim.scrollTop,
        left: dim.scrollLeft
      };
    }
    element.css({
      top: offset.top - layer_parent_offset.top + correct_offset.top,
      left: offset.left - layer_parent_offset.left + correct_offset.left
    });
    return this;
  };

  DOM.__failedDOMInserts = 0;

  DOM.waitForDOMRemove = function(_opts) {
    var check_in_dom, dfr, node, opts;
    opts = CUI.Element.readOpts(_opts, "DOM.waitForDOMRemove", {
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      ms: {
        "default": 200,
        check: function(v) {
          return v > 0;
        }
      }
    });
    node = DOM.getNode(opts.node);
    dfr = new CUI.Deferred();
    check_in_dom = (function(_this) {
      return function() {
        if (!CUI.DOM.isInDOM(node)) {
          dfr.resolve();
          return;
        }
        return CUI.setTimeout({
          call: check_in_dom,
          ms: opts.ms,
          track: false
        });
      };
    })(this);
    check_in_dom();
    return dfr.promise();
  };

  DOM.waitForDOMInsert = function(_opts) {
    var dfr, i, len1, node, opts, prefix, ref, timeout;
    opts = CUI.Element.readOpts(_opts, "DOM.waitForDOMInsert", {
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      }
    });
    node = DOM.getNode(opts.node);
    if (CUI.DOM.isInDOM(node)) {
      return CUI.resolvedPromise(true);
    }
    dfr = new CUI.Deferred();
    ref = ["-webkit-", "-moz-", "-ms-", "-o-", ""];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      prefix = ref[i];
      DOM.setStyleOne(node, prefix + "animation-duration", "0.001s");
      DOM.setStyleOne(node, prefix + "animation-name", "nodeInserted");
    }
    timeout = null;
    Events.wait({
      node: node,
      type: "animationstart",
      maxWait: -1
    }).done((function(_this) {
      return function() {
        var c, check_for_node, tries;
        if (DOM.isInDOM(node)) {
          dfr.resolve();
          return;
        }
        c = _this.__failedDOMInserts++;
        console.warn("[#" + c + "] Element received animationstart event but is not in DOM yet. We poll with timeout 0.");
        tries = 0;
        check_for_node = function() {
          if (DOM.isInDOM(node)) {
            console.warn("[#" + c + "] Poll done, element is in DOM now.");
            return dfr.resolve();
          } else if (tries < 10) {
            console.warn("[#" + c + "] Checking for node failed, try: ", tries);
            tries = tries + 1;
            return CUI.setTimeout(check_for_node, 0);
          } else {
            return console.error("[#" + c + "] Checking for node failed. Giving up.", node);
          }
        };
        return CUI.setTimeout(check_for_node, 0);
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  DOM.getNode = function(node) {
    if (node.DOM && node !== window) {
      return node.DOM;
    } else {
      return node;
    }
  };

  DOM.printElement = function(_opts) {
    var cls, docElem, href, i, j, len1, len2, new_node, opts, ref, ref1, style_node, win;
    opts = CUI.Element.readOpts(_opts, "DOM.printElement", {
      docElem: {
        check: function(v) {
          return v instanceof HTMLElement;
        }
      },
      title: {
        "default": "CUI-Print-Window",
        check: String
      },
      windowName: {
        "default": "_blank",
        check: String
      },
      windowFeatures: {
        "default": "width=400,height=800",
        check: String
      },
      bodyClasses: {
        "default": [],
        check: Array
      }
    });
    if (opts.docElem === document.documentElement) {
      docElem = document.body;
    } else {
      docElem = opts.docElem;
    }
    win = window.open("", opts.windowName, opts.windowFeatures);
    if (!isEmpty(opts.title)) {
      win.document.title = opts.title;
    }
    ref = DOM.matchSelector(document.head, "link[rel='stylesheet']");
    for (i = 0, len1 = ref.length; i < len1; i++) {
      style_node = ref[i];
      new_node = style_node.cloneNode(true);
      href = ez5.getAbsoluteURL(new_node.getAttribute("href"));
      new_node.setAttribute("href", href);
      console.debug("cloning css node for href", href);
      win.document.head.appendChild(new_node);
    }
    win.document.body.innerHTML = docElem.outerHTML;
    win.document.body.classList.add("cui-dom-print-element");
    ref1 = opts.bodyClasses;
    for (j = 0, len2 = ref1.length; j < len2; j++) {
      cls = ref1[j];
      win.document.body.classList.add(cls);
    }
    return win.print();
  };

  DOM.isNode = function(node) {
    if (!node) {
      return false;
    }
    if (node === document.documentElement || node === window || node === document || node.nodeType || node.DOM) {
      return true;
    } else {
      return false;
    }
  };

  DOM.insertChildAtPosition = function(node, node_insert, pos) {
    assert(isInteger(pos) && pos >= 0 && pos <= node.children.length, "CUI.DOM.insertAtPosition", "Unable to insert node at position #" + pos + ".", {
      node: node,
      node_insert: node_insert,
      pos: pos
    });
    if (pos === node.children.length) {
      return node.appendChild(node_insert);
    } else if (node.children[pos] !== node_insert) {
      return this.insertBefore(node.children[pos], node_insert);
    }
  };

  DOM.insertBefore = function(node, node_before) {
    if (node_before) {
      node.parentNode.insertBefore(node_before, node);
    }
    return node;
  };

  DOM.insertAfter = function(node, node_after) {
    if (node_after) {
      node.parentNode.insertBefore(node_after, node.nextSibling);
    }
    return node;
  };

  DOM.is = function(node, selector) {
    if (!node) {
      return null;
    }
    if (selector instanceof HTMLElement) {
      return node === selector;
    }
    if (CUI.isFunction(selector)) {
      return !!selector(node);
    }
    if (!(node instanceof HTMLElement)) {
      return null;
    }
    return this.matches(node, selector);
  };

  DOM.matches = function(node, selector) {
    if (!node) {
      return null;
    }
    return node[CUI.DOM.matchFunc](selector);
  };

  DOM.matchFunc = (function() {
    var d, i, k, len1, ref;
    d = document.createElement("div");
    ref = ["matches", "webkitMatchesSelector", "mozMatchesSelector", "oMatchesSelector", "msMatchesSelector"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (d[k]) {
        return k;
      }
    }
    return assert(false, "Could not determine match function on docElem");
  })();

  DOM.find = function(sel) {
    return this.matchSelector(document.documentElement, sel);
  };

  DOM.matchSelector = function(docElem, sel, trySelf) {
    var list;
    if (trySelf == null) {
      trySelf = false;
    }
    assert(docElem instanceof HTMLElement || docElem === document, "CUI.DOM.matchSelector", "docElem needs to be instanceof HTMLElement or document.", {
      docElem: docElem
    });
    list = docElem.querySelectorAll(sel);
    if (trySelf && list.length === 0) {
      if (docElem[CUI.DOM.matchFunc](sel)) {
        list = [docElem];
      } else {
        list = [];
      }
    }
    return list;
  };

  DOM.elementsUntil = function(docElem, selector, untilDocElem) {
    var path, testDocElem;
    assert(docElem instanceof Node || docElem === window, "CUI.DOM.elementsUntil", "docElem needs to be instanceof Node or window.", {
      docElem: docElem,
      selector: selector,
      untilDocElem: untilDocElem
    });
    testDocElem = docElem;
    path = [testDocElem];
    while (true) {
      if (selector && this.is(testDocElem, selector)) {
        return path;
      }
      if (testDocElem === untilDocElem) {
        if (selector) {
          return null;
        } else {
          return path;
        }
      }
      testDocElem = CUI.DOM.parent(testDocElem);
      if (testDocElem === null) {
        if (selector) {
          return null;
        } else {
          return path;
        }
      }
      path.push(testDocElem);
    }
    return null;
  };

  DOM.parent = function(docElem) {
    if (docElem === window) {
      return null;
    } else if (docElem === document) {
      return window;
    } else {
      return docElem.parentNode;
    }
  };

  DOM.closest = function(docElem, selector) {
    return this.closestUntil(docElem, selector);
  };

  DOM.closestUntil = function(docElem, selector, untilDocElem) {
    var path;
    if (!selector) {
      return null;
    }
    path = this.elementsUntil(docElem, selector, untilDocElem);
    if (path === null || path.length === 0) {
      return null;
    }
    return path[path.length - 1];
  };

  DOM.parentsUntil = function(docElem, selector, untilDocElem) {
    var parentElem, path;
    if (untilDocElem == null) {
      untilDocElem = document.documentElement;
    }
    parentElem = CUI.DOM.parent(docElem);
    if (!parentElem) {
      return [];
    }
    path = this.elementsUntil(parentElem, selector, untilDocElem);
    if (!(path != null ? path.length : void 0)) {
      return [];
    }
    return path;
  };

  DOM.parents = function(docElem, selector) {
    var i, len1, parent, parents, path;
    assert(docElem instanceof HTMLElement || docElem === document || docElem === window, "CUI.DOM.parents", "element needs to be instanceof HTMLElement, document, or window.", {
      element: docElem
    });
    path = this.parentsUntil(docElem);
    if (!selector) {
      return path;
    }
    parents = [];
    for (i = 0, len1 = path.length; i < len1; i++) {
      parent = path[i];
      if (this.is(parent, selector)) {
        parents.push(parent);
      }
    }
    return parents;
  };

  DOM.isInDOM = function(docElem) {
    if (!docElem) {
      return null;
    }
    assert(docElem instanceof Node, "CUI.DOM.isInDOM", "docElem needs to be instanceof Node.", {
      docElem: docElem
    });
    return document.documentElement.contains(docElem);
  };

  DOM.replaceWith = function(node, new_node) {
    var first_node;
    assert(node instanceof Node && (new_node instanceof Node || new_node instanceof NodeList), "CUI.DOM.replaceWidth", "nodes need to be instanceof Node.", {
      node: node,
      newNode: new_node
    });
    if (new_node instanceof NodeList) {
      first_node = new_node[0];
      node.parentNode.replaceChild(first_node, node);
      while (new_node.length > 0) {
        this.insertAfter(first_node, new_node[new_node.length - 1]);
      }
      return first_node;
    } else {
      return node.parentNode.replaceChild(new_node, node);
    }
  };

  DOM.getRect = function(docElem) {
    return docElem.getBoundingClientRect();
  };

  DOM.getComputedStyle = function(docElem) {
    return window.getComputedStyle(docElem);
  };

  DOM.setStyle = function(docElem, style, append) {
    var k, v;
    if (append == null) {
      append = "px";
    }
    assert(docElem instanceof HTMLElement, "CUI.DOM.setStyle", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem
    });
    for (k in style) {
      v = style[k];
      if (v === void 0) {
        continue;
      }
      switch (v) {
        case "":
        case null:
          docElem.style[k] = "";
          break;
        default:
          if (isNaN(Number(v))) {
            docElem.style[k] = v;
          } else if (v === 0 || v === "0") {
            docElem.style[k] = 0;
          } else {
            docElem.style[k] = v + append;
          }
      }
    }
    return docElem;
  };

  DOM.setStyleOne = function(docElem, key, value) {
    var map;
    map = {};
    map[key] = value;
    return this.setStyle(docElem, map);
  };

  DOM.setStylePx = function(docElem, style) {
    console.error("DOM.setStylePx is deprectaed, use DOM.setStyle.");
    return this.setStyle(docElem, style);
  };

  DOM.getRelativePosition = function(docElem) {
    var dim;
    assert(docElem instanceof HTMLElement, "CUI.DOM.getRelativePosition", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem
    });
    dim = CUI.DOM.getDimensions(docElem);
    return {
      top: dim.offsetTopScrolled,
      left: dim.offsetLeftScrolled
    };
  };

  DOM.getDimensions = function(docElem) {
    var cs, dim, dim_key, i, j, k, k1, k2, l, len1, len2, len3, len4, len5, len6, m, n, o, rect, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
    if (isNull(docElem)) {
      return null;
    }
    if (docElem === window || docElem === document) {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }
    cs = this.getComputedStyle(docElem);
    rect = this.getRect(docElem);
    dim = {
      computedStyle: cs,
      clientBoundingRect: rect
    };
    ref = ["margin", "padding", "border"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k1 = ref[i];
      ref1 = ["Top", "Right", "Bottom", "Left"];
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        k2 = ref1[j];
        dim_key = k1 + k2;
        switch (k1) {
          case "border":
            dim[dim_key] = this.getCSSFloatValue(cs["border" + k2 + "Width"]);
            break;
          default:
            dim[dim_key] = this.getCSSFloatValue(cs[dim_key]);
        }
      }
      dim[k1 + "Vertical"] = dim[k1 + "Top"] + dim[k1 + "Bottom"];
      dim[k1 + "Horizontal"] = dim[k1 + "Left"] + dim[k1 + "Right"];
    }
    dim.contentBoxWidth = Math.max(0, rect.width - dim.borderHorizontal - dim.paddingHorizontal);
    dim.contentBoxHeight = Math.max(0, rect.height - dim.borderVertical - dim.paddingVertical);
    dim.innerBoxWidth = Math.max(0, rect.width - dim.borderHorizontal);
    dim.innerBoxHeight = Math.max(0, rect.height - dim.borderVertical);
    dim.borderBoxWidth = rect.width;
    dim.borderBoxHeight = rect.height;
    if (cs.boxSizing === "content-box") {
      dim.contentWidthAdjust = dim.borderBoxWidth - dim.contentBoxWidth;
      dim.contentHeightAdjust = dim.borderBoxHeight - dim.contentBoxHeight;
    } else {
      dim.contentWidthAdjust = 0;
      dim.contentHeightAdjust = 0;
    }
    dim.marginBoxWidth = Math.max(0, rect.width + dim.marginHorizontal);
    dim.marginBoxHeight = Math.max(0, rect.height + dim.marginVertical);
    dim.viewportTop = rect.top;
    dim.viewportTopMargin = rect.top - dim.marginTop;
    dim.viewportLeft = rect.left;
    dim.viewportLeftMargin = rect.left - dim.marginLeft;
    dim.viewportBottom = rect.bottom;
    dim.viewportBottomMargin = rect.bottom + dim.marginBottom;
    dim.viewportRight = rect.right;
    dim.viewportRightMargin = rect.right + dim.marginRight;
    dim.viewportCenterTop = rect.top + ((rect.bottom - rect.top) / 2);
    dim.viewportCenterLeft = rect.left + ((rect.right - rect.left) / 2);
    ref2 = ["left", "top", "minWidth", "minHeight", "maxWidth", "maxHeight", "marginRight", "marginLeft", "marginTop", "marginBottom", "borderTopWidth", "borderLeftWidth", "borderBottomWidth", "borderRightWidth"];
    for (l = 0, len3 = ref2.length; l < len3; l++) {
      k = ref2[l];
      dim[k] = this.getCSSFloatValue(cs[k]);
    }
    ref3 = ["offsetWidth", "offsetHeight", "offsetTop", "offsetLeft", "clientWidth", "clientHeight", "scrollWidth", "scrollHeight", "scrollLeft", "scrollTop"];
    for (m = 0, len4 = ref3.length; m < len4; m++) {
      k = ref3[m];
      dim[k] = docElem[k];
    }
    dim.scaleX = dim.borderBoxWidth / dim.offsetWidth || 1;
    dim.scaleY = dim.borderBoxHeight / dim.offsetHeight || 1;
    if (docElem.offsetParent) {
      dim.offsetTopScrolled = dim.offsetTop + docElem.offsetParent.scrollTop;
      dim.offsetLeftScrolled = dim.offsetLeft + docElem.offsetParent.scrollLeft;
    } else {
      dim.offsetTopScrolled = dim.offsetTop + document.body.scrollTop;
      dim.offsetLeftScrolled = dim.offsetLeft + document.body.scrollLeft;
    }
    ref4 = ["offsetWidth", "offsetLeft", "clientWidth", "scrollWidth", "scrollLeft"];
    for (n = 0, len5 = ref4.length; n < len5; n++) {
      k = ref4[n];
      dim[k + "Scaled"] = dim[k] * dim.scaleX;
    }
    ref5 = ["offsetHeight", "offsetTop", "clientHeight", "scrollHeight", "scrollTop"];
    for (o = 0, len6 = ref5.length; o < len6; o++) {
      k = ref5[o];
      dim[k + "Scaled"] = dim[k] * dim.scaleY;
    }
    dim.verticalScrollbarWidth = dim.offsetWidth - dim.borderHorizontal - dim.clientWidth;
    dim.horizontalScrollbarHeight = dim.offsetHeight - dim.borderVertical - dim.clientHeight;
    dim.canHaveScrollbar = ((ref6 = cs.overflowX) === "auto" || ref6 === "scroll") || ((ref7 = cs.overflowY) === "auto" || ref7 === "scroll");
    dim.horizontalScrollbarAtStart = dim.scrollLeft === 0;
    dim.horizontalScrollbarAtEnd = dim.scrollWidth - dim.scrollLeft - dim.clientWidth - dim.verticalScrollbarWidth < 1;
    dim.verticalScrollbarAtStart = dim.scrollTop === 0;
    dim.verticalScrollbarAtEnd = dim.scrollHeight - dim.scrollTop - dim.clientHeight - dim.horizontalScrollbarHeight < 1;
    dim.viewportTopContent = rect.top + dim.borderTop + dim.paddingTop;
    dim.viewportLeftContent = rect.left + dim.borderLeft + dim.paddingLeft;
    dim.viewportBottomContent = rect.bottom - dim.borderBottom - Math.max(dim.paddingBottom, dim.horizontalScrollbarHeight);
    dim.viewportRightContent = rect.right - dim.borderRight - Math.max(dim.paddingRight, dim.verticalScrollbarWidth);
    dim.viewportTopInner = rect.top + dim.borderTop;
    dim.viewportLeftInner = rect.left + dim.borderLeft;
    dim.viewportBottomInner = rect.bottom - dim.borderBottom - dim.horizontalScrollbarHeight;
    dim.viewportRightInner = rect.right - dim.borderRight - dim.verticalScrollbarWidth;
    return dim;
  };

  DOM.parentsScrollable = function(node) {
    var dim, i, idx, len1, parent, parents, ref;
    parents = [];
    ref = DOM.parents(node);
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      parent = ref[idx];
      dim = DOM.getDimensions(parent);
      if (dim.canHaveScrollbar) {
        parents.push(parent);
      }
    }
    return parents;
  };

  DOM.setDimension = function(docElem, key, value) {
    var set;
    set = {};
    set[key] = value;
    return this.setDimensions(docElem, set);
  };

  DOM.getDimension = function(docElem, key) {
    return this.getDimensions(docElem)[key];
  };

  DOM.prepareSetDimensions = function(docElem) {
    if (docElem.__prep_dim) {
      return;
    }
    docElem.__prep_dim = {
      borderBox: this.isBorderBox(docElem),
      dim: this.getDimensions(docElem)
    };
    return this;
  };

  DOM.setDimensions = function(docElem, _dim) {
    var borderBox, css, cssFloat, dim, i, k, left_over_keys, len1, ref, set, set_dim;
    this.prepareSetDimensions(docElem);
    css = {};
    borderBox = docElem.__prep_dim.borderBox;
    dim = docElem.__prep_dim.dim;
    delete docElem.__prep_dim;
    set_dim = copyObject(_dim);
    cssFloat = {};
    set = (function(_this) {
      return function(key, value) {
        if (isNull(value) || isNaN(value)) {
          return;
        }
        if (!cssFloat.hasOwnProperty(key)) {
          if ((key === "width" || key === "height") && value < 0) {
            value = 0;
          }
          cssFloat[key] = value;
          return;
        }
        assert(cssFloat[key] === value, "DOM.setDimensions", "Unable to set contradicting values for " + key + ".", {
          docElem: docElem,
          dim: set_dim
        });
      };
    })(this);
    ref = ["width", "height", "left", "top"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (set_dim.hasOwnProperty(k)) {
        set(k, set_dim[k]);
        delete set_dim[k];
      }
    }
    if (set_dim.hasOwnProperty("contentBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.contentBoxWidth + dim.paddingHorizontal + dim.borderHorizontal);
      } else {
        set("width", set_dim.contentBoxWidth);
      }
      delete set_dim.contentBoxWidth;
    }
    if (set_dim.hasOwnProperty("contentBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.contentBoxHeight + dim.paddingVertical + dim.borderVertical);
      } else {
        set("height", set_dim.contentBoxHeight);
      }
      delete set_dim.contentBoxHeight;
    }
    if (set_dim.hasOwnProperty("borderBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.borderBoxWidth);
      } else {
        set("width", set_dim.borderBoxWidth - dim.paddingHorizontal - dim.borderHorizontal);
      }
      delete set_dim.borderBoxWidth;
    }
    if (set_dim.hasOwnProperty("borderBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.borderBoxHeight);
      } else {
        set("height", set_dim.borderBoxHeight - dim.paddingVertical - dim.borderVertical);
      }
      delete set_dim.borderBoxHeight;
    }
    if (set_dim.hasOwnProperty("marginBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.marginBoxWidth - dim.marginHorizontal);
      } else {
        set("width", set_dim.marginBoxWidth - dim.marginHorizontal - dim.paddingHorizontal - dim.borderHorizontal);
      }
      delete set_dim.marginBoxWidth;
    }
    if (set_dim.hasOwnProperty("marginBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.marginBoxHeight - dim.marginVertical);
      } else {
        set("height", set_dim.marginBoxHeight - dim.marginVertical - dim.paddingVertical - dim.borderHorizontal);
      }
      delete set_dim.marginBoxHeight;
    }
    left_over_keys = Object.keys(set_dim);
    assert(left_over_keys.length === 0, "DOM.setDimensions", "Unknown keys in dimension: \"" + left_over_keys.join("\", \"") + "\".", {
      docElem: docElem,
      dim: _dim
    });
    this.setStyle(docElem, cssFloat);
    return cssFloat;
  };

  DOM.htmlToNodes = function(html) {
    var d;
    if (isNull(html)) {
      return;
    }
    d = this.element("DIV");
    d.innerHTML = html;
    return d.childNodes;
  };

  DOM.findTextInNodes = function(nodes, callback, texts) {
    var child, child_nodes, i, j, len1, len2, node, ref, textContent;
    if (texts == null) {
      texts = [];
    }
    for (i = 0, len1 = nodes.length; i < len1; i++) {
      node = nodes[i];
      child_nodes = [];
      ref = node.childNodes;
      for (j = 0, len2 = ref.length; j < len2; j++) {
        child = ref[j];
        switch (child.nodeType) {
          case 3:
            textContent = child.textContent.trim();
            if (textContent.length > 0) {
              if (typeof callback === "function") {
                callback(child, textContent);
              }
              texts.push(textContent);
            }
            break;
          case 1:
            child_nodes.push(child);
        }
      }
      this.findTextInNodes(child_nodes, callback, texts);
    }
    return texts;
  };

  DOM.getCSSFloatValue = function(v) {
    var fl;
    if (v.indexOf("px") === -1) {
      return 0;
    }
    fl = parseFloat(v.substr(0, v.length - 2));
    return fl;
  };

  DOM.isPositioned = function(docElem) {
    var ref;
    assert(docElem instanceof HTMLElement, "DOM.isPositioned", "docElem needs to be instance of HTMLElement.", {
      docElem: docElem
    });
    if (docElem === document.body || docElem === document.documentElement) {
      return true;
    }
    return (ref = this.getComputedStyle(docElem).position) === "relative" || ref === "absolute" || ref === "fixed";
  };

  DOM.isVisible = function(docElem) {
    var style;
    style = this.getComputedStyle(docElem);
    if (style.visibility === "hidden" || style.display === "none") {
      return false;
    } else {
      return true;
    }
  };

  DOM.getBoxSizing = function(docElem) {
    return this.getComputedStyle(docElem).boxSizing;
  };

  DOM.isBorderBox = function(docElem) {
    return this.getBoxSizing(docElem) === "border-box";
  };

  DOM.isContentBox = function(docElem) {
    return CUI.DOM.getBoxSizing() === "content-box";
  };

  DOM.hideElement = function(docElem) {
    if (!docElem) {
      return;
    }
    if (docElem.style.display !== "none") {
      docElem.__saved_display = docElem.style.display;
    }
    docElem.style.display = "none";
    return docElem;
  };

  DOM.removeChildren = function(docElem, filter) {
    var child, i, len1, ref;
    assert(docElem instanceof HTMLElement, "CUI.DOM.removeChildren", "element needs to be instance of HTMLElement", {
      element: docElem
    });
    ref = this.children(docElem, filter);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      child = ref[i];
      docElem.removeChild(child);
    }
    return docElem;
  };

  DOM.showElement = function(docElem) {
    if (!docElem) {
      return;
    }
    docElem.style.display = docElem.__saved_display || "";
    delete docElem.__saved_display;
    return docElem;
  };

  DOM.space = function(style) {
    if (style == null) {
      style = null;
    }
    switch (style) {
      case "small":
        return this.element("DIV", {
          "class": "cui-small-space"
        });
      case "large":
        return this.element("DIV", {
          "class": "cui-large-space"
        });
      case "flexible":
        return this.element("DIV", {
          "class": "cui-flexible-space"
        });
      case null:
        return this.element("DIV", {
          "class": "cui-space"
        });
      default:
        return assert(false, "CUI.DOM.space", "Unknown style: " + style);
    }
  };

  DOM.element = function(tagName, attrs) {
    if (attrs == null) {
      attrs = {};
    }
    return DOM.setAttributeMap(document.createElement(tagName), attrs);
  };

  DOM.debugRect = function() {
    var arr, bottom, d, dim, height, i, k, left, len1, pattern, ref, right, top, value, width;
    this.remove(this.find("#cui-debug-rect")[0]);
    if (arguments.length === 0) {
      return;
    }
    if (arguments.length === 2 || !CUI.isArray(arguments[0])) {
      dim = arguments[0];
      pattern = arguments[1];
      arr = [];
      ref = ["Top", "Left", "Bottom", "Right"];
      for (i = 0, len1 = ref.length; i < len1; i++) {
        k = ref[i];
        if (isEmpty(pattern) || pattern === "*") {
          k = k.toLowerCase();
          value = dim[k];
        } else {
          value = dim[pattern.replace("*", k)];
        }
        arr.push(value);
      }
    } else if (CUI.isArray(arguments[0])) {
      arr = arguments[0];
    } else {
      console.error("CUI.DOM.debugRect: Argument Error.");
      return;
    }
    top = arr[0], left = arr[1], bottom = arr[2], right = arr[3];
    width = right - left;
    height = bottom - top;
    d = this.element("DIV", {
      id: "cui-debug-rect"
    });
    this.setStyle(d, {
      position: "absolute",
      border: "2px solid red",
      boxSizing: "border-box",
      top: top,
      left: left,
      width: width,
      height: height
    });
    document.body.appendChild(d);
    console.debug("DOM.debugRect:", [top, left, bottom, right]);
    return d;
  };

  DOM.scrollIntoView = function(docElem) {
    var dim, dim_p, i, idx, len1, measure, off_bottom, off_left, off_right, off_top, p, parents;
    if (!docElem) {
      return null;
    }
    if (docElem.nodeType === 3) {
      docElem = docElem.parentNode;
    }
    parents = CUI.DOM.parentsUntil(docElem);
    dim = null;
    measure = (function(_this) {
      return function() {
        return dim = _this.getDimensions(docElem);
      };
    })(this);
    measure();
    for (idx = i = 0, len1 = parents.length; i < len1; idx = ++i) {
      p = parents[idx];
      dim_p = this.getDimensions(p);
      if (dim_p.computedStyle.overflowY !== "visible") {
        off_bottom = dim.viewportBottomMargin - dim_p.viewportBottomContent;
        if (off_bottom > 0) {
          p.scrollTop = p.scrollTop + off_bottom;
          measure();
        }
        off_top = dim.viewportTopMargin - dim_p.viewportTopContent;
        if (off_top < 0) {
          p.scrollTop = p.scrollTop + off_top;
          measure();
        }
      }
      if (dim_p.computedStyle.overflowX !== "visible") {
        off_right = dim.viewportRightMargin - dim_p.viewportRightContent;
        if (off_right > 0) {
          p.scrollLeft = p.scrollLeft + off_right;
          measure();
        }
        off_left = dim.viewportLeftMargin - dim_p.viewportLeftContent;
        if (off_left < 0) {
          p.scrollLeft = p.scrollLeft + off_left;
          measure();
        }
      }
    }
    return docElem;
  };

  DOM.setClassOnMousemove = function(_opts) {
    var opts, remove_mousemoved_class, schedule_remove_mousemoved_class;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "DOM.setClassOnMousemove", {
      delayRemove: {
        check: Function
      },
      "class": {
        mandatory: true,
        check: String
      },
      ms: {
        "default": 3000,
        mandatory: true,
        check: function(v) {
          return v > 0;
        }
      },
      element: {
        mandatory: true,
        check: function(v) {
          return v instanceof HTMLElement;
        }
      },
      instance: {}
    });
    remove_mousemoved_class = (function(_this) {
      return function() {
        if ((typeof opts.delayRemove === "function" ? opts.delayRemove() : void 0) || window.globalDrag) {
          schedule_remove_mousemoved_class();
          return;
        }
        return opts.element.classList.remove(opts["class"]);
      };
    })(this);
    schedule_remove_mousemoved_class = (function(_this) {
      return function() {
        return CUI.scheduleCallback({
          ms: opts.ms,
          call: remove_mousemoved_class
        });
      };
    })(this);
    Events.listen({
      node: opts.element,
      type: "mousemove",
      instance: opts.instance,
      call: (function(_this) {
        return function(ev) {
          if (!opts.element.classList.contains(opts["class"])) {
            opts.element.classList.add(opts["class"]);
          }
          schedule_remove_mousemoved_class();
        };
      })(this)
    });
    return Events.listen({
      node: opts.element,
      type: "mouseleave",
      instance: opts.instance,
      call: (function(_this) {
        return function(ev) {
          return remove_mousemoved_class();
        };
      })(this)
    });
  };

  DOM.requestFullscreen = function(elem) {
    var dfr, fsc_ev;
    assert(elem instanceof HTMLElement, "startFullscreen", "element needs to be instance of HTMLElement", {
      element: elem
    });
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    }
    dfr = new CUI.Deferred();
    fsc_ev = Events.listen({
      type: "fullscreenchange",
      node: window,
      call: (function(_this) {
        return function(ev) {
          if (DOM.isFullscreen()) {
            dfr.notify();
          } else {
            Events.ignore(fsc_ev);
            dfr.resolve();
          }
        };
      })(this)
    });
    return dfr.promise();
  };

  DOM.exitFullscreen = function() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  };

  DOM.fullscreenElement = function() {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || void 0;
  };

  DOM.fullscreenEnabled = function() {
    return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || false;
  };

  DOM.isFullscreen = function() {
    return document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || false;
  };

  return DOM;

})(CUI.Element);

DOM = CUI.DOM;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.CSSLoader = (function(superClass) {
  extend(CSSLoader, superClass);

  function CSSLoader() {
    return CSSLoader.__super__.constructor.apply(this, arguments);
  }

  CSSLoader.prototype.initOpts = function() {
    CSSLoader.__super__.initOpts.call(this);
    return this.addOpts({
      group: {
        mandatory: true,
        "default": "main",
        check: String
      }
    });
  };

  CSSLoader.prototype.readOpts = function() {
    CSSLoader.__super__.readOpts.call(this);
    this.__cssName = "cui-css-" + this._group;
    return this.__themes = {};
  };

  CSSLoader.prototype.__getCSSNodes = function() {
    return CUI.DOM.matchSelector(document.documentElement, "link[name=\"" + this.__cssName + "\"]");
  };

  CSSLoader.prototype.getActiveTheme = function() {
    var active_theme, cssNode, i, len, name, ref;
    ref = this.__getCSSNodes();
    for (i = 0, len = ref.length; i < len; i++) {
      cssNode = ref[i];
      if (!CUI.DOM.getAttribute(cssNode, "loading")) {
        name = CUI.DOM.getAttribute(cssNode, "theme");
        active_theme = this.__themes[name];
        break;
      }
    }
    if (active_theme) {
      return active_theme;
    }
    return null;
  };

  CSSLoader.prototype.getThemes = function() {
    return this.__themes;
  };

  CSSLoader.prototype.registerTheme = function(_opts) {
    var opts;
    opts = CUI.Element.readOpts(_opts, "CSS.registerTheme", {
      name: {
        mandatory: true,
        check: String
      },
      url: {
        mandatory: true,
        check: String
      }
    });
    return this.__themes[opts.name] = opts;
  };

  CSSLoader.prototype.forceReloadTheme = function() {
    var theme;
    theme = this.getActiveTheme();
    if (!active_theme) {
      return CUI.rejectedPromise();
    }
    return this.loadTheme(theme, true);
  };

  CSSLoader.prototype.loadTheme = function(name, overload_url) {
    var cssNode, css_href, dfr, i, is_loading, len, loader_deferred, oldCssNode, ref, ref1, same_theme, same_url, url;
    if (overload_url == null) {
      overload_url = null;
    }
    url = (ref = this.__themes[name]) != null ? ref.url : void 0;
    assert(url, "CSSLoader.loadTheme", "Theme not found.", {
      name: name,
      themes: this.__themes
    });
    if (overload_url) {
      url = overload_url;
    }
    ref1 = this.__getCSSNodes();
    for (i = 0, len = ref1.length; i < len; i++) {
      oldCssNode = ref1[i];
      same_theme = CUI.DOM.getAttribute(oldCssNode, "theme") === name;
      same_url = CUI.DOM.getAttribute(oldCssNode, "href") === url;
      is_loading = CUI.DOM.getAttribute(oldCssNode, "loading");
      if (is_loading) {
        loader_deferred = CUI.DOM.data(oldCssNode, "css-loader-deferred");
        if (same_theme && same_url) {
          console.warn("CSSLoader.loadTheme:", name, ". Theme already loading, returning Promise.");
          return loader_deferred.promise();
        }
        load_deferred.reject();
      } else {
        if (same_theme && same_url) {
          return CUI.resolvedPromise();
        }
      }
    }
    if (name.startsWith("ng")) {
      CUI.__ng__ = true;
    }
    dfr = new CUI.Deferred();
    if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith("file://")) {
      css_href = url;
    } else if (!url.startsWith("/")) {
      css_href = CUI.getPathToScript() + url;
    } else {
      css_href = document.location.origin + url;
    }
    cssNode = CUI.DOM.element("LINK", {
      rel: "stylesheet",
      charset: "utf-8",
      name: this.__cssName,
      loading: "1",
      theme: name,
      href: css_href
    });
    CUI.DOM.data(cssNode, "css-loader-deferred", dfr);
    dfr.always((function(_this) {
      return function() {
        CUI.DOM.removeData(cssNode, "css-loader-deferred");
        return CUI.DOM.removeAttribute(cssNode, "loading");
      };
    })(this));
    dfr.fail((function(_this) {
      return function(css_href) {
        console.error("CSSLoader: Loading failed, removing node.", css_href);
        return CUI.DOM.remove(cssNode);
      };
    })(this));
    Events.listen({
      node: cssNode,
      type: "load",
      call: (function(_this) {
        return function(ev, info) {
          var css_node, error, ex, found_stylesheet, j, k, len1, len2, old_css_nodes, ref2, ref3, ref4, styleSheet;
          if (dfr.state() !== "pending") {
            console.warn("CSSLoader.loadTheme: Caught event load second time, ignoring. IE does that for some reason.");
            return;
          }
          if (CUI.browser.ie) {
            found_stylesheet = false;
            ref2 = document.styleSheets;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              styleSheet = ref2[j];
              if (styleSheet.href === css_href) {
                try {
                  if (!((ref3 = styleSheet.cssRules) != null ? ref3.length : void 0)) {
                    console.error("CSSLoader: Loaded a stylesheet with no rules: ", css_href, styleSheet);
                    dfr.reject(css_href);
                    return;
                  }
                  found_stylesheet = true;
                } catch (error) {
                  ex = error;
                }
                break;
              }
            }
            if (!found_stylesheet) {
              console.error("CSSLoader: Stylesheet not correctly loaded: ", css_href);
              dfr.reject(css_href);
              return;
            }
          }
          old_css_nodes = [];
          ref4 = DOM.matchSelector(document.head, "link[name='" + _this.__cssName + "']");
          for (k = 0, len2 = ref4.length; k < len2; k++) {
            css_node = ref4[k];
            if (css_node !== cssNode) {
              CUI.DOM.remove(css_node);
              old_css_nodes.push(css_node);
            }
          }
          CUI.DOM.setAttribute(document.body, "cui-theme", name);
          Events.trigger({
            type: "viewport-resize",
            info: {
              css_load: true
            }
          });
          dfr.resolve(css_href);
        };
      })(this)
    });
    Events.listen({
      node: cssNode,
      type: "error",
      call: (function(_this) {
        return function(ev, info) {
          console.error("CSS.load: loading error:", url);
          dfr.reject(css_href);
        };
      })(this)
    });
    document.head.appendChild(cssNode);
    return dfr.promise();
  };

  return CSSLoader;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Template,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Template = (function(superClass) {
  extend(Template, superClass);

  function Template(opts1) {
    var node;
    this.opts = opts1 != null ? opts1 : {};
    Template.__super__.constructor.call(this, this.opts);
    node = Template.nodeByName[this._name];
    assert(node, "CUI.Template", this._name + " not found. Make sure to call Template.loadFile(...).");
    this.DOM = node.cloneNode(true);
    if (this._class) {
      DOM.addClass(this.DOM, this._class);
    }
    CUI.DOM.setElement(this.DOM, this);
    this.map = this.getElMap(this._map);
    if (!CUI.isEmptyObject(this.map) && this._set_template_empty) {
      CUI.DOM.addClass(this.DOM, "cui-template-empty");
    }
    if (this._init_flex_handles) {
      this.initFlexHandles();
    }
    return;
  }

  Template.prototype.initOpts = function() {
    Template.__super__.initOpts.call(this);
    this.addOpts({
      name: {
        mandatory: true,
        check: String
      },
      map_prefix: {
        check: String
      },
      init_flex_handles: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      set_template_empty: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      map: {
        type: "PlainObject",
        "default": {}
      },
      "class": {
        check: String
      }
    });
    return this;
  };

  Template.prototype.initFlexHandles = function(pane_opts) {
    var fh, fh_el, fh_name, i, k, len, opts, ref, ref1, v;
    if (pane_opts == null) {
      pane_opts = {};
    }
    this.__flexHandles = {};
    ref = CUI.DOM.matchSelector(this.DOM, "[data-cui-flex-handle]");
    for (i = 0, len = ref.length; i < len; i++) {
      fh_el = ref[i];
      opts = this.readOptsFromAttr(CUI.DOM.getAttribute(fh_el, "data-cui-flex-handle"));
      if (pane_opts[opts.name]) {
        ref1 = pane_opts[opts.name];
        for (k in ref1) {
          v = ref1[k];
          if (!opts.hasOwnProperty(k)) {
            opts[k] = v;
          }
        }
      } else {
        opts.manage_state = false;
      }
      opts.element = fh_el;
      fh = new FlexHandle(opts);
      if (!isEmpty(fh_name = fh.getName())) {
        this.__flexHandles[fh_name] = fh;
        fh.init();
      }
    }
    return this;
  };

  Template.prototype.getFlexHandle = function(name) {
    var fh;
    assert(this.__flexHandles, "Template.getFlexHandle", "flexHandles are not initialized yet, call Template.initFlexHandles(opts) first.", {
      name: name
    });
    fh = this.__flexHandles[name];
    assert(fh instanceof FlexHandle, this.__cls + ".getFlexHandle", "FlexHandle \"" + name + "\" not found, make sure you have specified a name in the cui-flex-handle attribute.", {
      opts: this.opts,
      flexHandles: this.__flexHandles
    });
    return fh;
  };

  Template.prototype.getFlexHandles = function() {
    return this.__flexHandles;
  };

  Template.prototype.getElMap = function(map) {
    var clean_k, el_map, k, map_obj, misses, prefix, report, sel, v;
    el_map = {};
    report = [];
    misses = 0;
    for (k in map) {
      v = map[k];
      if (isNull(v)) {
        continue;
      }
      if (v === true) {
        clean_k = k.replace(/_/g, "-");
        if (this._map_prefix) {
          sel = "." + this._map_prefix + "-" + clean_k;
        } else {
          prefix = toDash(this._name);
          sel = ".ez-" + prefix + "-" + clean_k + ",.cui-" + prefix + "-" + clean_k;
        }
        sel = sel + ',[data-slot="' + CUI.escapeAttribute(k) + '"]';
      } else {
        sel = v;
      }
      map_obj = CUI.DOM.matchSelector(this.DOM, sel, true);
      if (map_obj.length === 0) {
        report.push("* " + k + ": not found (" + sel + ")");
        misses++;
      } else if (map_obj.length > 1) {
        CUI.debug(k, v, "found more than once", map_obj, this.DOM);
        report.push("* " + k + ": found more than once (" + sel + ")");
        misses++;
      } else {
        report.push("+ " + k + ": found");
        el_map[k] = CUI.jQueryCompat(map_obj[0]);
        (function(_this) {
          return (function(k) {
            el_map[k].empty = function() {
              _this.empty(k);
              return el_map[k];
            };
            el_map[k].append = function(value) {
              _this.append(value, k);
              return el_map[k];
            };
            return el_map[k].prepend = function(value) {
              _this.prepend(value, k);
              return el_map[k];
            };
          });
        })(this)(k);
      }
    }
    if (misses) {
      alert(("Not all required elements were found for Template:\n\n\"" + this._name + "\"\n\n") + report.join("\n"));
    }
    return el_map;
  };

  Template.prototype.destroy = function() {
    DOM.remove(this.DOM);
    delete this.map;
    return Template.__super__.destroy.call(this);
  };

  Template.prototype.addClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".addClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.addClass(this.map[key], cls);
    } else {
      return DOM.addClass(this.DOM, cls);
    }
  };

  Template.prototype.removeClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".removeClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.removeClass(this.map[key], cls);
    } else {
      return DOM.removeClass(this.DOM, cls);
    }
  };

  Template.prototype.hasClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".hasClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.hasClass(this.map[key], cls);
    } else {
      return DOM.hasClass(this.DOM, cls);
    }
  };

  Template.prototype.has = function(key) {
    return !!this.map[key];
  };

  Template.prototype.empty = function(key) {
    var is_empty;
    assert(this.map, "Template[" + this._name + "].empty [" + (this.getUniqueId()) + "]", "Already destroyed", {
      template: this,
      name: this._name
    });
    if (this.isEmpty(key)) {
      if (key) {
        return this.map[key];
      } else {
        return this.DOM;
      }
    }
    if (key) {
      assert(this.map[key], this.__cls + ".empty", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
      CUI.DOM.empty(this.map[key]);
      is_empty = true;
      for (key in this.map) {
        if (!this.isEmpty(key)) {
          is_empty = false;
          break;
        }
      }
      if (is_empty && this._set_template_empty) {
        CUI.DOM.addClass(this.DOM, "cui-template-empty");
      }
      return this.map[key];
    }
    if (CUI.isEmptyObject(this.map)) {
      DOM.empty(this.DOM);
    } else {
      for (key in this.map) {
        DOM.empty(this.map[key]);
      }
      if (this._set_template_empty) {
        CUI.DOM.addClass(this.DOM, "cui-template-empty");
      }
    }
    return this.DOM;
  };

  Template.prototype.replace = function(value, key, element) {
    assert(this.map, "Template[" + this._name + "].replace [" + (this.getUniqueId()) + "]", "Already destroyed");
    if (key) {
      assert(this.map[key], this.__cls + ".replace", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
    }
    this.empty(key);
    return this.append(value, key, element);
  };

  Template.prototype.text = function(value, key, element) {
    assert(isString(value), this.__cls + ".text", "Value must be String", {
      value: value,
      key: key,
      element: element
    });
    if (key) {
      return this.map[key].text(value);
    } else {
      return this.DOM.text(value);
    }
  };

  Template.prototype.prepend = function(value, key, element) {
    return this.append(value, key, element, true);
  };

  Template.prototype.append = function(value, key, element, prepend) {
    var _value, appends, fn, i, len, node;
    if (prepend == null) {
      prepend = false;
    }
    if (prepend) {
      fn = "prepend";
    } else {
      fn = "append";
    }
    assert(this.map, "Template[" + this._name + "]." + fn + " [" + (this.getUniqueId()) + "]", "Already destroyed");
    if (key) {
      assert(this.map[key], this.__cls + "." + fn, "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
    }
    if (CUI.isFunction(value)) {
      value = value(element);
    }
    if (!CUI.isArray(value)) {
      value = [value];
    }
    appends = [];
    for (i = 0, len = value.length; i < len; i++) {
      _value = value[i];
      if (_value != null ? _value.DOM : void 0) {
        appends.push(_value.DOM);
      } else {
        assert(!isPromise(_value), "Template.append", "value cannot be Promise", {
          value: value
        });
        if (_value) {
          appends.push(_value);
        }
      }
    }
    if (key) {
      node = this.map[key];
    } else {
      node = this.DOM;
    }
    if (appends.length > 0) {
      CUI.DOM[fn](node, appends);
      if (this._set_template_empty) {
        CUI.DOM.removeClass(this.DOM, "cui-template-empty");
      }
    }
    return node;
  };

  Template.prototype.isEmpty = function(key) {
    if (!key) {
      return !this.DOM.firstChild;
    } else {
      assert(this.map[key], this.__cls + ".isEmpty", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
      return !this.map[key].firstChild;
    }
  };

  Template.prototype.removeEmptySlots = function() {
    var key, node, ref;
    ref = this.map;
    for (key in ref) {
      node = ref[key];
      if (!node.firstChild) {
        DOM.remove(node);
      }
    }
    return this;
  };

  Template.nodeByName = {};

  Template.start = function() {
    var dfr;
    dfr = new CUI.Deferred();
    this.load();
    if (!this.nodeByName["cui-base"]) {
      CUI.Template.loadFile("easydbui.html").done((function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this));
    } else {
      dfr.resolve();
    }
    return dfr.promise();
  };

  Template.loadTemplateFile = function(filename) {
    return this.loadFile(filename, true);
  };

  Template.loadFile = function(filename, load_templates) {
    var div, p;
    if (load_templates == null) {
      load_templates = false;
    }
    if (filename.match("^(https://|http://|/)")) {
      p = filename;
    } else {
      p = CUI.getPathToScript() + filename;
    }
    div = CUI.DOM.element("DIV", {
      style: "display:none;"
    });
    return new CUI.XHR({
      url: p,
      responseType: "text"
    }).start().done(function(data) {
      var count;
      div.innerHTML = data;
      if (!load_templates) {
        document.body.appendChild(div);
      } else {
        count = Template.load(div);
        if (div.children.length > 0) {
          document.body.appendChild(div);
          console.warn("Template.loadFile:", filename, "contains extra content.", div);
        }
        if (count === 0) {
          console.warn("Template.loadFile:", filename, "contains no Templates.");
        } else {

        }
      }
    }).fail(function(xhr) {
      return console.error("Template.loadFile: Unable to load filename: \"" + filename + "\", see Console for more details. You can however, output easydbui.html manually before loading easydbui.js.", xhr);
    });
  };

  Template.load = function(start_element) {
    var cls, count, el, i, j, len, len1, name, ref, ref1;
    if (start_element == null) {
      start_element = document.documentElement;
    }
    count = 0;
    ref = CUI.DOM.matchSelector(start_element, ".cui-tmpl,[data-template]");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      name = null;
      name = el.getAttribute("data-template");
      if (isEmpty(name)) {
        ref1 = el.classList;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          cls = ref1[j];
          if (cls.startsWith("cui-tmpl-")) {
            name = cls.substr(9);
            if (Template.nodeByName[name]) {
              console.error("Template.load:", name, "already found in DOM tree. Make sure all elements exists only once.", el);
              continue;
            }
            break;
          }
        }
      }
      if (name) {
        Template.nodeByName[name] = el;
        CUI.DOM.remove(el);
        el.classList.remove("cui-tmpl");
        el.removeAttribute("data-template");
        count = count + 1;
      }
    }
    return count;
  };

  return Template;

})(CUI.Element);

Template = CUI.Template;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FlexHandle,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FlexHandle = (function(superClass) {
  extend(FlexHandle, superClass);

  function FlexHandle(opts1) {
    var c, children, i, idx, len;
    this.opts = opts1 != null ? opts1 : {};
    FlexHandle.__super__.constructor.call(this, this.opts);
    this.__pane = null;
    children = this._element.parentNode.children;
    for (idx = i = 0, len = children.length; i < len; idx = ++i) {
      c = children[idx];
      if (CUI.DOM.is(c, this._pane)) {
        this.__pane = c;
        this.__pane_idx = idx;
      }
      if (CUI.DOM.is(c, this._element)) {
        this.__element_idx = idx;
      }
    }
    this.__adjacent_pane = null;
    if (this.__element_idx > this.__pane_idx) {
      if (this.__element_idx < children.length - 1) {
        this.__adjacent_pane = children[this.__element_idx + 1];
      }
    } else {
      if (this.__element_idx > 0) {
        this.__adjacent_pane = children[this.__element_idx - 1];
      }
    }
    this.__closed = this._closed;
    this.__hidden = this._hidden;
    this.__stretched = null;
    this.__size = null;
    assert(this.__pane, "new " + this.__cls, "pane \"" + this._pane + "\" not found in parent element of cui-flex-handle element.", {
      opts: this.opts,
      children: children
    });
    CUI.DOM.data(this.__pane, "flexHandle", this);
    CUI.DOM.setAttribute(this.__pane, "flex-handled-pane", this._name);
  }

  FlexHandle.prototype.readOpts = function() {
    var ref, ref1, ref2;
    FlexHandle.__super__.readOpts.call(this);
    if ((ref = this._direction) === "horizontal" || ref === "row") {
      this.__direction = "row";
    } else if ((ref1 = this._direction) === "vertical" || ref1 === "column") {
      this.__direction = "column";
    }
    assert((ref2 = this.__direction) === "row" || ref2 === "column", "new " + this.__cls, "opts.direction needs to be set", {
      opts: this.opts,
      element: this._element[0]
    });
    if (this._label) {
      this.addLabel(this._label);
    }
  };

  FlexHandle.prototype.initOpts = function() {
    FlexHandle.__super__.initOpts.call(this);
    return this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return isElement(v);
        }
      },
      pane: {
        mandatory: true,
        check: String
      },
      name: {
        mandatory: true,
        check: String
      },
      closed: {
        check: Boolean
      },
      closable: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      label: {
        check: function(v) {
          return v instanceof Label || CUI.isPlainObject(v);
        }
      },
      hidden: {
        check: Boolean
      },
      direction: {
        check: ["horizontal", "vertical", "row", "column"]
      },
      manage_state: {
        "default": true,
        check: Boolean
      },
      state_name: {
        check: String
      },
      "class": {
        check: String
      }
    });
  };

  FlexHandle.prototype.init = function() {
    var axis, drag_start_size, dragging;
    if (this.isDestroyed()) {
      return;
    }
    DOM.addClass(this._element, "cui-flex-handle cui-flex-handle-" + this.__direction + " cui-flex-handle-" + this._name);
    if (this.__closed) {
      this.close();
    }
    if (this.__hidden) {
      this.hide();
    }
    if (this._class) {
      CUI.DOM.addClass(this._element, this._class);
    }
    if (this.__direction === "row") {
      axis = "x";
      this.__css_value = "Width";
    } else {
      axis = "y";
      this.__css_value = "Height";
    }
    Events.listen({
      type: "dblclick",
      node: this._element,
      call: (function(_this) {
        return function(ev) {
          if (_this.__size === null) {
            if (_this.isClosed()) {
              _this.open();
            } else if (_this._closable) {
              _this.close();
            }
          } else {
            _this.resetSize();
          }
          _this.storeState();
        };
      })(this)
    });
    Events.listen({
      type: ["click"],
      node: this._element,
      call: (function(_this) {
        return function(ev) {
          if (!_this.__label) {
            return;
          }
          if (_this.isClosed()) {
            _this.open();
            _this.storeState();
          }
        };
      })(this)
    });
    drag_start_size = null;
    new Draggable({
      element: this._element,
      axis: axis,
      support_touch: true,
      create: (function(_this) {
        return function() {
          if (_this.isClosed()) {
            return false;
          }
        };
      })(this),
      dragstart: (function(_this) {
        return function(ev, gd) {
          var adj_data, data, flip, get_data, max_diff;
          if (_this.__pane_idx < _this.__element_idx) {
            flip = 1;
          } else {
            flip = -1;
          }
          get_data = function(pane) {
            var dim, min;
            dim = DOM.getDimensions(pane);
            min = dim["min" + _this.__css_value];
            if (min < 10) {
              min = 10;
            }
            return {
              min: min,
              max: dim["max" + _this.__css_value],
              value: dim["contentBox" + _this.__css_value]
            };
          };
          data = get_data(_this.__pane);
          if (_this.__adjacent_pane) {
            adj_data = get_data(_this.__adjacent_pane);
            max_diff = adj_data.value - adj_data.min;
            data.max = Math.max(0, data.value + max_diff);
          }
          drag_start_size = _this.__pane.style[_this.__css_value.toLowerCase()];
          gd.__pane_data = {
            flip: flip,
            axis: axis,
            min: data.min,
            max: data.max,
            value: data.value
          };
          gd.isFlexHandleDrag = true;
          return gd;
        };
      })(this),
      get_cursor: function(gd) {
        if (gd.__pane_data.axis === "x") {
          return "ew-resize";
        } else {
          return "ns-resize";
        }
      },
      dragend: (function(_this) {
        return function(ev, gd) {
          dragging(gd);
          _this.__size = DOM.getDimension(_this.__pane, "contentBox" + _this.__css_value);
          return _this.storeState();
        };
      })(this),
      dragstop: (function(_this) {
        return function() {
          _this.__pane.style[_this.__css_value.toLowerCase()] = drag_start_size;
          drag_start_size = null;
          return _this.__resize();
        };
      })(this),
      dragging: (function(_this) {
        return function(ev, gd) {
          if (!CUI.__ng__ || CUI.browser.ie) {
            return;
          }
          return dragging(gd);
        };
      })(this)
    });
    dragging = (function(_this) {
      return function(gd) {
        var new_value;
        new_value = gd.__pane_data.value + gd.dragDiff[gd.__pane_data.axis] * gd.__pane_data.flip;
        if (gd.__pane_data.min) {
          new_value = Math.max(gd.__pane_data.min, new_value);
        }
        if (gd.__pane_data.max) {
          new_value = Math.min(gd.__pane_data.max, new_value);
        }
        return _this.__setSize(new_value);
      };
    })(this);
    if (this._manage_state) {
      if (!this._state_name) {
        console.error("new FlexHandle()", "opts.state_name missing, state will not be stored.", this.opts);
      }
      this.__state_name = this._state_name;
      this.__setState();
    }
    return this;
  };

  FlexHandle.prototype.__setSize = function(size) {
    if (isNull(size)) {
      DOM.setStyleOne(this.__pane, this.__css_value.toLowerCase(), "");
      if (this.__isAlive()) {
        if (DOM.getDimension(this.__pane, "contentBox" + this.__css_value) === 0) {
          CUI.error("FlexHandle.__setSize: Pane size is 0 if unset, this needs to be fixed in CSS.", this.__pane[0]);
          DOM.setDimension(this.__pane, "contentBox" + this.__css_value, 100);
        }
      }
      this.__pane.classList.remove("cui-is-manually-sized");
      this._element.classList.remove("cui-is-manually-sized");
      this.__size = null;
    } else {
      this.__pane.classList.add("cui-is-manually-sized");
      this._element.classList.add("cui-is-manually-sized");
      DOM.setDimension(this.__pane, "contentBox" + this.__css_value, size);
      this.__size = size;
    }
    return this.__resize();
  };

  FlexHandle.prototype.resetSize = function() {
    this.__setSize(null);
    return this;
  };

  FlexHandle.prototype.__getSize = function() {
    return this.__size;
  };

  FlexHandle.prototype.__isAlive = function() {
    if (this.isDestroyed() || !CUI.DOM.isInDOM(this._element)) {
      return false;
    } else {
      return true;
    }
  };

  FlexHandle.prototype.__resize = function() {
    if (!this.__isAlive()) {
      return;
    }
    return Events.trigger({
      type: "viewport-resize",
      info: {
        FlexHandle: true
      }
    });
  };

  FlexHandle.prototype.__getState = function() {
    var state, value;
    value = CUI.getLocalStorage(this.__state_name);
    if (!isNull(value)) {
      state = JSON.parse(value);
    } else {
      state = {};
    }
    return state;
  };

  FlexHandle.prototype.__setState = function() {
    var state;
    if (!this.__state_name) {
      return;
    }
    state = this.__getState();
    if (!isUndef(state.closed) && this._closable) {
      if (state.closed) {
        this.close();
      } else {
        this.open();
      }
    }
    if (!isUndef(state.size)) {
      this.__setSize(state.size);
    }
    return this;
  };

  FlexHandle.prototype.storeState = function() {
    var state, value;
    if (!this.__state_name) {
      return;
    }
    state = {
      closed: this.isClosed(),
      size: this.__getSize()
    };
    value = JSON.stringify(state);
    CUI.setLocalStorage(this.__state_name, value);
    console.info("FlexHandle.storeState: ", this.__state_name, value);
    return this;
  };

  FlexHandle.prototype.isStretched = function() {
    return this.__stretched;
  };

  FlexHandle.prototype.stretch = function(direction, do_stretch) {
    var el, els, i, j, len, len1, pane, set;
    if (do_stretch == null) {
      do_stretch = true;
    }
    if (do_stretch) {
      if (this.isStretched() === direction) {
        return;
      } else {
        this.unstretch();
      }
    }
    pane = this.getPane();
    switch (direction) {
      case "west":
      case "north":
        els = DOM.findPreviousSiblings(pane);
        break;
      case "east":
      case "south":
        els = DOM.findNextSiblings(pane);
    }
    switch (direction) {
      case "west":
      case "east":
        set = "width";
        break;
      case "north":
      case "south":
        set = "height";
    }
    if (do_stretch) {
      for (i = 0, len = els.length; i < len; i++) {
        el = els[i];
        el.classList.add("cui-flex-handle-hide-for-stretch");
        el.classList.add("cui-flex-handle-hide-for-stretch-" + direction);
      }
      this.__pane[set]("");
      pane.classList.add("cui-flex-handle-stretched");
      pane.classList.add("cui-flex-handle-stretched-" + direction);
      Events.trigger({
        node: pane,
        type: "flex-stretch-start"
      });
      this.__stretched = direction;
    } else {
      for (j = 0, len1 = els.length; j < len1; j++) {
        el = els[j];
        el.classList.remove("cui-flex-handle-hide-for-stretch");
        el.classList.remove("cui-flex-handle-hide-for-stretch-" + direction);
      }
      this.__stretched = null;
      if (this.__size) {
        this.__pane[set](this.__size);
      }
      pane.classList.remove("cui-flex-handle-stretched");
      pane.classList.remove("cui-flex-handle-stretched-" + direction);
      Events.trigger({
        node: pane,
        type: "flex-stretch-end"
      });
      this.__resize();
    }
    return this;
  };

  FlexHandle.prototype.unstretch = function() {
    if (!this.isStretched()) {
      return;
    }
    return this.stretch(this.__stretched, false);
  };

  FlexHandle.prototype.getLabel = function() {
    if (!this.__isAlive()) {
      return null;
    }
    return this.__label;
  };

  FlexHandle.prototype.addLabel = function(opts) {
    if (opts == null) {
      opts = {};
    }
    if (opts instanceof Label) {
      this.__label = opts;
    } else {
      if (this.__direction === "row") {
        opts.rotate_90 = true;
      }
      this.__label = new CUI.defaults["class"].Label(opts);
    }
    DOM.append(this._element, this.__label.DOM);
    return DOM.addClass(this._element, "cui-flex-handle-has-label");
  };

  FlexHandle.prototype.getName = function() {
    return this._name;
  };

  FlexHandle.prototype.getHandle = function() {
    return this._element;
  };

  FlexHandle.prototype.getPane = function() {
    return this.__pane;
  };

  FlexHandle.prototype.isShown = function() {
    return !this.isHidden();
  };

  FlexHandle.prototype.isHidden = function() {
    return this._element.classList.contains("cui-flex-handle-hidden");
  };

  FlexHandle.prototype.isClosed = function() {
    return this._element.classList.contains("cui-flex-handle-closed");
  };

  FlexHandle.prototype.isOpen = function() {
    return !this.isClosed();
  };

  FlexHandle.prototype.close = function() {
    if (this.isClosed()) {
      return this;
    }
    Events.trigger({
      node: this.getPane(),
      type: "flex-close"
    });
    this._element.classList.add("cui-flex-handle-closed");
    this.__pane.css("display", "none");
    this.__resize();
    return this;
  };

  FlexHandle.prototype.open = function() {
    if (this.isOpen()) {
      return this;
    }
    this._element.classList.remove("cui-flex-handle-closed");
    this.__pane.css("display", "");
    delete this.__closed;
    this.__resize();
    return this;
  };

  FlexHandle.prototype.hide = function() {
    if (this.isHidden()) {
      return this;
    }
    this._element.classList.add("cui-flex-handle-hidden");
    this.__resize();
    return this;
  };

  FlexHandle.prototype.show = function() {
    if (this.isShown()) {
      return this;
    }
    this._element.classList.remove("cui-flex-handle-hidden");
    delete this.__hidden;
    this.__resize();
    return this;
  };

  FlexHandle.prototype.destroy = function() {
    DOM.removeData(this.__pane, "flexHandle");
    DOM.removeAttribute(this.__pane, "flex-handled-pane");
    DOM.remove(this._element);
    return FlexHandle.__super__.destroy.call(this);
  };

  FlexHandle.getStretchButton = function(_opts) {
    var activedir, btn_opts, k, opts, ref, v;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "FlexHandle.getPushButton", {
      direction: {
        check: ["west", "east", "north", "south"]
      },
      text: {
        check: String
      },
      flexHandle: {
        check: FlexHandle
      },
      button: {
        "default": {}
      }
    });
    activedir = {
      west: "east",
      east: "west",
      north: "south",
      south: "north"
    };
    btn_opts = opts.button;
    ref = {
      icon_active: activedir[opts.direction],
      icon_inactive: opts.direction,
      "class": "cui-pane-stretch-button",
      text: opts.text,
      "switch": true,
      onClick: (function(_this) {
        return function(ev, btn) {
          var fh, fh_els;
          if (opts.flexHandle) {
            fh = opts.flexHandle;
          } else {
            fh_els = btn.DOM.closest("[flex-handled-pane]");
            assert(fh_els.length === 1, "FlexHandle.getStretchButton", "FlexHandle not or more than one found, name: " + opts.name + ".", {
              opts: opts,
              flexHandles: fh_els
            });
            fh = DOM.data(fh_els[0], "flexHandle");
          }
          if (fh.isStretched()) {
            return fh.unstretch();
          } else {
            return fh.stretch(opts.direction);
          }
        };
      })(this)
    };
    for (k in ref) {
      v = ref[k];
      btn_opts[k] = v;
    }
    return new CUI.defaults["class"].Button(btn_opts);
  };

  return FlexHandle;

})(CUI.Element);

CUI.Events.registerEvent({
  type: ["flex-stretch-start", "flex-stretch-end", "flex-close"],
  sink: true
});
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Layout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Layout = (function(superClass) {
  extend(Layout, superClass);

  function Layout(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    Layout.__super__.constructor.call(this, this.opts);
    this.__isInit = false;
    this.init();
  }

  Layout.prototype.initOpts = function() {
    var i, len, pn, ref, results;
    Layout.__super__.initOpts.call(this);
    this.addOpts({
      absolute: {
        check: Boolean
      },
      maximize: {
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean
      },
      maximize_vertical: {
        check: Boolean
      },
      auto_buttonbar: {
        "default": true,
        mandatory: true,
        check: Boolean
      },
      center: {
        "default": {},
        check: "PlainObject"
      }
    });
    ref = this.getSupportedPanes();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      results.push(this.addOpt(pn, {
        check: function(v) {
          return CUI.isPlainObject(v) || v === false;
        }
      }));
    }
    return results;
  };

  Layout.prototype.readOpts = function() {
    this.initDefaultPanes();
    Layout.__super__.readOpts.call(this);
    this.maximizeReadOpts();
    if (this._absolute) {
      assert(this.__maximize, "new " + this.__cls, "opts.absolute needs opts.maximize to be set.", {
        opts: this.opts
      });
    }
    return this;
  };

  Layout.prototype.maximizeAddClasses = function() {
    if (this.__maximize) {
      this.addClass("cui-maximize");
    }
    if (this.__maximize_horizontal) {
      this.addClass("cui-maximize-horizontal");
    }
    if (this.__maximize_vertical) {
      this.addClass("cui-maximize-vertical");
    }
    return this;
  };

  Layout.prototype.maximizeReadOpts = function() {
    if (isNull(this._maximize) && isNull(this._maximize_horizontal) && isNull(this._maximize_vertical)) {
      this._maximize = true;
    }
    if (this._maximize) {
      assert(!this._maximize_horizontal && !this._maximize_vertical, "new " + getObjectClass(this), "opts.maximize cannot be set together with opts.maximize_horizontal or opts.maximize_vertical", {
        opts: this.opts
      });
      this.__maximize_horizontal = true;
      this.__maximize_vertical = true;
    } else {
      if (this._maximize_horizontal) {
        this.__maximize_horizontal = true;
      }
      if (this._maximize_vertical) {
        this.__maximize_vertical = true;
      }
    }
    if (this.__maximize_vertical && this.__maximize_horizontal) {
      this.__maximize = true;
    }
    return this;
  };

  Layout.prototype.init = function() {
    return this.__init();
  };

  Layout.prototype.getTemplateMap = function() {
    var i, len, map, pn, ref;
    map = {};
    ref = this.__panes;
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      map[pn] = true;
    }
    return map;
  };

  Layout.prototype.__init = function() {
    var fn, has_flex_handles, i, j, len, len1, pane, pane_opts, pn, ref, ref1, ref2;
    assert(!(this._maximize === false && this._absolute === true), "Layout.__init", "opts.maximize == false and opts.absolute == true is not allowed.", {
      opts: this.opts
    });
    this.__panes = this.getPanes();
    this.__panes.push("center");
    this.__name = this.getName();
    this.__layout = new Template({
      name: this.__name,
      map_prefix: this.getMapPrefix(),
      map: this.getTemplateMap()
    });
    this.registerTemplate(this.__layout);
    if (this.__maximize_horizontal && this.__maximize_vertical) {
      Events.listen({
        type: "content-resize",
        instance: this,
        node: this.DOM,
        call: (function(_this) {
          return function(ev) {
            if (DOM.closest(_this.DOM, '.cui-absolute')) {
              return;
            }
            return ev.stopPropagation();
          };
        })(this)
      });
    }
    this.maximizeAddClasses();
    this.addClass(this.getMapPrefix());
    if (this._absolute) {
      this.addClass("cui-absolute");
      assert((ref = CUI.DOM.getAttribute(this.DOM, "data-cui-absolute-container")) === "row" || ref === "column", "new Layout", "opts.absolute: template must include a cui-absolute-container attribute set to \"row\" or \"column\".");
      DOM.waitForDOMInsert({
        node: this.DOM
      }).done((function(_this) {
        return function() {
          return Layout.all();
        };
      })(this));
    }
    this.__buttonbars = {};
    if (this.hasFlexHandles()) {
      has_flex_handles = true;
      pane_opts = {};
      ref1 = this.__panes;
      for (i = 0, len = ref1.length; i < len; i++) {
        pn = ref1[i];
        pane = this["_" + pn];
        if (pane != null ? pane.flexHandle : void 0) {
          pane_opts[pn] = pane.flexHandle;
        }
      }
      this.__layout.initFlexHandles(pane_opts);
    } else {
      has_flex_handles = false;
    }
    ref2 = this.__panes;
    fn = (function(_this) {
      return function(pn) {
        return _this[pn] = function() {
          assert(_this["_" + pn], _this.__cls + "." + pn, "Pane \"" + pn + "\" not initialized.", {
            opts: _this.opts
          });
          assert(!_this.__layout.isDestroyed(), "Layout already destroyed, cannot get pane \"" + pn + "\".");
          return _this.__layout.map[pn];
        };
      };
    })(this);
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      pn = ref2[j];
      fn(pn);
      pane = this["_" + pn];
      if (pane) {
        this.__initPane(pane, pn);
        if (has_flex_handles && pn !== "center" && !pane.flexHandle) {
          this.__layout.getFlexHandle(pn).destroy();
        }
      } else {
        this.__layout.map[pn].remove();
        if (has_flex_handles) {
          this.__layout.getFlexHandle(pn).destroy();
        }
      }
    }
    return this.__isInit = true;
  };

  Layout.prototype.destroy = function() {
    Events.ignore({
      instance: this
    });
    return Layout.__super__.destroy.call(this);
  };

  Layout.prototype.getMapPrefix = function() {
    return void 0;
  };

  Layout.prototype.__initPane = function(options, pane_name) {
    var opts;
    assert(pane_name, "Layout.initPane", "pane_name must be set", {
      options: options,
      pane_name: pane_name
    });
    opts = CUI.Element.readOpts(options, "new Layout.__initPane", {
      "class": {
        check: String
      },
      content: {},
      flexHandle: {}
    });
    this.append(opts.content, pane_name);
    if (opts["class"]) {
      return this.__layout.addClass(opts["class"], pane_name);
    }
  };

  Layout.prototype.hasFlexHandles = function() {
    return true;
  };

  Layout.prototype.initDefaultPanes = function() {
    var i, len, pn, ref;
    ref = this.getPanes();
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      if (!this.opts.hasOwnProperty(pn)) {
        this.opts[pn] = {};
      }
    }
    return this;
  };

  Layout.prototype.getPanes = function() {
    return assert(false, this.__cls + ".getPanes", "Needs implementation");
  };

  Layout.prototype.getSupportedPanes = function() {
    return assert(false, this.__cls + ".getSupportedPanes", "Needs implementation");
  };

  Layout.prototype.getLayout = function() {
    return this.__layout;
  };

  Layout.prototype.getButtonbar = function(key) {
    if (!this.__buttonbars[key]) {
      this.__buttonbars[key] = new Buttonbar();
      DOM.prototype.append.call(this, this.__buttonbars[key], key);
    }
    return this.__buttonbars[key];
  };

  Layout.prototype.__callAutoButtonbar = function(value, key) {
    var _v, get_value, i, len, results, v;
    if (CUI.isFunction(value)) {
      value = value(this);
    }
    get_value = function(v) {
      if (CUI.isPlainObject(v)) {
        return new CUI.defaults["class"].Button(v);
      } else {
        return v;
      }
    };
    value = get_value(value);
    if (CUI.isArray(value)) {
      results = [];
      for (i = 0, len = value.length; i < len; i++) {
        _v = value[i];
        v = get_value(_v);
        if (v instanceof Button) {
          results.push(this.getButtonbar(key).addButton(v));
        } else {
          results.push(DOM.prototype.append.call(this, _v, key));
        }
      }
      return results;
    } else if (value instanceof Button) {
      return this.getButtonbar(key).addButton(value);
    } else {
      return DOM.prototype.append.call(this, value, key);
    }
  };

  Layout.prototype.append = function(value, key, auto_buttonbar) {
    if (auto_buttonbar == null) {
      auto_buttonbar = this._auto_buttonbar;
    }
    if (auto_buttonbar) {
      return this.__callAutoButtonbar(value, key);
    } else {
      return Layout.__super__.append.call(this, value, key);
    }
  };

  Layout.prototype.replace = function(value, key, auto_buttonbar) {
    if (auto_buttonbar == null) {
      auto_buttonbar = this._auto_buttonbar;
    }
    if (auto_buttonbar) {
      delete this.__buttonbars[key];
      this.empty(key);
      return this.__callAutoButtonbar(value, key);
    } else {
      return Layout.__super__.replace.call(this, value, key);
    }
  };

  Layout.prototype.setAbsolute = function() {
    this.addClass("cui-absolute");
    return Layout.__all();
  };

  Layout.prototype.unsetAbsolute = function() {
    var child, i, len, ref;
    this.DOM.removeAttribute("data-cui-absolute-check-value");
    this.DOM.removeAttribute("data-cui-absolute-values");
    ref = CUI.DOM.children(this.DOM);
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      CUI.DOM.setStyle(child, {
        top: "",
        left: "",
        right: "",
        bottom: ""
      });
    }
    this.removeClass("cui-absolute");
    return this;
  };

  Layout.prototype.getName = function() {
    return assert(false, this.__cls + ".getName", "Needs to be overwritten.");
  };

  Layout.setAbsolute = function(layout) {
    var abs_values, check_value, child, children, css, direction, i, idx, j, k, key, len, len1, len2, rect_check_key, rect_key, ref, set, value, values;
    assert(isElement(layout), "Layout.setAbsolute", "layout needs to be HTMLElement", {
      layout: layout
    });
    direction = CUI.DOM.getAttribute(layout, "data-cui-absolute-container");
    switch (direction) {
      case "row":
        rect_key = "marginBoxWidth";
        rect_check_key = "marginBoxHeight";
        break;
      case "column":
        rect_key = "marginBoxHeight";
        rect_check_key = "marginBoxWidth";
        break;
      default:
        assert(false, "Layout.setAbsolute", "cui-absolute-container is not set for .cui-absolute container or not set to row or column.", {
          container: layout,
          direction: direction
        });
    }
    values = [];
    children = DOM.children(layout);
    for (idx = i = 0, len = children.length; i < len; idx = ++i) {
      child = children[idx];
      values[idx] = DOM.getDimensions(child)[rect_key];
    }
    abs_values = values.join(",");
    check_value = DOM.getDimensions(layout)[rect_check_key] + "";
    if (CUI.DOM.getAttribute(layout, "data-cui-absolute-values") === abs_values && CUI.DOM.getAttribute(layout, "data-cui-absolute-check-value") === check_value) {
      return false;
    }
    if (CUI.DOM.getAttribute(layout, "data-cui-absolute-check-value") !== check_value) {
      CUI.DOM.setAttribute(layout, "data-cui-absolute-check-value", check_value);
    }
    if (CUI.DOM.getAttribute(layout, "data-cui-absolute-values") !== abs_values) {
      CUI.DOM.setAttribute(layout, "data-cui-absolute-values", abs_values);
      for (idx = j = 0, len1 = children.length; j < len1; idx = ++j) {
        child = children[idx];
        set = CUI.DOM.getAttribute(child, "data-cui-absolute-set");
        if (!set) {
          continue;
        }
        css = {};
        ref = set.split(",");
        for (k = 0, len2 = ref.length; k < len2; k++) {
          key = ref[k];
          switch (key) {
            case "left":
            case "top":
              if (idx > 0) {
                value = values.slice(0, idx).reduce(function(a, b) {
                  return a + b;
                });
              } else {
                value = 0;
              }
              break;
            case "right":
            case "bottom":
              if (idx + 1 < values.length) {
                value = values.slice(idx + 1).reduce(function(a, b) {
                  return a + b;
                });
              } else {
                value = 0;
              }
              break;
            default:
              assert(false, "Layout.setAbsolute: Unknown key " + key + " in data-cui-absolute-set.");
          }
          css[key] = value;
        }
        DOM.setStyle(child, css);
      }
    }
    return true;
  };

  Layout.__all = function() {
    var changed, i, idx, layout, layouts, len, ref;
    layouts = [];
    changed = 0;
    ref = DOM.matchSelector(document.documentElement, ".cui-absolute");
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      layout = ref[idx];
      if (Layout.setAbsolute(layout)) {
        changed++;
      }
    }
    if (changed > 0) {
      Events.trigger({
        type: "viewport-resize"
      });
    }
    return this;
  };

  Layout.all = function() {
    return CUI.scheduleCallback({
      call: Layout.__all
    });
  };

  return Layout;

})(CUI.DOM);

Layout = CUI.Layout;

CUI.ready(function() {
  return Events.listen({
    type: ["viewport-resize", "content-resize"],
    call: function(ev, info) {
      if (info.FlexHandle) {
        return Layout.__all();
      } else {
        return Layout.all();
      }
    }
  });
});
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Layer = (function(superClass) {
  extend(Layer, superClass);

  function Layer(opts) {
    var bc, body_clone, cls;
    this.opts = opts != null ? opts : {};
    Layer.__super__.constructor.call(this, this.opts);
    this.__layer = this.getTemplate();
    this.registerTemplate(this.__layer);
    this.__layer_root = new Template({
      "class": "cui-layer-root-" + (toDash(this.__cls) + " " + (this._class || "")).trim().split(/\s+/).join(" cui-layer-root-"),
      name: "layer-root"
    });
    if (this._backdrop) {
      this.__bd_policy = this._backdrop.policy || "click-thru";
      this.__backdrop = new Template({
        "class": "cui-layer-backdrop",
        name: "layer-backdrop"
      });
      this.__layer_root.addClass("cui-layer-backdrop-policy-" + this.__bd_policy);
      if (this._backdrop.content) {
        this.setBackdropContent(this._backdrop.content);
      } else if (this._backdrop.blur) {
        body_clone = document.body.firstChild.cloneNode(true);
        if (this.__bd_policy === "click-thru") {
          this.__backdrop_crop = this.__backdrop.DOM;
          this.setBackdropContent(body_clone);
        } else {
          this.__backdrop_crop = $div("cui-layer-backdrop-body-clone")[0];
          this.__backdrop_crop.appendChild(body_clone);
          this.setBackdropContent(this.__backdrop_crop);
        }
        this.__layer_root.addClass("cui-layer-root-backdrop-blur");
      }
      if (this.__bd_policy === "click-thru" && !this._backdrop.blur && !this._backdrop.content) {

      } else {
        this.__layer_root.DOM.appendChild(this.__backdrop.DOM);
        switch (this.__bd_policy) {
          case "click-thru":
            break;
          case "click":
            Events.listen({
              type: ["click", "contextmenu"],
              node: this.__backdrop,
              call: (function(_this) {
                return function(ev) {
                  if (ev.ctrlKey() && ev.getButton() === 2) {
                    return;
                  }
                  _this.hide(ev);
                  return ev.stopPropagation();
                };
              })(this)
            });
            break;
          case "modal":
            this.__backdrop.addClass("cui-layer-backdrop--visible");
            if (this._backdrop.add_bounce_class !== false) {
              if (isString(this._backdrop.add_bounce_class)) {
                bc = this._backdrop.add_bounce_class;
              } else {
                bc = "cui-layer-bounce";
              }
              Events.listen({
                type: "click",
                node: this.__backdrop,
                call: (function(_this) {
                  return function(ev) {
                    CUI.debug("clicked on modal backdrop", bc, _this._backdrop);
                    if (!_this.__layer) {
                      return;
                    }
                    Events.wait({
                      type: "transitionend",
                      node: _this.__layer
                    }).always(function() {
                      if (_this.isDestroyed()) {
                        return;
                      }
                      return _this.__layer.removeClass(bc);
                    });
                    _this.__layer.addClass(bc);
                  };
                })(this)
              });
            }
            break;
          default:
            assert("new " + this.__cls, "Unknown backdrop policy: \"" + this.__bd_policy + "\".");
        }
      }
    }
    if (this._visible === false) {
      this.setVisible(this._visible);
    }
    this.__layer_root.DOM.appendChild(this.__layer.DOM);
    if (this._handle_focus) {
      DOM.setAttribute(this.__layer.DOM, "tabindex", "0");
    }
    if (this._element) {
      this.__setElement(this._element);
    }
    if (this._use_element_width_as_min_width) {
      assert(this.__element, "new CUI.Layer", "opts.use_element_width_as_min_width requires opts.element to be set.", {
        opts: this.opts
      });
    }
    if (this._pointer) {
      if (this._class) {
        cls = "cui-layer-pointer-" + this._class.split(/\s+/).join(" cui-layer-pointer-");
      }
      this.__pointer = new Template({
        "class": cls,
        name: "layer-pointer"
      }).DOM;
      this.__layer_root.DOM.appendChild(this.__pointer);
    }
    this.__shown = false;
  }

  Layer.prototype.setBackdropContent = function(content) {
    assert(this.__backdrop, "CUI.Layer.setBackdropContent", "No backdrop found in layer", {
      layer: this
    });
    return this.__backdrop.DOM.append(content);
  };

  Layer.prototype.getTemplate = function() {
    return new Template({
      name: "layer"
    });
  };

  Layer.prototype.getLayerRoot = function() {
    return this.__layer_root;
  };

  Layer.prototype.getLayer = function() {
    return this.__layer;
  };

  Layer.prototype.initOpts = function() {
    Layer.__super__.initOpts.call(this);
    this.addOpts({
      backdrop: {
        "default": {
          policy: "click-thru",
          add_bounce_class: true,
          content: null
        },
        check: function(v) {
          if (CUI.isPlainObject(v) || v === false) {
            return true;
          }
        }
      },
      add_bounce_class: {
        deprecated: "use backdrop.add_bounce_class instead"
      },
      onBeforeShow: {
        check: Function
      },
      onShow: {
        check: Function
      },
      onPosition: {
        check: Function
      },
      onHide: {
        check: Function
      },
      handle_focus: {
        "default": true,
        check: Boolean
      },
      pointer: {
        check: ["arrow"]
      },
      placement: {
        check: String
      },
      placements: {
        check: function(v) {
          var a, i, len;
          if (!CUI.isArray(v)) {
            return false;
          }
          for (i = 0, len = v.length; i < len; i++) {
            a = v[i];
            if (this.knownPlacements.indexOf(a) === -1) {
              return false;
            }
          }
          return true;
        }
      },
      element: {
        check: function(v) {
          return isElement(v) || isElement(v != null ? v.DOM : void 0);
        }
      },
      use_element_width_as_min_width: {
        "default": false,
        check: Boolean
      },
      show_at_position: {
        check: function(v) {
          return CUI.isPlainObject(v) && v.top >= 0 && v.left >= 0;
        }
      },
      fill_space: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "both", "horizontal", "vertical"]
      },
      check_for_element: {
        "default": false,
        check: Boolean
      },
      show_ms: {
        "default": 700,
        check: (function(_this) {
          return function(v) {
            return v > 0;
          };
        })(this)
      },
      visible: {
        check: Boolean
      },
      hide_ms: {
        "default": 100,
        check: (function(_this) {
          return function(v) {
            return v > 0;
          };
        })(this)
      }
    });
    return this;
  };

  Layer.prototype.setVisible = function(on_off) {
    if (on_off == null) {
      on_off = true;
    }
    if (on_off) {
      return DOM.setStyleOne(this.__layer_root.DOM, "visibility", "");
    } else {
      return DOM.setStyleOne(this.__layer_root.DOM, "visibility", "hidden");
    }
  };

  Layer.prototype.knownPlacements = ["s", "e", "w", "ws", "wn", "n", "se", "ne", "es", "en", "nw", "sw", "c"];

  Layer.prototype.__setElement = function(element) {
    if (element instanceof CUI.DOM) {
      this.__element = element.getElementForLayer();
    } else if (element.DOM) {
      this.__element = element.DOM;
    } else {
      this.__element = element;
    }
      // console.log(this.__element === element)
      // console.log(element.DOM)
    assert(!DOM.closest(this.__element, ".cui-tmpl"), "Layer.__setElement", "element cannot be inside a Template.", {
      element: element
    });
    assert(this.__element instanceof HTMLElement, "Layer.__setElement", "element needs to be HTMLElement.", {
      element: element
    });
    return this.__element;
  };

  Layer.prototype.__getOriginalElement = function() {
    var ref;
    return ((ref = this._element) != null ? ref.DOM : void 0) || this._element || null;
  };

  Layer.prototype.autoSize = function() {
    return this.position();
  };

  Layer.prototype.position = function(ev) {
    var allowed_placements, available_placements, body_scroll_left, body_scroll_top, dbg_pl, dim_element, dim_layer, dim_pointer, dim_window, direction, get_pointer_class, get_pointer_direction, i, is_fixed, j, k, l, layer_pos, layer_pos_bottom, layer_pos_right, len, len1, len2, len3, len4, listener, m, marginBottom, marginLeft, marginRight, marginTop, minWidth, overlap_bottom, overlap_height, overlap_right, overlap_width, placement, placement_parts, pointer_direction, pointer_pos, pointer_pos_bottom, pointer_pos_right, pushNeeded, ref, ref1, ref2, ref3, ref4, ref5, set_css, show_dbg_div, sibl, spaceAvailable, vp, vp_pl, wanted_placement, wanted_rank;
    if (!this.isShown()) {
      return this;
    }
    dim_window = {
      width: document.body.clientWidth,
      height: window.innerHeight
    };
    get_pointer_direction = function(placement) {
      return {
        n: "s",
        s: "n",
        e: "w",
        w: "e"
      }[placement];
    };
    get_pointer_class = (function(_this) {
      return function(direction) {
        if (CUI.__ng__) {
          return "cui-layer-pointer--" + direction;
        } else {
          return "cui-pointer-placement-" + get_pointer_direction(direction);
        }
      };
    })(this);
    if (this.__pointer) {
      CUI.DOM.setStyle(this.__pointer, {
        top: 0,
        left: 0,
        margin: ""
      });
      ref = ["w", "s", "e", "n"];
      for (i = 0, len = ref.length; i < len; i++) {
        direction = ref[i];
        CUI.DOM.removeClass(this.__pointer, get_pointer_class(direction));
      }
    }
    dim_pointer = {};
    ref1 = ["n", "s", "e", "w"];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      placement = ref1[j];
      pointer_direction = get_pointer_direction(placement);
      if (this.__pointer) {
        CUI.DOM.addClass(this.__pointer, get_pointer_class(pointer_direction));
        dim_pointer[placement] = CUI.DOM.getDimensions(this.__pointer);
        CUI.DOM.removeClass(this.__pointer, get_pointer_class(pointer_direction));
      } else {
        dim_pointer[placement] = {
          borderBoxWidth: 0,
          borderBoxHeight: 0,
          marginLeft: 0,
          marginRight: 0,
          marginTop: 0,
          marginBottom: 0
        };
      }
      dim_pointer[placement].direction = pointer_direction;
    }
    CUI.DOM.setStyle(this.__layer.DOM, {
      position: "",
      top: "",
      left: "",
      width: "",
      height: "",
      margin: "",
      minWidth: "",
      maxWidth: "",
      maxHeight: ""
    });
    dim_layer = CUI.DOM.getDimensions(this.__layer.DOM);
    allowed_placements = (this._placements || this.knownPlacements).slice(0);
    wanted_placement = this._placement || allowed_placements[0];
    body_scroll_top = document.body.scrollTop;
    body_scroll_left = document.body.scrollLeft;
    if (this.__element) {
      dim_element = CUI.DOM.getDimensions(this.__element);
    } else if (this._show_at_position) {
      dim_element = {
        viewportTop: this._show_at_position.top,
        viewportLeft: this._show_at_position.left
      };
      dim_element.viewportBottom = dim_element.viewportTop;
      dim_element.viewportRight = dim_element.viewportLeft;
    } else {
      dim_element = {
        viewportTop: 0,
        viewportLeft: 0,
        viewportBottom: dim_window.height,
        viewportRight: dim_window.width,
        viewportCenterLeft: dim_window.width / 2,
        viewportCenterTop: dim_window.height / 2,
        borderBoxWidth: dim_window.width,
        borderBoxHeight: dim_window.height
      };
    }
    vp_pl = {};
    ref2 = this.knownPlacements;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      placement = ref2[k];
      if (placement !== "n" && placement !== "s" && placement !== "e" && placement !== "w" && placement !== "c") {
        continue;
      }
      vp_pl[placement] = vp = {};
      vp.window_top = dim_layer.marginTop;
      vp.window_left = dim_layer.marginLeft;
      vp.window_right = dim_window.width - dim_layer.marginRight;
      vp.window_bottom = dim_window.height - dim_layer.marginBottom;
      vp.dim_window = dim_window;
      vp.dim_layer = dim_layer;
      vp.dim_element = dim_element;
      vp.dim_pointer = dim_pointer[placement];
      switch (placement) {
        case "c":
          vp.top = vp.window_top;
          vp.left = vp.window_left;
          vp.right = vp.window_right;
          vp.bottom = vp.window_bottom;
          vp.align_vertical = "center";
          vp.align_horizontal = "center";
          break;
        case "n":
          vp.top = dim_layer.marginTop;
          vp.left = dim_layer.marginLeft;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_element.viewportTop - vp.dim_pointer.borderBoxHeight - vp.dim_pointer.marginBottom;
          vp.align_vertical = "bottom";
          vp.align_horizontal = "center";
          break;
        case "s":
          vp.top = dim_element.viewportBottom + vp.dim_pointer.borderBoxHeight + vp.dim_pointer.marginTop;
          vp.left = dim_layer.marginLeft;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.align_vertical = "top";
          vp.align_horizontal = "center";
          break;
        case "e":
          vp.top = dim_layer.marginTop;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.left = dim_element.viewportRight + vp.dim_pointer.borderBoxWidth + vp.dim_pointer.marginLeft;
          vp.align_vertical = "center";
          vp.align_horizontal = "left";
          break;
        case "w":
          vp.top = dim_layer.marginTop;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.right = dim_element.viewportLeft - vp.dim_pointer.borderBoxWidth - vp.dim_pointer.marginRight;
          vp.left = dim_layer.marginLeft;
          vp.align_vertical = "center";
          vp.align_horizontal = "right";
      }
      vp.pointer_align_vertical = vp.align_vertical;
      vp.pointer_align_horizontal = vp.align_horizontal;
      vp.overlap_align = null;
    }
    ref3 = this.knownPlacements;
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      placement = ref3[l];
      if (placement === "n" || placement === "s" || placement === "e" || placement === "w" || placement === "c") {
        continue;
      }
      placement_parts = placement.split("");
      vp_pl[placement] = vp = copyObject(vp_pl[placement_parts[0]]);
      vp.dim_pointer = dim_pointer[placement_parts[0]];
      if (!vp) {
        continue;
      }
      switch (placement_parts[1]) {
        case "s":
          vp.top = dim_element.viewportTop;
          vp.align_vertical = "top";
          vp.pointer_align_vertical = "center";
          vp.overlap_align = "bottom";
          break;
        case "n":
          vp.bottom = dim_element.viewportBottom;
          vp.align_vertical = "bottom";
          vp.pointer_align_vertical = "center";
          vp.overlap_align = "top";
          break;
        case "e":
          vp.left = dim_element.viewportLeft;
          vp.align_horizontal = "left";
          vp.pointer_align_horizontal = "center";
          vp.overlap_align = "right";
          break;
        case "w":
          vp.right = dim_element.viewportRight;
          vp.align_horizontal = "right";
          vp.pointer_align_horizontal = "center";
          vp.overlap_align = "left";
      }
    }
    ref4 = this.knownPlacements;
    for (m = 0, len4 = ref4.length; m < len4; m++) {
      placement = ref4[m];
      if (indexOf.call(allowed_placements, placement) < 0) {
        delete vp_pl[placement];
        continue;
      }
      vp = vp_pl[placement];
      vp.width = vp.right - vp.left;
      vp.height = vp.bottom - vp.top;
      if (vp.width < 10 || vp.height < 10) {
        delete vp_pl[placement];
      }
    }
    for (placement in vp_pl) {
      vp = vp_pl[placement];
      layer_pos = vp.layer_pos = {};
      pointer_pos = vp.pointer_pos = {};
      vp.cuts = 0;
      switch (this._fill_space) {
        case "both":
          layer_pos.width = vp.width;
          layer_pos.height = vp.height;
          break;
        case "vertical":
          layer_pos.height = vp.height;
          layer_pos.width = dim_layer.borderBoxWidth;
          break;
        case "horizontal":
          layer_pos.width = vp.width;
          layer_pos.height = dim_layer.borderBoxHeight;
          break;
        default:
          layer_pos.width = dim_layer.borderBoxWidth;
          layer_pos.height = dim_layer.borderBoxHeight;
      }
      if (layer_pos.width > vp.width) {
        layer_pos.width = vp.width;
        vp.cuts++;
      }
      if (layer_pos.height > vp.height) {
        layer_pos.height = vp.height;
        vp.cuts++;
      }
      switch (vp.align_horizontal) {
        case "left":
          layer_pos.left = vp.left;
          break;
        case "right":
          layer_pos.left = vp.right - layer_pos.width;
          break;
        case "center":
          layer_pos.left = dim_element.viewportCenterLeft - layer_pos.width / 2;
      }
      switch (vp.align_vertical) {
        case "top":
          layer_pos.top = vp.top;
          break;
        case "bottom":
          layer_pos.top = vp.bottom - layer_pos.height;
          break;
        case "center":
          layer_pos.top = dim_element.viewportCenterTop - layer_pos.height / 2;
      }
      if (vp.dim_pointer) {
        switch (vp.pointer_align_horizontal) {
          case "left":
            pointer_pos.left = dim_element.viewportRight + vp.dim_pointer.marginLeft;
            break;
          case "right":
            pointer_pos.left = dim_element.viewportLeft - vp.dim_pointer.borderBoxWidth - vp.dim_pointer.marginLeft;
            break;
          case "center":
            pointer_pos.left = dim_element.viewportCenterLeft - vp.dim_pointer.borderBoxWidth / 2;
        }
        switch (vp.pointer_align_vertical) {
          case "top":
            pointer_pos.top = dim_element.viewportBottom + vp.dim_pointer.marginTop;
            break;
          case "bottom":
            pointer_pos.top = dim_element.viewportTop - vp.dim_pointer.marginBoxHeight + vp.dim_pointer.marginTop;
            break;
          case "center":
            pointer_pos.top = dim_element.viewportCenterTop - vp.dim_pointer.borderBoxHeight / 2;
        }
        pointer_pos.width = vp.dim_pointer.borderBoxWidth;
        pointer_pos.height = vp.dim_pointer.borderBoxHeight;
        pointer_pos.direction = vp.dim_pointer.direction;
      }
      if (layer_pos.top < vp.top) {
        layer_pos.top = vp.top;
        vp.cuts++;
      }
      if (layer_pos.left < vp.left) {
        layer_pos.left = vp.left;
        vp.cuts++;
      }
      overlap_bottom = layer_pos.top + layer_pos.height - vp.bottom;
      if (overlap_bottom > 0) {
        layer_pos.top = layer_pos.top - overlap_bottom;
      }
      overlap_right = layer_pos.left + layer_pos.width - vp.right;
      if (overlap_right > 0) {
        layer_pos.left = layer_pos.left - overlap_right;
      }
      vp.overlap_height = 0;
      vp.overlap_width = 0;
      if (this.__pointer || this._show_at_position) {
        overlap_height = dim_layer.borderBoxHeight - layer_pos.height;
        if (overlap_height > 0) {
          switch (vp.overlap_align) {
            case "bottom":
              vp.overlap_height = Math.min(layer_pos.top - vp.window_top, overlap_height);
              layer_pos.top = layer_pos.top - vp.overlap_height;
              layer_pos.height = layer_pos.height + vp.overlap_height;
              break;
            case "top":
              vp.overlap_height = Math.min(vp.window_bottom - layer_pos.top - layer_pos.height, overlap_height);
              layer_pos.height = layer_pos.height + vp.overlap_height;
          }
        }
        overlap_width = dim_layer.borderBoxWidth - layer_pos.width;
        if (overlap_width > 0) {
          switch (vp.overlap_align) {
            case "right":
              vp.overlap_width = Math.min(layer_pos.left - vp.window_left, overlap_width);
              layer_pos.left = layer_pos.left - vp.overlap_width;
              layer_pos.width = layer_pos.width + vp.overlap_width;
              break;
            case "left":
              vp.overlap_height = Math.min(vp.window_right - layer_pos.right, overlap_width);
              layer_pos.width = layer_pos.width + vp.overlap_width;
          }
        }
      }
      if (this.__pointer) {
        layer_pos_right = vp.layer_pos.left + vp.layer_pos.width;
        layer_pos_bottom = vp.layer_pos.top + vp.layer_pos.height;
        pointer_pos_right = vp.pointer_pos.left + vp.pointer_pos.width;
        pointer_pos_bottom = vp.pointer_pos.top + vp.pointer_pos.height;
        switch (vp.pointer_pos.direction) {
          case "n":
          case "s":
            marginLeft = vp.pointer_pos.left - vp.layer_pos.left;
            pushNeeded = marginLeft - vp.dim_pointer.marginLeft;
            if (pushNeeded < 0) {
              spaceAvailable = vp.layer_pos.left - vp.window_left;
              vp.push_left = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.left = vp.layer_pos.left - vp.push_left;
            }
            marginRight = layer_pos_right - pointer_pos_right;
            pushNeeded = marginRight - vp.dim_pointer.marginRight;
            if (pushNeeded < 0) {
              spaceAvailable = vp.window_right - layer_pos_right;
              vp.push_right = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.left = vp.layer_pos.left + vp.push_right;
            }
            break;
          case "e":
          case "w":
            marginTop = vp.pointer_pos.top - vp.layer_pos.top;
            pushNeeded = marginTop - vp.dim_pointer.marginTop;
            if (pushNeeded < 0) {
              spaceAvailable = vp.layer_pos.top - vp.window_top;
              vp.push_top = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.top = vp.layer_pos.top - vp.push_top;
            }
            marginBottom = layer_pos_bottom - pointer_pos_bottom;
            pushNeeded = marginBottom - vp.dim_pointer.marginBottom;
            if (pushNeeded < 0) {
              spaceAvailable = vp.window_bottom - layer_pos_bottom;
              vp.push_bottom = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.top = vp.layer_pos.top + vp.push_bottom;
            }
        }
      }
      if (this._onPosition) {
        if (typeof this._onPosition === "function") {
          this._onPosition(this, vp);
        }
      }
      vp.layer_pos.estate = vp.layer_pos.width * vp.layer_pos.height;
      vp.layer_pos.aspect_ratio = vp.layer_pos.width / vp.layer_pos.height;
      vp.dim_layer.aspect_ratio = vp.dim_layer.borderBoxWidth / vp.dim_layer.borderBoxHeight;
      wanted_rank = allowed_placements.length - idxInArray(placement, allowed_placements);
      if (wanted_placement === placement) {
        wanted_rank = allowed_placements.length + 1;
      }
      vp.ranking = wanted_rank * 10 + 1 - Math.abs(vp.layer_pos.aspect_ratio - vp.dim_layer.aspect_ratio) + vp.layer_pos.estate;
    }
    available_placements = [];
    for (placement in vp_pl) {
      vp = vp_pl[placement];
      available_placements.push(placement);
    }
    assert(available_placements.length > 0, "Layer.position", "No available placements found.", {
      vp_pl: vp_pl
    });
    available_placements.sort(function(pl1, pl2) {
      var value;
      value = function(pl) {
        return vp_pl[pl].ranking;
      };
      return compareIndex(value(pl1), value(pl2));
    });
    available_placements.reverse();
    placement = available_placements[0];
    if (ev != null ? ev.hasModifierKey() : void 0) {
      console.debug("layer", dim_layer);
      console.debug("element", dim_element);
      console.debug("pointer", dim_pointer);
      console.debug("window", dim_window);
      console.debug("placements", placement, vp_pl);
      show_dbg_div = (function(_this) {
        return function(placement) {
          var _vp, span, style1, style2, style3;
          _this.__removeDebugDivs();
          _vp = vp_pl[placement];
          console.info("Layer: Placement", placement, _vp);
          _this.__dbg_div1 = CUI.DOM.element("DIV");
          _this.__dbg_div2 = CUI.DOM.element("DIV");
          _this.__dbg_div3 = CUI.DOM.element("DIV");
          style1 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #ff0032",
            backgroundColor: "rgba(255, 0, 0, 0.4)",
            top: _vp.top,
            left: _vp.left,
            width: _vp.width,
            height: _vp.height
          };
          DOM.setStyle(_this.__dbg_div1, style1);
          style2 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #00ff32",
            backgroundColor: "rgba(0, 255, 0, 0.4)",
            top: _vp.layer_pos.top,
            left: _vp.layer_pos.left,
            width: _vp.layer_pos.width,
            height: _vp.layer_pos.height,
            alignItems: "center",
            justifyContent: "center",
            fontSize: 40,
            color: "rgb(0,255,50)"
          };
          span = CUI.DOM.element("SPAN");
          span.textContent = placement;
          _this.__dbg_div2.appendChild(span);
          DOM.setStyle(_this.__dbg_div2, style2);
          style3 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #0032ff",
            backgroundColor: "rgba(0, 0, 255, 0.4)",
            top: _vp.pointer_pos.top,
            left: _vp.pointer_pos.left,
            width: _vp.pointer_pos.width,
            height: _vp.pointer_pos.height
          };
          DOM.setStyle(_this.__dbg_div3, style3);
          _this.__layer_root.DOM.appendChild(_this.__dbg_div1);
          _this.__layer_root.DOM.appendChild(_this.__dbg_div2);
          if (_this.__pointer) {
            return _this.__layer_root.DOM.appendChild(_this.__dbg_div3);
          }
        };
      })(this);
      dbg_pl = 0;
      listener = Events.listen({
        node: document,
        type: "keyup",
        call: (function(_this) {
          return function(ev, info) {
            var _placement;
            if (ev.keyCode() !== 32) {
              return;
            }
            while (true) {
              dbg_pl = dbg_pl + 1;
              if (dbg_pl === _this.knownPlacements.length) {
                _this.__removeDebugDivs();
                listener.destroy();
                return;
              }
              _placement = _this.knownPlacements[dbg_pl];
              if (vp_pl[_placement]) {
                show_dbg_div(_placement);
                return;
              }
              console.warn("Placement", _placement, "is unavailable.");
            }
          };
        })(this)
      });
    }
    vp = vp_pl[placement];
    if (vp.layer_pos.width < 10 || vp.layer_pos.height < 10) {

    }
    if (this._element && this._use_element_width_as_min_width) {
      minWidth = dim_element.borderBoxWidth;
    } else {
      minWidth = void 0;
    }
    CUI.DOM.setAttribute(this.__layer_root.DOM, "cui-placement", placement);
    CUI.DOM.setAttribute(this.__layer_root.DOM, "cui-fill-space", this._fill_space);
    set_css = {
      top: vp.layer_pos.top + body_scroll_top,
      left: vp.layer_pos.left + body_scroll_left,
      minWidth: minWidth,
      margin: 0
    };
    if (!dim_layer.computedStyle.maxWidth || dim_layer.computedStyle.maxWidth === 'none') {
      set_css.maxWidth = vp.width + vp.overlap_width - (vp.layer_pos.left - vp.left);
    }
    if (!dim_layer.computedStyle.maxHeight || dim_layer.computedStyle.maxHeight === 'none') {
      set_css.maxHeight = vp.height + vp.overlap_height - (vp.layer_pos.top - vp.top);
    }
    if (placement === "c") {
      is_fixed = true;
    } else {
      is_fixed = ((ref5 = this.__layer_root.DOM.previousElementSibling) != null ? ref5.hasAttribute("cui-layer-fixed") : void 0) || false;
    }
    if (is_fixed) {
      this.__layer_root.DOM.setAttribute("cui-layer-fixed", "");
      set_css.top = vp.layer_pos.top;
      set_css.left = vp.layer_pos.left;
    } else {
      this.__layer_root.DOM.removeAttribute("cui-layer-fixed");
    }
    if (placement === "c" && !CUI.browser.ie) {

    }
    if (CUI.browser.ie) {
      set_css.width = Math.ceil(vp.layer_pos.width);
      set_css.height = Math.ceil(vp.layer_pos.height);
      sibl = this.__layer_root.DOM.previousElementSibling;
      this.__layer_root.DOM.remove();
    }
    CUI.DOM.setStyle(this.__layer.DOM, set_css);
    if (this.__pointer) {
      if (is_fixed) {
        CUI.DOM.setStyle(this.__pointer, {
          top: vp.pointer_pos.top,
          left: vp.pointer_pos.left,
          margin: 0
        });
      } else {
        CUI.DOM.setStyle(this.__pointer, {
          top: vp.pointer_pos.top + body_scroll_top,
          left: vp.pointer_pos.left + body_scroll_left,
          margin: 0
        });
      }
      CUI.DOM.addClass(this.__pointer, get_pointer_class(vp.pointer_pos.direction));
    }
    if (this.__backdrop_crop) {
      DOM.setStyle(this.__backdrop_crop, {
        top: vp.layer_pos.top,
        left: vp.layer_pos.left,
        width: vp.layer_pos.width,
        height: vp.layer_pos.height
      });
      DOM.setStyle(this.__backdrop_crop.firstChild, {
        width: dim_window.width,
        height: dim_window.height,
        top: -vp.layer_pos.top,
        left: -vp.layer_pos.left
      });
    }
    if (CUI.browser.ie) {
      CUI.DOM.insertAfter(sibl, this.__layer_root.DOM);
    }
    return this;
  };

  Layer.prototype.__removeDebugDivs = function() {
    var ref, ref1, ref2;
    if ((ref = this.__dbg_div1) != null) {
      ref.remove();
    }
    if ((ref1 = this.__dbg_div2) != null) {
      ref1.remove();
    }
    if ((ref2 = this.__dbg_div3) != null) {
      ref2.remove();
    }
    this.__dbg_div1 = null;
    this.__dbg_div2 = null;
    return this.__dbg_div3 = null;
  };

  Layer.prototype.clearTimeout = function() {
    if (this.__timeout) {
      CUI.clearTimeout(this.__timeout);
    }
    this.__timeout = null;
    return this;
  };

  Layer.prototype.showTimeout = function(ms, ev) {
    var dfr;
    if (ms == null) {
      ms = this._show_ms;
    }
    this.clearTimeout();
    dfr = new CUI.Deferred();
    this.__timeout = CUI.setTimeout({
      ms: ms,
      track: false,
      onReset: (function(_this) {
        return function() {
          return dfr.reject();
        };
      })(this),
      onDone: (function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this),
      call: (function(_this) {
        return function() {
          if (_this.__element && !CUI.DOM.isInDOM(_this.__element)) {
            _this.destroy();
            return;
          }
          return _this.show(null, ev);
        };
      })(this)
    });
    return dfr.promise();
  };

  Layer.prototype.hideTimeout = function(ms, ev) {
    var dfr;
    if (ms == null) {
      ms = this._hide_ms;
    }
    this.clearTimeout();
    dfr = new CUI.Deferred();
    this.__timeout = CUI.setTimeout({
      ms: ms,
      track: false,
      onReset: (function(_this) {
        return function() {
          return dfr.reject();
        };
      })(this),
      onDone: (function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this),
      call: (function(_this) {
        return function() {
          return _this.hide(ev);
        };
      })(this)
    });
    return dfr.promise();
  };

  Layer.prototype.hide = function(ev) {
    this.clearTimeout();
    if (this.isDestroyed()) {
      return;
    }
    if (!this.isShown()) {
      return this;
    }
    this.__removeDebugDivs();
    if (this.__element) {
      if (this.__check_for_element) {
        CUI.clearInterval(this.__check_for_element);
      }
      CUI.DOM.removeClass(this.__getOriginalElement(), this.getElementOpenClass());
    }
    this.__layer_root.DOM.detach();
    CUI.DOM.setAttributeMap(this.__layer_root.DOM[0], {
      "cui-layer-stack-number": null,
      "cui-layer-stack-count": null
    });
    this.__updateLayerStackCounter();
    this.__shown = false;
    if (this._handle_focus) {
      this.focusOnHide(ev);
    }
    Events.ignore({
      instance: this
    });
    if (typeof this._onHide === "function") {
      this._onHide(this, ev);
    }
    return this;
  };

  Layer.prototype.__updateLayerStackCounter = function() {
    var el, i, idx, layer_elements, len, total;
    layer_elements = CUI.DOM.matchSelector(document.documentElement, "body > .cui-tmpl-layer-root");
    total = layer_elements.length;
    for (idx = i = 0, len = layer_elements.length; i < len; idx = ++i) {
      el = layer_elements[idx];
      CUI.DOM.setAttributeMap(el, {
        "cui-layer-stack-number": idx,
        "cui-layer-stack-count": total
      });
    }
    return this;
  };

  Layer.prototype.getElementOpenClass = function() {
    return "cui-layer-open";
  };

  Layer.prototype.show = function(ev) {
    var i, len, ref, scroll_parent;
    assert(!this.isDestroyed(), this.__cls + ".show", "Unable to show, Layer #" + (this.getUniqueId()) + " is already destroyed", {
      layer: this
    });
    if (Tooltip.current && !(this instanceof Tooltip)) {
      Tooltip.current.hide();
    }
    this.clearTimeout();
    if (this.isShown()) {
      this.position();
      return this;
    }
    document.body.appendChild(this.__layer_root.DOM);
    if (this.__element) {
      CUI.DOM.addClass(this.__getOriginalElement(), this.getElementOpenClass());
      ref = CUI.DOM.parentsScrollable(this.__element);
      for (i = 0, len = ref.length; i < len; i++) {
        scroll_parent = ref[i];
        Events.listen({
          type: "scroll",
          instance: this,
          node: scroll_parent,
          call: (function(_this) {
            return function() {
              return _this.position();
            };
          })(this)
        });
      }
      if (this._check_for_element) {
        this.__check_for_element = CUI.setInterval((function(_this) {
          return function() {
            if (!CUI.DOM.isInDOM(_this.__element)) {
              return _this.destroy();
            }
          };
        })(this), 200);
      }
    }
    this.__updateLayerStackCounter();
    Events.listen({
      type: "content-resize",
      instance: this,
      node: this.__layer,
      call: (function(_this) {
        return function(ev) {
          return _this.position();
        };
      })(this)
    });
    Events.listen({
      type: "viewport-resize",
      instance: this,
      node: this.__layer,
      call: (function(_this) {
        return function(ev) {
          if (_this.__element && !CUI.DOM.isInDOM(_this.__element)) {
            return;
          }
          _this.position();
        };
      })(this)
    });
    if (typeof this._onBeforeShow === "function") {
      this._onBeforeShow(this, ev);
    }
    this.__shown = true;
    this.position(ev);
    if (this._handle_focus) {
      this.focusOnShow(ev);
    }
    if (typeof this._onShow === "function") {
      this._onShow(this, ev);
    }
    return this;
  };

  Layer.prototype.isKeyboardCancellable = function(ev) {
    var ref;
    if ((ref = this.__bd_policy) === "click" || ref === "click-thru") {
      return true;
    } else {
      return false;
    }
  };

  Layer.prototype.doCancel = function(ev) {
    return this.hide(ev);
  };

  Layer.prototype.focusOnShow = function(ev) {
    if (ev === CUI.KeyboardEvent) {
      this.__focused_on_show = true;
    } else if (this.__element && DOM.matchSelector(document.documentElement, ":focus").length > 0) {

    } else {
      this.__focused_on_show = false;
    }
    if (this.__focused_on_show) {
      this.DOM[0].focus();
    }
    return this;
  };

  Layer.prototype.focusOnHide = function(ev) {
    var ref;
    if (!this.__element) {
      return this;
    }
    if (ev === CUI.KeyboardEvent || this.__focused_on_show) {
      if ((ref = DOM.findElement(this.__element[0], "[tabindex]")) != null) {
        ref.focus();
      }
    }
    return this;
  };

  Layer.prototype.getElement = function() {
    return this.__element;
  };

  Layer.prototype.isShown = function() {
    return this.__shown;
  };

  Layer.prototype.destroy = function() {
    var ref, ref1, ref2, ref3;
    this.clearTimeout();
    if (this.__shown) {
      this.hide();
    }
    Layer.__super__.destroy.call(this);
    if ((ref = this.__layer) != null) {
      ref.destroy();
    }
    if ((ref1 = this.__layer_root) != null) {
      ref1.destroy();
    }
    this.__layer = null;
    this.__layer_root = null;
    if ((ref2 = this.__pointer) != null) {
      ref2.remove();
    }
    this.__pointer = null;
    if ((ref3 = this.__backdrop) != null) {
      ref3.destroy();
    }
    return this.__backdrop = null;
  };

  return Layer;

})(CUI.DOM);

CUI.ready(function() {
  Events.listen({
    type: ["mousedown", "touchend"],
    capture: true,
    node: document.body,
    call: function(ev, info) {
      var element, layer, layer_element, layer_elements, target;
      layer_elements = DOM.findElements(document.body, "body > .cui-tmpl-layer-root, body > .cui-pane-fill-screen-is-on, body > .cui-layer-prevent-click-thru");
      target = ev.getTarget();
      while (layer_element = layer_elements.pop()) {
        if (!CUI.DOM.hasClass(layer_element, "cui-layer-backdrop-policy-click-thru")) {
          return;
        }
        if (CUI.DOM.closest(target, layer_element)) {
          return;
        }
        layer = DOM.data(CUI.DOM.children(layer_element, ".cui-layer")[0], "element");
        element = layer.getElement();
        if (element && CUI.DOM.closest(ev.getTarget(), element)) {
          Events.listen({
            node: document.documentElement,
            type: ["dblclick", "click"],
            capture: true,
            only_once: true,
            call: (function(_this) {
              return function(ev) {
                console.error("eating click on layer opening element");
                return ev.stop();
              };
            })(this)
          });
        }
        ev.cui_layer_closed = true;
        layer.hide(ev);
      }
    }
  });
  return Events.listen({
    type: ["keyup"],
    node: document.body,
    call: function(ev) {
      var element, layer, layer_element, layer_elements;
      if (ev.keyCode() !== 27 || window.globalDrag) {
        return;
      }
      layer_elements = DOM.findElements(document.body, "body > .cui-tmpl-layer-root > .cui-layer");
      layer_element = layer_elements[layer_elements.length - 1];
      if (!layer_element) {
        return;
      }
      element = CUI.DOM.closest(ev.getTarget(), "[tabindex],select,input,textarea");
      if ((element === layer_element)) {
        return;
      }
      layer = DOM.data(layer_element, "element");
      ev.stopImmediatePropagation();
      ev.preventDefault();
      if (layer.isKeyboardCancellable(ev)) {
        layer.doCancel(ev);
        return false;
      }
    }
  });
});
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DataField,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

CUI.DataField = (function(superClass) {
  extend(DataField, superClass);

  DataField.changed_marker_css_class = "cui-data-field-changed-marker";

  function DataField(opts) {
    var tt_opts;
    this.opts = opts != null ? opts : {};
    DataField.__super__.constructor.call(this, this.opts);
    assertImplements(this, ["render"]);
    if (this._name) {
      assertImplements(this, ["getDefaultValue"]);
    }
    this.__checkChangedValue = void 0;
    this.initTemplate();
    this.addClass("cui-data-field");
    Events.listen({
      type: "data-changed",
      node: this.DOM,
      call: (function(_this) {
        return function(ev, info) {
          if (!(info != null ? info.element : void 0)) {
            CUI.warn((getObjectClass(_this)) + "[DataField].listen[data-changed]: received event with element not set.", ev, info, _this);
            return;
          }
          if (typeof _this._onDataChanged === "function") {
            _this._onDataChanged(info.element.getData(), info.element, ev, info);
          }
        };
      })(this)
    });
    if (this.getName()) {
      this.DOM.attr("cui-data-field-name", this.getName());
    }
    this.init();
    if (this._data && !CUI.isFunction(this._data)) {
      this.setData(this._data);
    }
    this.__initDisabled();
    if (this._hidden) {
      this.hide();
    }
    if (this._tooltip && (this._tooltip.text || this._tooltip.content)) {
      tt_opts = copyObject(this._tooltip);
      tt_opts.element = this.DOM;
      this.__tooltip = new Tooltip(tt_opts);
    }
    this.__opacity = 1;
    if (typeof this._onInit === "function") {
      this._onInit(this);
    }
  }

  DataField.prototype.initOpts = function() {
    DataField.__super__.initOpts.call(this);
    return this.addOpts({
      name: this.getNameOpt(),
      data: {
        check: function(v) {
          return CUI.isFunction(v != null ? v.hasOwnProperty : void 0) || CUI.isFunction(v);
        }
      },
      data_not_for_others: {
        "default": false,
        check: Boolean
      },
      disabled: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      disabled_depends_on_data: {
        check: Function
      },
      tooltip: {
        check: "PlainObject"
      },
      hidden: {
        check: Boolean
      },
      form: {},
      undo_support: {
        "default": true,
        check: Boolean
      },
      undo_and_changed_support: {
        check: Boolean
      },
      mark_changed: {
        "default": true,
        check: Boolean
      },
      check_changed: {
        "default": true,
        check: Boolean
      },
      onDataChanged: {
        check: Function
      },
      onDataInit: {
        check: Function
      },
      onInit: {
        check: Function
      },
      onRender: {
        check: Function
      }
    });
  };

  DataField.prototype.readOpts = function() {
    var i, k, len, ref;
    if (this.opts.hasOwnProperty("undo_and_changed_support")) {
      ref = ["undo_support", "check_changed", "mark_changed"];
      for (i = 0, len = ref.length; i < len; i++) {
        k = ref[i];
        if (!this.opts.hasOwnProperty(k)) {
          this.opts[k] = this.opts.undo_and_changed_support;
        }
      }
    }
    return DataField.__super__.readOpts.call(this);
  };

  DataField.prototype.getUniqueIdForLabel = function() {
    return null;
  };

  DataField.prototype.initTemplate = function() {
    return this.registerTemplate(this.getTemplate());
  };

  DataField.prototype.getTemplate = function() {
    return new Template({
      name: "data-field"
    });
  };

  DataField.prototype.isResizable = function() {
    return false;
  };

  DataField.prototype.init = function() {};

  DataField.prototype.debug = function() {
    CUI.debug("----" + this + "----", this);
    if (this.__data) {
      CUI.debug("data:", this.getData());
      CUI.debug("value:", this.getValue());
      CUI.debug("init-value:", this.getInitValue());
      return CUI.debug("check-changed-value:", this.getCheckChangedValue());
    }
  };

  DataField.prototype.toString = function() {
    return "[" + this.__cls + "[" + this.__uniqueId + ", " + (this._name || '<no name>') + "]}";
  };

  DataField.prototype.reload = function() {
    this.remove();
    this.render();
    this.displayValue();
    if (typeof this._onRender === "function") {
      this._onRender(this);
    }
    return this;
  };

  DataField.prototype.remove = function() {
    this.callOnOthers("remove");
    if (!this.isDestroyed()) {
      this.empty();
    }
    return this.__isRendered = false;
  };

  DataField.prototype.getNameOpt = function() {
    return {
      check: String
    };
  };

  DataField.prototype.registerLabel = function(lbl) {
    return lbl.setAttribute('for', this.getUniqueIdForLabel());
  };

  DataField.prototype.getLabel = function() {
    return this._label;
  };

  DataField.prototype.setForm = function(form) {
    assertImplements(form, ["getFieldsByName", "getFieldByIdx", "getData", "getFields"]);
    this.__form = form;
    if (!this.getForm().getFormPath) {
      return this;
    }
    this.setFormDepth();
    return this;
  };

  DataField.prototype.setFormDepth = function() {
    var path;
    path = this.getFormPath();
    CUI.DOM.setAttribute(this.DOM, "cui-form-depth", path.length);
    this.callOnOthers("setFormDepth");
    return this;
  };

  DataField.prototype.getFormPath = function(include_self, path, call) {
    var ref;
    if (include_self == null) {
      include_self = false;
    }
    if (path == null) {
      path = [];
    }
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "CUI.DataField.getPath", "Recursion detected.");
    if ((ref = this.getForm()) != null ? ref.getFormPath : void 0) {
      this.getForm().getFormPath(true, path, call + 1);
    }
    if (include_self) {
      path.push(this);
    }
    return path;
  };

  DataField.prototype.getForm = function() {
    return this.__form;
  };

  DataField.prototype.getOtherField = function(name) {
    var ref, ref1;
    return (ref = this.__form) != null ? (ref1 = ref.getFieldsByName(name)) != null ? ref1[0] : void 0 : void 0;
  };

  DataField.prototype.getRootForm = function() {
    if (this.__form) {
      return this.__form.getRootForm();
    } else if (this instanceof Form) {
      return this;
    } else {
      return null;
    }
  };

  DataField.prototype.__initDisabled = function() {
    if (this._disabled && (this._disabled === true || this._disabled.call(this, this))) {
      this.disable();
    }
  };

  DataField.prototype.enable = function() {
    this.removeClass("cui-data-field-disabled");
    this.callOnOthers("enable");
    return this;
  };

  DataField.prototype.disable = function() {
    this.addClass("cui-data-field-disabled");
    this.callOnOthers("disable");
    return this;
  };

  DataField.prototype.isDisabled = function() {
    return this.hasClass("cui-data-field-disabled");
  };

  DataField.prototype.isHidden = function() {
    return this.hasClass("cui-data-field-hidden");
  };

  DataField.prototype.isShown = function() {
    return !this.isHidden();
  };

  DataField.prototype.updateData = function(data) {
    if (CUI.isFunction(this._data)) {
      this.__data = this._data.call(this, data, this);
    } else {
      this.__data = data;
    }
    return this.displayValue();
  };

  DataField.prototype.setData = function(data, init_data) {
    var ref;
    if (init_data == null) {
      init_data = true;
    }
    if (this.__data && this._data && !CUI.isFunction(this._data)) {
      return;
    }
    assert(!this.__data, this + ".setData", "data is already set.", {
      opts: this.opts,
      data: this.__data
    });
    if (CUI.isFunction(this._data)) {
      this.__data = this._data.call(this, data, this);
    } else {
      this.__data = data;
    }
    assert(CUI.isPlainObject(this.__data) || ((ref = this.__data) != null ? typeof ref.hasOwnProperty === "function" ? ref.hasOwnProperty(this.getName()) : void 0 : void 0), this + ".setData", "data needs to be PlainObject or have a property \"" + (this.getName()) + "\".", {
      data: data,
      opts: this.opts
    });
    if (this.setDataOnOthers()) {
      this.callOnOthers("setData", this.__data, init_data);
    }
    if (init_data) {
      this.initData();
    }
    return this;
  };

  DataField.prototype.setDataOnOthers = function() {
    return !this._data_not_for_others;
  };

  DataField.prototype.hide = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.addClass("cui-data-field-hidden");
    this.callOnOthers("hide");
    if (trigger_event) {
      Events.trigger({
        type: "form-check-row-visibility",
        node: this.DOM,
        info: {
          element: this
        }
      });
    }
    return this;
  };

  DataField.prototype.show = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.removeClass("cui-data-field-hidden");
    this.callOnOthers("show");
    if (trigger_event) {
      Events.trigger({
        type: "form-check-row-visibility",
        node: this.DOM,
        info: {
          element: this
        }
      });
    }
    return this;
  };

  DataField.prototype.isRendered = function() {
    return this.__isRendered;
  };

  DataField.prototype.render = function() {
    assert(!this.__isRendered, this.__cls + ".render", "Cannot be called when already rendered.", {
      opts: this.opts,
      dataField: this
    });
    this.__isRendered = true;
    if (this.isDisabled()) {
      this.disable();
    }
    if (this.isHidden()) {
      this.hide(true);
    }
    this.callOnOthers("render");
    return this;
  };

  DataField.prototype.displayValue = function() {
    assert(!this.isDestroyed(), this.__cls + ".displayValue", "DataField already destroyed, cannot display value.", {
      data_field: this
    });
    assert(this.__isRendered, this.__cls + ".displayValue", "not rendered yet, cannot display.", {
      opts: this.opts,
      data: this.__data
    });
    this.checkChanged();
    return this.callOnOthers("displayValue");
  };

  DataField.prototype.start = function() {
    assert(!this.__isRendered, this.__cls + ".start", "Cannot be called when already rendered.", {
      opts: this.opts,
      dataField: this
    });
    this.__initDisabled();
    this.render();
    this.displayValue();
    if (typeof this._onRender === "function") {
      this._onRender(this);
    }
    return this;
  };

  DataField.prototype.getAllDataFields = function(all) {
    if (all == null) {
      all = false;
    }
    return this.getDataFields(true);
  };

  DataField.prototype.getDataFields = function(all, data_fields) {
    if (all == null) {
      all = false;
    }
    if (data_fields == null) {
      data_fields = [];
    }
    if (this.isDataField() || all) {
      data_fields.push(this);
    }
    this.callOnOthers("getDataFields", all, data_fields);
    return data_fields;
  };

  DataField.prototype.isDataField = function() {
    return this.hasData();
  };

  DataField.prototype.callOnOthers = function() {
    var args, df, func, i, len, other_fields;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (this.getFields) {
      other_fields = this.getFields(func).slice(0);
    } else {
      other_fields = [];
    }
    for (i = 0, len = other_fields.length; i < len; i++) {
      df = other_fields[i];
      if (!df || !CUI.isFunction(df[func])) {
        assert(false, "CUI.DataField.callOnOthers", "Field found in other fields has no Function \"" + func + "\".", {
          field: df,
          other_fields: other_fields
        });
        return this;
      }
      df[func].apply(df, args);
    }
    return this;
  };

  DataField.prototype.getData = function() {
    return this.__data;
  };

  DataField.prototype.hasData = function() {
    if (!isEmpty(this._name) && this.__data) {
      return true;
    } else {
      return false;
    }
  };

  DataField.prototype.getArrayFromOpt = function(opt, event, allowDeferred) {
    var arr, v;
    if (allowDeferred == null) {
      allowDeferred = false;
    }
    v = this["_" + opt];
    if (CUI.isFunction(v)) {
      arr = v.call(this, this, event);
      assert(CUI.isArray(arr) || (isPromise(arr) && allowDeferred), this.__cls + ".getArrayFromOpt", "opts." + opt + "(dataField) did not return Array or Promise.", {
        options: arr,
        opts: this.opts
      });
    } else {
      arr = v;
    }
    return arr;
  };

  DataField.prototype.getName = function() {
    return this._name;
  };

  DataField.prototype.getDefaultValue = function() {};

  DataField.prototype.getValue = function() {
    return this.__data[this._name];
  };

  DataField.prototype.checkValue = function() {
    throw new Error(this.__cls + ".checkValue is unimplemtented.");
    return this;
  };

  DataField.prototype.setValue = function(v, flags) {
    var e, error, ref;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      if (this.isRendered()) {
        this.displayValue();
      }
      return this;
    }
    if (v === this.getValue()) {
      return this;
    }
    try {
      this.checkValue(v, flags);
    } catch (error) {
      e = error;
      if (!(e instanceof CheckValueError)) {
        throw e;
      }
      throw new Error((this.__cls + ".setValue: ") + v + ", Error: " + e);
    }
    if ((ref = flags.no_trigger) !== false && ref !== true) {
      flags.no_trigger = true;
    }
    this.storeValue(v, flags);
    if (this.isRendered()) {
      this.displayValue();
    }
    return this;
  };

  DataField.prototype.getInitValue = function() {
    var undo;
    undo = this.getUndo();
    if (!undo) {
      return void 0;
    }
    return undo.values[0];
  };

  DataField.prototype.getLastValue = function() {
    var undo;
    undo = this.getUndo();
    if (!undo) {
      return void 0;
    }
    return undo.values[undo.idx - 1];
  };

  DataField.prototype.reset = function() {
    var undo;
    if (undo = this.getUndo()) {
      this.__data[this._name] = undo.values[0];
      undo.values.splice(1);
      undo.idx = 0;
      this.displayValue();
      this.triggerDataChanged({
        action: "reset",
        undo_idx: 0
      });
    }
    return this;
  };

  DataField.prototype.undo = function() {
    var undo;
    if (undo = this.getUndo()) {
      if (undo.idx === 0) {
        return false;
      }
      this.__data[this._name] = undo.values[--undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "undo",
        undo_idx: undo.idx
      });
      return true;
    }
    return null;
    return this;
  };

  DataField.prototype.redo = function() {
    var undo;
    if (undo = this.getUndo()) {
      if (undo.idx === undo.values.length - 1) {
        return false;
      }
      this.__data[this._name] = undo.values[++undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "redo",
        undo_idx: undo.idx
      });
      return true;
    }
    return null;
    return this;
  };

  DataField.prototype.goto = function(idx) {
    var undo;
    if (undo = this.getUndo()) {
      if (isUndef(undo.values[idx])) {
        return false;
      }
      undo.idx = idx;
      this.__data[this._name] = undo.values[undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "goto",
        undo_idx: idx
      });
      return true;
    }
    return null;
  };

  DataField.prototype.initData = function() {
    var undo;
    if (typeof this._onDataInit === "function") {
      this._onDataInit(this, this.__data);
    }
    if (!this.hasData()) {
      return;
    }
    this.initValue();
    undo = this.getUndo();
    if (CUI.isPlainObject(undo) && CUI.isEmptyObject(undo)) {
      undo.values = [this.getValue()];
      undo.idx = 0;
    }
    if (isUndef(this.getCheckChangedValue())) {
      this.setCheckChangedValue(undo ? this.getInitValue() : this.getValue());
    }
    if (this.setDataOnOthers()) {
      this.callOnOthers("initData");
    }
    return this;
  };

  DataField.prototype.initValue = function() {
    if (isUndef(this.__data[this._name])) {
      this.__data[this._name] = this.getDefaultValue();
    }
    return this;
  };

  DataField.prototype.setCheckChangedValue = function(value) {
    assert(this.hasData(), this.__cls + ".setCheckChangedValue", "Cannot set without data.", {
      opts: this.opts,
      value: value,
      dataField: this
    });
    if (this._check_changed === false) {
      return void 0;
    }
    return this.__checkChangedValue = JSON.stringify(value);
  };

  DataField.prototype.getCheckChangedValue = function() {
    if (this._check_changed === false) {
      return void 0;
    }
    assert(this.hasData(), this.__cls + ".getCheckChangedValue", "No data set.", {
      opts: this.opts
    });
    return this.__checkChangedValue;
  };

  DataField.prototype.getUndo = function() {
    var undo;
    if (!this.hasData() || this._undo_support === false) {
      return false;
    }
    if (isUndef(this.__data._undo)) {
      this.__data._undo = {};
    }
    if (isUndef(undo = this.__data._undo[this._name])) {
      undo = this.__data._undo[this._name] = {};
    }
    return undo;
  };

  DataField.prototype.storeValue = function(value, flags) {
    var store_last, undo;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      return false;
    }
    store_last = flags.initial_activate !== true && flags.no_store !== true;
    if (store_last && (undo = this.getUndo())) {
      undo.values[++undo.idx] = value;
      undo.values.splice(undo.idx + 1);
    }
    this.__data[this._name] = value;
    this.checkChanged();
    if (store_last && !flags.no_trigger) {
      this.triggerDataChanged({
        action: "store",
        undo_idx: undo != null ? undo.idx : void 0
      });
    }
    return this;
  };

  DataField.prototype.triggerDataChanged = function(info) {
    if (info == null) {
      info = {};
    }
    info.element = this;
    return Events.trigger({
      type: "data-changed",
      node: this.DOM,
      info: info
    });
  };

  DataField.prototype.isChanged = function() {
    if (!this.hasData() || this._check_changed === false) {
      return void 0;
    }
    return this.getCheckChangedValue() !== JSON.stringify(this.getValue());
  };

  DataField.prototype.checkChanged = function() {
    if (this._check_changed === false) {
      return;
    }
    if (this.isChanged()) {
      this.addClass("changed");
    } else {
      this.removeClass("changed");
    }
    return this;
  };

  DataField.prototype.getChangedMarker = function() {
    if (this._mark_changed === false || this._check_changed === false) {
      return;
    }
    this.checkChanged();
    return $div(CUI.DataField.changed_marker_css_class);
  };

  DataField.prototype.destroy = function() {
    var ref;
    this.remove(true);
    if ((ref = this.__tooltip) != null) {
      ref.destroy();
    }
    return DataField.__super__.destroy.call(this);
  };

  DataField["new"] = function(field, delete_keys, default_data) {
    var _field, field_opts, k, type, v;
    if (delete_keys == null) {
      delete_keys = [];
    }
    if (default_data == null) {
      default_data = {};
    }
    if (field instanceof DataField) {
      return field;
    }
    assert(CUI.isPlainObject(field), "CUI.DataField.new", "field needs to be PlainObject.", {
      field: field,
      delete_keys: delete_keys,
      default_data: default_data
    });
    field_opts = {};
    for (k in field) {
      v = field[k];
      if (k === "type") {
        type = v;
        continue;
      }
      if (delete_keys.indexOf(k) > -1) {
        continue;
      }
      field_opts[k] = v;
    }
    for (k in default_data) {
      v = default_data[k];
      if (field_opts.hasOwnProperty(k)) {
        continue;
      }
      field_opts[k] = v;
    }
    assert(CUI.isFunction(type), "CUI.DataField.new", "type is unknown: \"" + type + "\".", {
      field: field
    });
    _field = new type(field_opts);
    assert(_field instanceof CUI.DataField, "CUI.DataField.new", "field.type needs to be of class DataField, but is " + (getObjectClass(_field)) + ".", {
      field: field
    });
    return _field;
  };

  return DataField;

})(CUI.DOM);

DataField = CUI.DataField;

CUI.Events.registerEvent({
  type: "data-changed",
  bubble: true
});
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var CheckValueError,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CheckValueError = (function(superClass) {
  extend(CheckValueError, superClass);

  function CheckValueError() {
    return CheckValueError.__super__.constructor.apply(this, arguments);
  }

  return CheckValueError;

})(Error);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DataFieldInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DataFieldInput = (function(superClass) {
  extend(DataFieldInput, superClass);

  function DataFieldInput(opts) {
    this.opts = opts != null ? opts : {};
    DataFieldInput.__super__.constructor.call(this, this.opts);
    DOM.setAttributeMap(this.DOM[0], this._attr);
    this.addClass("cui-data-field-input");
  }

  DataFieldInput.prototype.initOpts = function() {
    DataFieldInput.__super__.initOpts.call(this);
    return this.addOpts({
      group: {
        check: String
      },
      attr: {
        "default": {},
        check: "PlainObject"
      }
    });
  };

  DataFieldInput.prototype.getGroup = function() {
    return this._group;
  };

  DataFieldInput.prototype.isResizable = function() {
    return true;
  };

  return DataFieldInput;

})(CUI.DataField);

DataFieldInput = CUI.DataFieldInput;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Button,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Button = (function(superClass) {
  extend(Button, superClass);

  Button.defaults = {
    confirm_ok: "Ok",
    confirm_icon: "question",
    confirm_cancel: "Cancel",
    confirm_title: "Confirmation",
    disabled_css_class: "cui-disabled",
    active_css_class: "cui-active"
  };

  function Button(opts) {
    var icon_left, itemList_opts, k, menu_start_hide, menu_stop_hide, ref, ref1, ref2, ref3, ref4, ref5, ref6, tname, v;
    this.opts = opts != null ? opts : {};
    Button.__super__.constructor.call(this, this.opts);
    if (this._tooltip) {
      if (this._tooltip.text || this._tooltip.content) {
        this.__tooltipOpts = this._tooltip;
      }
    }
    this.__has_left = true;
    this.__has_right = true;
    this.__has_center = true;
    tname = this.getTemplateName();
    this.__box = new Template({
      name: tname,
      map: {
        left: this.__has_left ? ".cui-button-left" : void 0,
        center: this.__has_center ? ".cui-button-center" : void 0,
        visual: CUI.__ng__ ? ".cui-button-visual" : void 0,
        right: this.__has_right ? ".cui-button-right" : void 0
      }
    });
    this.registerTemplate(this.__box);
    this.__active = null;
    this.__disabled = false;
    this.__hidden = false;
    this.__txt = null;
    if (CUI.__ng__) {
      this.addClass("cui-button-button");
    }
    if (isString((ref = this.__tooltipOpts) != null ? ref.text : void 0)) {
      this.setAria("label", (ref1 = this.__tooltipOpts) != null ? ref1.text : void 0);
      this.__hasAriaLabel = true;
    } else {
      this.__hasAriaLabel = false;
    }
    DOM.setAttribute(this.DOM, "tabindex", this._tabindex);
    if (!((ref2 = this._attr) != null ? ref2.role : void 0)) {
      DOM.setAttribute(this.DOM, "role", this._role);
    }
    if (!this._left || this._left === true) {
      if (this._icon) {
        assert(isUndef(this._icon_left), "new " + this.__cls, "opts.icon conflicts with opts.icon_left", {
          opts: this.opts
        });
        icon_left = this._icon;
      } else {
        icon_left = this._icon_left;
      }
      if (icon_left) {
        assert(!this._icon_active && !this._icon_inactive, "new Button", "opts.icon_active or opts.icon_inactive cannot be set together with opts.icon or opts.icon_left", {
          opts: this.opts
        });
        this.setIcon(icon_left);
      }
    } else {
      this.append(this._left, "left");
    }
    if (!this._right) {
      if (this._icon_right) {
        this.setIconRight(this._icon_right);
      } else if (this._menu && this._icon_right !== false) {
        this.addClass("cui-button--has-caret");
        if (this._menu_parent) {
          this.setIconRight("fa-angle-right");
        } else {
          this.setIconRight("fa-angle-down");
        }
      }
    } else if (this._right !== true) {
      this.append(this._right, "right");
    }
    if (!CUI.__ng__ && !this._size) {
      this._size = 'normal';
    }
    this.setSize(this._size);
    if (this._appearance) {
      this.addClass("cui-button-appearance-" + this._appearance);
    } else if (!CUI.__ng__) {
      this.addClass("cui-button-appearance-auto cui-button-appearance-normal");
    }
    if (this._primary) {
      this.addClass("cui-button--primary");
    }
    if (this._center) {
      this.append(this._center, "center");
    } else if (this._text) {
      this.setText(this._text);
    }
    if (this._disabled && (this._disabled === true || this._disabled.call(this, this))) {
      this.disable();
    }
    if (this._hidden && (this._hidden === true || this._hidden.call(this, this))) {
      this.hide();
    }
    if (this._active === true) {
      this.activate({
        initial_activate: true
      });
    } else if (this._active === false || this._switch) {
      this.deactivate({
        initial_activate: true
      });
    } else {
      this.__setState();
    }
    this.__radio_allow_null = this._radio_allow_null;
    if (this._radio) {
      assert(isUndef(this._switch), "new Button", "opts.switch conflicts with opts.radio.", {
        opts: this.opts
      });
      if (this._radio === true) {
        this.__radio = "radio--" + this.getUniqueId();
      } else {
        this.__radio = this._radio;
      }
    } else if (!isNull(this._switch)) {
      this.__radio = "switch--" + this.getUniqueId();
      this.__radio_allow_null = true;
    }
    if (this.__radio) {
      assert(!((ref3 = this._attr) != null ? ref3.radio : void 0), "new Button", "opts.radio conflicts with opts.attr.radio", {
        opts: this.opts
      });
      DOM.setAttribute(this.DOM, "radio", this.__radio);
    }
    this.setGroup(this._group);
    if (this._menu) {
      this.__menu_opts = {};
      itemList_opts = {};
      ref4 = this._menu;
      for (k in ref4) {
        v = ref4[k];
        switch (k) {
          case "onShow":
          case "onHide":
            continue;
          case "class":
          case "backdrop":
          case "onPosition":
          case "placement":
          case "placements":
          case "pointer":
            this.__menu_opts[k] = v;
            break;
          default:
            itemList_opts[k] = v;
        }
      }
      if (!isEmpty(this._class)) {
        if (this.__menu_opts["class"]) {
          this.__menu_opts["class"] += " " + this._class;
        } else {
          this.__menu_opts["class"] = this._class;
        }
      }
      if (this._menu.itemList) {
        this.__menu_opts.itemList = this._menu.itemList;
      } else {
        this.__menu_opts.itemList = itemList_opts;
      }
      this.__menu_opts.element = this;
      if (!this.__menu_opts.hasOwnProperty("use_element_width_as_min_width")) {
        if (!this._menu_parent) {
          this.__menu_opts.use_element_width_as_min_width = true;
        }
      }
      this.__menu_opts.onHide = (function(_this) {
        return function() {
          var base;
          return typeof (base = _this._menu).onHide === "function" ? base.onHide() : void 0;
        };
      })(this);
      this.__menu_opts.onShow = (function(_this) {
        return function() {
          var base;
          return typeof (base = _this._menu).onShow === "function" ? base.onShow() : void 0;
        };
      })(this);
      if (!this.__menu_opts.hasOwnProperty("backdrop")) {
        this.__menu_opts.backdrop = {
          policy: "click-thru"
        };
      }
      if (!this.__menu_opts.backdrop.hasOwnProperty("blur") && ((ref5 = this._menu_parent) != null ? (ref6 = ref5.getOpt("backdrop")) != null ? ref6.blur : void 0 : void 0)) {
        if (this._menu_on_hover) {
          this.__menu_opts.backdrop = {
            policy: "click-thru",
            blur: true
          };
        } else {
          this.__menu_opts.backdrop.blur = true;
        }
      }
      if (this._menu_parent) {
        this.__menu_opts.parent_menu = this._menu_parent;
      }
    }
    Events.listen({
      type: "keydown",
      node: this.DOM,
      capture: true,
      call: (function(_this) {
        return function(ev) {
          var el, left, ref7, right;
          if (ev.hasModifierKey()) {
            return;
          }
          if ((ref7 = ev.keyCode()) === 13 || ref7 === 32) {
            _this.onClickAction(ev);
            ev.stop();
            return;
          }
          if (ev.keyCode() === 27) {
            _this.DOM.blur();
            ev.stop();
            return;
          }
          el = null;
          right = function() {
            return el = DOM.findNextVisibleElement(_this.DOM, "[tabindex]");
          };
          left = function() {
            return el = DOM.findPreviousVisibleElement(_this.DOM, "[tabindex]");
          };
          switch (ev.keyCode()) {
            case 39:
              right();
              break;
            case 40:
              right();
              break;
            case 37:
              left();
              break;
            case 38:
              left();
          }
          if (el) {
            el.focus();
            ev.stop();
          }
        };
      })(this)
    });
    Events.listen({
      type: Button.clickTypesPrevent[this._click_type],
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          ev.preventDefault();
          return ev.stopPropagation();
        };
      })(this)
    });
    Events.listen({
      type: Button.clickTypes[this._click_type],
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          if (window.globalDrag) {
            return;
          }
          if (ev.getButton() !== 0 && !ev.getType().startsWith("touch")) {
            return;
          }
          ev.stopPropagation();
          _this.onClickAction(ev);
        };
      })(this)
    });
    if (this._menu_on_hover) {
      CUI.Button.menu_timeout = null;
      menu_stop_hide = (function(_this) {
        return function() {
          if (!CUI.Button.menu_timeout) {
            return;
          }
          CUI.clearTimeout(CUI.Button.menu_timeout);
          return CUI.Button.menu_timeout = null;
        };
      })(this);
      menu_start_hide = (function(_this) {
        return function(ev, ms) {
          if (ms == null) {
            ms = 700;
          }
          menu_stop_hide();
          return CUI.Button.menu_timeout = CUI.setTimeout({
            ms: ms,
            call: function() {
              return _this.getMenu().hide(ev);
            }
          });
        };
      })(this);
    }
    if (this._menu_on_hover || this.__tooltipOpts) {
      Events.listen({
        type: "mouseenter",
        node: this.DOM,
        call: (function(_this) {
          return function(ev) {
            var menu, menu_shown;
            if (window.globalDrag) {
              return;
            }
            if (_this.__tooltipOpts) {
              _this.__initTooltip();
              _this.getTooltip().showTimeout(null, ev);
            }
            if (_this._menu_on_hover) {
              menu = _this.getMenu();
              menu_stop_hide();
              if (!_this.__disabled && menu.hasItems(ev)) {
                menu_shown = CUI.DOM.data(CUI.DOM.find(".cui-button--hover-menu")[0], "element");
                if (menu_shown && menu_shown !== menu) {
                  menu_shown.hide(ev);
                }
                CUI.DOM.addClass(menu.DOM, "cui-button--hover-menu");
                Events.ignore({
                  instance: _this,
                  node: menu
                });
                Events.listen({
                  type: "mouseenter",
                  node: menu,
                  instance: _this,
                  only_once: true,
                  call: function() {
                    return menu_stop_hide();
                  }
                });
                Events.listen({
                  type: "mouseleave",
                  node: menu,
                  instance: _this,
                  only_once: true,
                  call: function() {
                    return menu_start_hide(ev);
                  }
                });
                menu.show(ev);
              }
            }
          };
        })(this)
      });
    }
    Events.listen({
      type: "mouseleave",
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          var ref7;
          if (window.globalDrag) {
            return;
          }
          if ((ref7 = _this.getTooltip()) != null) {
            ref7.hideTimeout(ev);
          }
          if (_this._menu_on_hover) {
            menu_start_hide(ev, 100);
          }
        };
      })(this)
    });
  }

  Button.prototype.setSize = function(size) {
    var cls, i, j, len, len1, ref, remove;
    remove = [];
    ref = this.DOM.classList;
    for (i = 0, len = ref.length; i < len; i++) {
      cls = ref[i];
      if (cls.startsWith("cui-button-size")) {
        remove.push(cls);
      }
    }
    for (j = 0, len1 = remove.length; j < len1; j++) {
      cls = remove[j];
      this.DOM.classList.remove(cls);
    }
    if (size) {
      this.DOM.classList.add("cui-button-size-" + size);
    }
    return this;
  };

  Button.prototype.onClickAction = function(ev) {
    var ref;
    if (this.__disabled) {
      ev.preventDefault();
      return;
    }
    if ((ref = this.getTooltip()) != null) {
      ref.hide(ev);
    }
    if (this.__radio) {
      if (this.__radio_allow_null) {
        this.toggle({}, ev);
      } else {
        this.activate({}, ev);
      }
    }
    if (this.hasMenu() && !this._menu_on_hover && this.getMenu().hasItems(ev)) {
      this.getMenu().show(ev);
      ev.preventDefault();
      return;
    }
    if (ev.isImmediatePropagationStopped()) {
      return;
    }
    Events.trigger({
      type: "cui-button-click",
      node: this,
      info: {
        event: ev
      }
    });
    if (ev.isImmediatePropagationStopped() || !this._onClick) {
      return;
    }
    return this._onClick.call(this, ev, this);
  };

  Button.prototype.initOpts = function() {
    Button.__super__.initOpts.call(this);
    return this.addOpts({
      tabindex: {
        "default": 0,
        check: function(v) {
          return isInteger(v) || v === false;
        }
      },
      size: {
        check: ["mini", "normal", "big", "bigger"]
      },
      appearance: {
        check: ["link", "flat", "normal", "important"]
      },
      primary: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      onClick: {
        check: Function
      },
      click_type: {
        "default": "click",
        mandatory: true,
        check: function(v) {
          return !!Button.clickTypes[v];
        }
      },
      text: {
        check: String
      },
      tooltip: {
        check: "PlainObject"
      },
      disabled: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      active_css_class: {
        "default": CUI.defaults["class"].Button.defaults.active_css_class,
        check: String
      },
      left: {
        check: function(v) {
          if (v === true) {
            return true;
          }
          return (isElement(v) || v instanceof CUI.Element || isString(v)) && !this._icon && !this._icon_left && !this._icon_active && !this._icon_inactive;
        }
      },
      right: {
        check: function(v) {
          return (v === true || isContent(v)) && !this._icon_right;
        }
      },
      center: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_left: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_right: {
        check: function(v) {
          return v instanceof Icon || isString(v) || v === false;
        }
      },
      icon_active: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_inactive: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      text_active: {
        check: String
      },
      text_inactive: {
        check: String
      },
      value: {},
      name: {
        check: String
      },
      hidden: {
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      menu: {
        check: "PlainObject"
      },
      menu_on_hover: {
        check: Boolean
      },
      menu_parent: {
        check: Menu
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      radio: {
        check: function(v) {
          return isString(v) || v === true;
        }
      },
      radio_allow_null: {
        check: Boolean
      },
      "switch": {
        check: Boolean
      },
      active: {
        check: Boolean
      },
      activate_initial: {
        "default": true,
        check: Boolean
      },
      group: {
        check: String
      },
      role: {
        "default": "button",
        mandatory: true,
        check: String
      }
    });
  };

  Button.prototype.__getIcon = function(icon) {
    if (!icon) {
      return null;
    } else if (icon instanceof Icon) {
      return icon;
    } else {
      return new Icon({
        icon: icon
      });
    }
  };

  Button.prototype.readOpts = function() {
    if (this.opts["switch"]) {
      assert(isUndef(this.opts.radio_allow_null), "new Button", "opts.switch cannot be used together with opts.radio_allow_null", {
        opts: this.opts
      });
    }
    Button.__super__.readOpts.call(this);
    if (this._left) {
      return assert(this._left === true || !(this._icon_active || this._icon_inactive || this._icon), "new Button", "opts.left != true cannot be used togeter with opts.icon*", {
        opts: this.opts
      });
    }
  };

  Button.prototype.getCenter = function() {
    return this.__box.map.center;
  };

  Button.prototype.__getTemplateName = function() {
    if (this._icon || this._icon_left || this._icon_active || this._icon_inactive || this._left) {
      this.__has_left = true;
    } else {
      this.__has_left = false;
    }
    if (this._icon_right || (this._menu && this._icon_right !== false) || this._right) {
      this.__has_right = true;
    } else {
      this.__has_right = false;
    }
    if (this.__has_left && isUndef(this._text) && isUndef(this._center) && isUndef(this._text_active) && isUndef(this._text_inactive) && CUI.__ng__) {
      this.__has_center = false;
    }
    if (this.__has_left && this.__has_right) {
      return "button";
    } else if (this.__has_left) {
      if (this.__has_center) {
        return "button-left-center";
      } else {
        return "button-left";
      }
    } else if (this.__has_right) {
      return "button-center-right";
    } else {
      return "button-center";
    }
  };

  Button.prototype.getTemplateName = function() {
    if (CUI.__ng__) {
      return this.__getTemplateName() + "-ng";
    } else {
      return this.__getTemplateName();
    }
  };

  Button.prototype.getValue = function() {
    return this._value;
  };

  Button.prototype.getElementForLayer = function() {
    return this.__box.map.visual;
  };

  Button.prototype.getRadioButtons = function() {
    if (!this.__radio) {
      return [];
    }
    return this.__getButtons("radio", this.__radio);
  };

  Button.prototype.getGroupButtons = function() {
    if (!this.getGroup()) {
      return [];
    }
    return this.__getButtons("button-group", this.getGroup());
  };

  Button.prototype.__getButtons = function(key, value) {
    var c, docElem, i, len, parents, ref, results;
    parents = this.DOM.parents(".cui-buttonbar,.cui-form-table,.cui-tmpl-item-list-body,.cui-layer");
    if (parents.length === 0) {
      parents = this.DOM.parents();
    }
    if (parents.length > 0) {
      docElem = parents[parents.length - 1];
    } else {
      return [];
    }
    ref = DOM.matchSelector(docElem, ".cui-button[" + key + "=\"" + value + "\"]");
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      results.push(DOM.data(c, "element"));
    }
    return results;
  };

  Button.prototype.hasMenu = function() {
    return !!this.__menu_opts;
  };

  Button.prototype.hasLeft = function() {
    return this.__has_left;
  };

  Button.prototype.getMenu = function() {
    if (!this.hasMenu()) {
      return;
    }
    if (this.__menu) {
      return this.__menu;
    } else {
      return this.__menu = new Menu(this.__menu_opts);
    }
  };

  Button.prototype.menuSetActiveIdx = function(idx) {
    if (this.__menu) {
      this.__menu.setActiveIdx(idx);
    } else {
      this.__menu_opts.itemList.active_item_idx = idx;
    }
    return this;
  };

  Button.prototype.getMenuRootButton = function() {
    var ref;
    if (this._menu_parent) {
      return (ref = this._menu_parent.getButton()) != null ? ref.getMenuRootButton() : void 0;
    } else if (this.hasMenu()) {
      return this;
    } else {
      return null;
    }
  };

  Button.prototype.toggle = function(flags, event) {
    if (flags == null) {
      flags = {};
    }
    return this.setActive(!this.__active, flags, event);
  };

  Button.prototype.setActive = function(active, flags, event) {
    if (flags == null) {
      flags = {};
    }
    if (active) {
      return this.activate(flags, event);
    } else {
      return this.deactivate(flags, event);
    }
  };

  Button.prototype.activate = function(flags, event) {
    var activate, btn, i, idx, len, ref, ret;
    if (flags == null) {
      flags = {};
    }
    activate = (function(_this) {
      return function() {
        var btn, group, i, len, ref;
        _this.addClass(_this._active_css_class);
        _this.setAria("pressed", true);
        _this.__setState();
        group = _this.getGroup();
        if (!group || !(event != null ? event.ctrlKey() : void 0) || flags.ignore_ctrl) {
          return;
        }
        flags.ignore_ctrl = true;
        ref = _this.getGroupButtons();
        for (i = 0, len = ref.length; i < len; i++) {
          btn = ref[i];
          if (btn === _this) {
            continue;
          }
          btn.activate(flags, event);
        }
      };
    })(this);
    if (this._activate_initial === false && flags.initial_activate) {
      this.__active = true;
      activate();
      return this;
    }
    if (this.__active === true && CUI.isEmptyObject(flags)) {
      return this;
    }
    if (this.__radio) {
      ref = this.getRadioButtons();
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        btn = ref[idx];
        if (btn === this || !btn.isActive()) {
          continue;
        }
        btn.deactivate({
          prior_activate: true,
          initial_activate: flags.initial_activate
        });
      }
    }
    this.__active = true;
    ret = typeof this._onActivate === "function" ? this._onActivate(this, flags, event) : void 0;
    if (isPromise(ret)) {
      ret.done(activate).fail((function(_this) {
        return function() {
          return _this.__active = false;
        };
      })(this));
      return ret;
    }
    activate();
    return this;
  };

  Button.prototype.deactivate = function(flags, event) {
    var deactivate, ret;
    if (flags == null) {
      flags = {};
    }
    deactivate = (function(_this) {
      return function() {
        var btn, group, i, len, ref, results;
        _this.removeClass(_this._active_css_class);
        _this.setAria("pressed", false);
        _this.__setState();
        group = _this.getGroup();
        if (!group || !(event != null ? event.ctrlKey() : void 0) || flags.ignore_ctrl) {
          return;
        }
        flags.ignore_ctrl = true;
        ref = _this.getGroupButtons();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          btn = ref[i];
          if (btn === _this) {
            continue;
          }
          results.push(btn.deactivate(flags, event));
        }
        return results;
      };
    })(this);
    if (this._activate_initial === false && flags.initial_activate) {
      this.__active = false;
      deactivate();
      return this;
    }
    if (this.__active === false && CUI.isEmptyObject(flags)) {
      return this;
    }
    this.__active = false;
    ret = typeof this._onDeactivate === "function" ? this._onDeactivate(this, flags, event) : void 0;
    if (isPromise(ret)) {
      ret.done(deactivate).fail((function(_this) {
        return function() {
          return _this.__active = true;
        };
      })(this));
      return ret;
    }
    deactivate();
    return this;
  };

  Button.prototype.setIconRight = function(icon) {
    if (icon == null) {
      icon = null;
    }
    return this.setIcon(icon, "right");
  };

  Button.prototype.setIcon = function(icon, _key) {
    var key;
    if (icon == null) {
      icon = null;
    }
    if (_key == null) {
      _key = "left";
    }
    key = "__icon_" + _key;
    if (icon === "") {
      this[key] = "";
    } else {
      this[key] = this.__getIcon(icon);
    }
    assert(this[key] === null || this[key] === "" || this[key] instanceof Icon, "CUI.Button.setIcon", "icon needs to be instance of Icon", {
      icon: icon
    });
    if (this[key] === null) {
      this.empty(_key);
    } else if (this[key] === "") {
      this.replace(CUI.DOM.element("SPAN"), _key);
    } else {
      this.replace(this[key], _key);
    }
    return this;
  };

  Button.prototype.startSpinner = function() {
    assert(this.__has_left, "CUI.Button.startSpinner", "No space for Icon found, make sure the Button was created with opts.left set.", {
      opts: this.opts
    });
    if (this.__hasSpinner) {
      return;
    }
    this.__iconBeforeSpinner = this.getIcon();
    this.__hasSpinner = true;
    this.setIcon("spinner");
    return this;
  };

  Button.prototype.stopSpinner = function() {
    this.setIcon(this.__iconBeforeSpinner);
    this.__hasSpinner = false;
    this.__iconBeforeSpinner = null;
    return this;
  };

  Button.prototype.getIcon = function() {
    return this.__icon_left;
  };

  Button.prototype.getIconRight = function() {
    return this.__icon_right;
  };

  Button.prototype.__setState = function() {
    this.__setIconState();
    return this.__setTextState();
  };

  Button.prototype.__setIconState = function() {
    if (!(this._icon_active || this._icon_inactive)) {
      return this;
    }
    if (this.isActive()) {
      if (!this._icon_active) {
        this.setIcon("");
      } else {
        this.setIcon(this._icon_active);
      }
    } else {
      if (!this._icon_inactive) {
        this.setIcon("");
      } else {
        this.setIcon(this._icon_inactive);
      }
    }
    return this;
  };

  Button.prototype.__setTextState = function() {
    if (!(this._text_active || this._text_inactive)) {
      return this;
    }
    if (this.isActive()) {
      if (!isNull(this._text_active)) {
        this.setText(this._text_active);
      }
    } else {
      if (!isNull(this._text_inactive)) {
        this.setText(this._text_inactive);
      }
    }
    return this;
  };

  Button.prototype.isActive = function() {
    return !!this.__active;
  };

  Button.prototype.isDisabled = function() {
    return this.__disabled;
  };

  Button.prototype.isEnabled = function() {
    return !this.__disabled;
  };

  Button.prototype.setEnabled = function(enabled) {
    if (enabled) {
      return this.enable();
    } else {
      return this.disable();
    }
  };

  Button.prototype.disable = function() {
    this.DOM.addClass(CUI.defaults["class"].Button.defaults.disabled_css_class);
    DOM.removeAttribute(this.DOM, "tabindex");
    this.__disabled = true;
    return this;
  };

  Button.prototype.enable = function() {
    this.DOM.removeClass(CUI.defaults["class"].Button.defaults.disabled_css_class);
    DOM.setAttribute(this.DOM, "tabindex", this._tabindex);
    this.__disabled = false;
    return this;
  };

  Button.prototype.setText = function(__txt) {
    var span;
    this.__txt = __txt;
    if (isEmpty(this.__txt)) {
      this.__txt = '';
    }
    span = $text(this.__txt);
    if (!this.__hasAriaLabel) {
      span.id = "button-text-" + this.getUniqueId();
      this.setAria("labelledby", span.id);
    }
    return this.replace(span, "center");
  };

  Button.prototype.setTextMaxChars = function(max_chars) {
    return CUI.DOM.setAttribute(this.getCenter().firstChild, "data-max-chars", max_chars);
  };

  Button.prototype.getText = function() {
    return this.__txt;
  };

  Button.prototype.getGroup = function() {
    return this.__group;
  };

  Button.prototype.setGroup = function(__group) {
    this.__group = __group;
    if (this.__group) {
      return DOM.setAttribute(this.DOM, "button-group", this.__group);
    } else {
      return DOM.removeAttribute(this.DOM, "button-group");
    }
  };

  Button.prototype.__initTooltip = function() {
    var i, k, len, ref, tt_opts;
    if (this.__tooltip) {
      return this;
    }
    tt_opts = copyObject(this.__tooltipOpts);
    if (tt_opts.element == null) {
      tt_opts.element = this.DOM;
    }
    ref = ["on_hover", "on_click"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      assert(!tt_opts.hasOwnProperty(k), "CUI.Button.__initTooltip", "opts.tooltip cannot contain " + k + ".", {
        opts: this.opts
      });
      tt_opts[k] = false;
    }
    this.__tooltip = new Tooltip(tt_opts);
    return this;
  };

  Button.prototype.getTooltip = function() {
    return this.__tooltip;
  };

  Button.prototype.isShown = function() {
    return !this.isHidden();
  };

  Button.prototype.isHidden = function() {
    return this.__hidden;
  };

  Button.prototype.destroy = function() {
    var ref, ref1;
    if ((ref = this.__menu) != null) {
      ref.destroy();
    }
    this.__menu = null;
    if ((ref1 = this.__tooltip) != null) {
      ref1.destroy();
    }
    this.__tooltip = null;
    return Button.__super__.destroy.call(this);
  };

  Button.prototype.show = function() {
    this.__hidden = false;
    DOM.removeClass(this.DOM, "cui-button-hidden");
    DOM.showElement(this.DOM);
    return Events.trigger({
      type: "show",
      node: this.DOM
    });
  };

  Button.prototype.hide = function() {
    this.__hidden = true;
    DOM.addClass(this.DOM, "cui-button-hidden");
    DOM.hideElement(this.DOM);
    return Events.trigger({
      type: "hide",
      node: this.DOM
    });
  };

  Button.clickTypes = {
    click: ['click'],
    mouseup: ['mouseup'],
    dblclick: ['dblclick']
  };

  Button.clickTypesPrevent = {
    click: ['dblclick', 'mousedown'],
    mouseup: ['mouseup', 'mousedown'],
    dblclick: ['click', 'mousedown']
  };

  return Button;

})(CUI.DOM);

CUI.defaults["class"].Button = CUI.Button;

CUI.Events.registerEvent({
  type: ["show", "hide", "cui-button-click"],
  bubble: true
});

Button = CUI.Button;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Icon,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Icon = (function(superClass) {
  extend(Icon, superClass);

  function Icon(opts) {
    var cls, svg_cls;
    this.opts = opts != null ? opts : {};
    Icon.__super__.constructor.call(this, this.opts);
    svg_cls = "";
    cls = "";
    if (this._icon) {
      cls = this.icon_map()[this._icon];
      if (isEmpty(cls)) {
        cls = this._icon;
      }
      if (cls.startsWith("svg-")) {
        svg_cls = cls;
        cls = "";
      }
    }
    if (!isEmpty(this._class)) {
      cls += " " + this._class;
    }
    if (svg_cls) {
      this.DOM = CUI.DOM.htmlToNodes("<svg class=\"cui-icon-svg " + svg_cls + " " + cls + "\"><use xlink:href=\"#" + (svg_cls.split(" ")[0]) + "\"></svg>")[0];
    } else {
      this.DOM = CUI.jQueryCompat(CUI.DOM.element("I", {
        "class": "fa " + cls
      }));
    }
    if (this._tooltip) {
      this._tooltip.element = this.DOM;
      new Tooltip(this._tooltip);
    }
  }

  Icon.prototype.initOpts = function() {
    Icon.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        check: String
      },
      icon: {
        check: String
      },
      fixed_width: {
        check: Boolean
      },
      tooltip: {
        check: "PlainObject"
      }
    });
  };

  Icon.prototype.copy = function() {
    return new Icon(this.opts);
  };

  Icon.prototype.hide = function() {
    return CUI.DOM.hideElement(this.DOM);
  };

  Icon.prototype.show = function() {
    return CUI.DOM.showElement(this.DOM);
  };

  Icon.prototype.icon_map = function() {
    return {
      crop: "fa-crop",
      fullscreen: "fa-arrows-alt",
      trash: CUI.__ng__ ? "svg-trash" : "fa-trash-o",
      failed: "fa-warning",
      no_right: "fa-slack",
      file: CUI.__ng__ ? "fa-file" : "fa-file-o",
      filter: "fa-filter",
      refresh: "fa-refresh",
      reset: "svg-reset",
      zip: "fa fa-file-archive-o",
      rotate_right: "fa-rotate-right",
      rotate_left: "fa-rotate-left",
      rotate_vertical: "fa-arrows-v",
      rotate_horizontal: "fa-arrows-h",
      calendar: "fa-calendar",
      show: "fa-question",
      help: "fa-question",
      question: "fa-question",
      settings: CUI.__ng__ ? "fa-cog" : "fa-cogs",
      download: "fa-download",
      "export": "fa-download",
      spinner: "svg-spinner cui-spin-stepped",
      list: "fa-question",
      upload: "fa-upload",
      envelope: "fa-envelope-o",
      envelope_active: "fa-envelope",
      save: "fa-floppy-o",
      heart: "fa-heart",
      remove: "svg-close",
      user: "fa-user",
      clock: "fa-clock-o",
      plus: "fa-plus",
      edit: "fa-pencil",
      copy: "fa-files-o",
      search: "fa-search",
      share: "fa-share",
      play: "fa-play",
      audio: "fa-music",
      start: "fa-play",
      stop: "fa-stop",
      print: "fa-print",
      minus: "fa-minus",
      tree_open: "fa-caret-right",
      tree_close: "fa-caret-down",
      ellipsis_h: "fa-ellipsis-h",
      ellipsis_v: "fa-ellipsis-v",
      close: "svg-close",
      folder: "svg-folder",
      folder_shared: "svg-folder-shared",
      folder_upload: "svg-folder-upload",
      folder_shared_upload: "svg-folder-shared-upload",
      menu: "fa-bars",
      info: "fa-info-circle",
      info_circle: "svg-info-circle",
      bolt: "fa-bolt",
      check: "fa-check",
      warning: "fa-warning",
      legal: "fa-legal",
      cloud: "fa-cloud",
      left: CUI.__ng__ ? "fa-angle-left" : "fa-chevron-left",
      right: CUI.__ng__ ? "fa-angle-right" : "fa-chevron-right",
      dive: CUI.__ng__ ? "fa-angle-right" : "fa-chevron-right",
      zoom_in: "fa-search-plus",
      zoom_out: "fa-search-minus",
      resize_small: "fa-compress",
      resize_full: "fa-expand",
      email: "fa-envelope-o",
      file_text_active: "fa-file-text",
      file_text: "fa-file-text-o",
      required: "fa-bullhorn",
      west: "fa-angle-left",
      east: "fa-angle-right",
      south: "fa-angle-down",
      north: "fa-angle-up",
      up: "fa-caret-up",
      down: "fa-caret-down",
      camera: "fa-camera",
      expert_search: "fa-list-ul",
      image: "fa-picture-o",
      external_link: "svg-external-link"
    };
  };

  return Icon;

})(CUI.Element);

CUI.proxyMethods(CUI.Icon, CUI.Button, ["hide", "show", "isShown", "isHidden"]);

Icon = CUI.Icon;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ButtonHref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ButtonHref = (function(superClass) {
  extend(ButtonHref, superClass);

  function ButtonHref(opts) {
    var attr;
    this.opts = opts != null ? opts : {};
    ButtonHref.__super__.constructor.call(this, this.opts);
    attr = {
      href: this._href,
      tabindex: "0",
      target: this._target
    };
    if (this._download) {
      attr.download = "download";
    }
    this.DOM.attr(attr);
  }

  ButtonHref.prototype.initOpts = function() {
    ButtonHref.__super__.initOpts.call(this);
    return this.addOpts({
      href: {
        check: String
      },
      download: {
        check: Boolean
      },
      target: {
        check: String
      }
    });
  };

  ButtonHref.prototype.readOpts = function() {
    ButtonHref.__super__.readOpts.call(this);
    if (this._icon_right === void 0 && this._appearance === "link") {
      this._icon_right = "external_link";
    }
    return this;
  };

  ButtonHref.prototype.setHref = function(href) {
    return this.DOM.attr("href", href);
  };

  ButtonHref.prototype.getTemplateName = function() {
    ButtonHref.__super__.getTemplateName.call(this);
    if (CUI.__ng__) {
      return "buttonHref-ng";
    } else {
      return "buttonHref";
    }
  };

  return ButtonHref;

})(Button);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Buttonbar,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Buttonbar = (function(superClass) {
  extend(Buttonbar, superClass);

  function Buttonbar(opts) {
    var btn, i, idx, len, ref, tt_opts;
    this.opts = opts != null ? opts : {};
    this.__setVisibilityClasses = bind(this.__setVisibilityClasses, this);
    Buttonbar.__super__.constructor.call(this, this.opts);
    this.__box = new Template({
      name: "buttonbar"
    });
    this.registerTemplate(this.__box);
    this.__buttons = this.__box.DOM;
    this.__groupDivs = {};
    if (this._tooltip) {
      tt_opts = copyObject(this._tooltip);
      tt_opts.element = this.__buttons;
      this.__tooltip = new Tooltip(tt_opts);
    }
    ref = this._buttons;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      btn = ref[idx];
      this.addButton(btn, false);
    }
    if (this._size) {
      this.addClass("cui-buttonbar--size-" + this._size);
    }
    this.__checkVisibility();
  }

  Buttonbar.prototype.initOpts = function() {
    Buttonbar.__super__.initOpts.call(this);
    return this.addOpts({
      size: {
        check: ["big"]
      },
      buttons: {
        mandatory: true,
        "default": [],
        check: Array
      },
      tooltip: {
        check: "PlainObject"
      }
    });
  };

  Buttonbar.prototype.__proxy = function() {
    var args, el, ele, func, i, len, ref;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    ref = DOM.matchSelector(this.__buttons, ".cui-button,.cui-select");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      ele = DOM.data(el, "element");
      ele[func].apply(ele, args);
    }
    return this;
  };

  Buttonbar.prototype.disable = function() {
    return this.__proxy("disable");
  };

  Buttonbar.prototype.enable = function() {
    return this.__proxy("enable");
  };

  Buttonbar.prototype.__setVisibilityClasses = function(el) {
    var c, count, i, idx, last_visible_child, len, ref, ref1;
    count = 0;
    last_visible_child = null;
    ref = el.children;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      c = ref[idx];
      c.classList.remove("cui-first-visible-child");
      c.classList.remove("cui-last-visible-child");
      if (((ref1 = CUI.DOM.data(c, 'element')) != null ? typeof ref1.isHidden === "function" ? ref1.isHidden() : void 0 : void 0) || !CUI.DOM.isVisible(c)) {
        continue;
      }
      count++;
      last_visible_child = c;
      if (count === 1) {
        c.classList.add("cui-first-visible-child");
      }
    }
    if (last_visible_child) {
      last_visible_child.classList.add("cui-last-visible-child");
    }
    return count;
  };

  Buttonbar.prototype.__checkVisibility = function() {
    var d, grp, ref;
    DOM.showElement(this.__buttons);
    for (grp in this.__groupDivs) {
      d = this.__groupDivs[grp];
      if (this.__setVisibilityClasses(d) > 0) {
        DOM.showElement(d);
      } else {
        DOM.hideElement(d);
      }
    }
    if (this.__setVisibilityClasses(this.__buttons) > 0) {
      if ((ref = this.__tooltip) != null ? ref.isShown() : void 0) {
        this.__tooltip.position();
      }
    } else {
      DOM.showElement(this.__buttons);
    }
    return this;
  };

  Buttonbar.prototype.removeButtons = function() {
    return DOM.empty(this.__buttons);
  };

  Buttonbar.prototype.prependButton = function(btn, check_visibility) {
    if (check_visibility == null) {
      check_visibility = true;
    }
    return this.addButton(btn, check_visibility, true);
  };

  Buttonbar.prototype.addButton = function(btn, check_visibility, prepend) {
    var btn_dom, div, func, grp, ref;
    if (check_visibility == null) {
      check_visibility = true;
    }
    if (prepend == null) {
      prepend = false;
    }
    if (isNull(btn)) {
      return;
    }
    if (CUI.isPlainObject(btn)) {
      btn = new CUI.defaults["class"].Button(btn);
    }
    if (btn instanceof Button || btn instanceof DataFieldInput) {
      btn_dom = btn.DOM;
      grp = btn.getGroup();
    } else if (btn instanceof Label) {
      btn_dom = btn.DOM;
      grp = btn.getGroup();
    } else if (btn != null ? (ref = btn.classList) != null ? ref.contains("cui-button") : void 0 : void 0) {
      btn_dom = btn;
      grp = btn.group || null;
    } else {
      assert(false, "new " + this.__cls, "button must be instance of Button or have class \".cui-button\" but is " + (getObjectClass(btn)) + ".", {
        button: btn,
        opts: this.opts
      });
    }
    Events.listen({
      type: ["show", "hide"],
      node: btn,
      call: (function(_this) {
        return function(ev) {
          return _this.__checkVisibility();
        };
      })(this)
    });
    if (prepend) {
      func = "prepend";
    } else {
      func = "append";
    }
    if (grp) {
      if (!this.__groupDivs[grp]) {
        div = $div("cui-buttonbar-group cui-buttonbar-group-" + grp);
        DOM.append(this.__buttons, div);
        this.__groupDivs[grp] = div;
      }
      CUI.DOM[func](this.__groupDivs[grp], btn_dom);
    } else {
      CUI.DOM[func](this.__buttons, btn_dom);
    }
    if (check_visibility) {
      this.__checkVisibility();
    }
    return btn;
  };

  return Buttonbar;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Label,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Label = (function(superClass) {
  extend(Label, superClass);

  Label.defaults = {
    manage_overflow: {
      icon_inactive: "down",
      icon_active: "up",
      active_css_class: ""
    }
  };

  function Label(opts) {
    var btn_opts, k, ref, tname, tt_opts, v;
    this.opts = opts != null ? opts : {};
    Label.__super__.constructor.call(this, this.opts);
    if (this._rotate_90) {
      tname = "label-rotate-90";
    } else if (this._icon || !CUI.__ng__) {
      tname = "label";
    } else {
      tname = "label-no-icon";
    }
    this.__label = new Template({
      name: tname,
      map_prefix: "cui-label",
      map: {
        icon: tname === "label-no-icon" ? void 0 : true,
        content: true
      }
    });
    this.registerTemplate(this.__label);
    if (this._icon && this._icon !== true) {
      this.setIcon(this._icon);
    }
    if (!isEmpty(this._text)) {
      this.setText(this._text);
    } else {
      this.setContent(this._content);
    }
    if (this._tooltip) {
      tt_opts = copyObject(this._tooltip);
      if (tt_opts.element == null) {
        tt_opts.element = this.DOM;
      }
      this.__tooltip = new Tooltip(tt_opts);
    }
    if (this._multiline) {
      this.addClass("cui-label-multiline");
    }
    if (this._centered) {
      this.addClass("cui-label-centered");
    }
    if (this._markdown) {
      this.addClass("cui-label-markdown");
    }
    if (this._manage_overflow) {
      this.addClass("cui-label-manage-overflow");
    }
    if (this._padded) {
      this.addClass("cui-label--padded");
    }
    if (this._size) {
      this.addClass("cui-label-size-" + this._size);
    } else if (!CUI.__ng__) {
      this.addClass("cui-label-size-normal");
    }
    if (this._appearance) {
      this.addClass("cui-label-appearance-" + this._appearance);
    } else if (!CUI.__ng__) {
      this.addClass("cui-label-appearance-auto cui-label-appearance-normal");
    }
    if (this._manage_overflow) {
      if (this._manage_overflow === true) {
        btn_opts = copyObject(CUI.defaults["class"].Label.defaults.manage_overflow, true);
      } else {
        btn_opts = this._manage_overflow;
      }
      ref = {
        "class": "cui-label-manage-overflow-button",
        appearance: "flat",
        "switch": true,
        hidden: true,
        onActivate: (function(_this) {
          return function() {
            return _this.__label.addClass("cui-label--show-overflow");
          };
        })(this),
        onDeactivate: (function(_this) {
          return function() {
            return _this.__label.removeClass("cui-label--show-overflow");
          };
        })(this)
      };
      for (k in ref) {
        v = ref[k];
        if (!btn_opts.hasOwnProperty(k) || (k !== "class")) {
          btn_opts[k] = v;
          continue;
        }
        btn_opts[k] += " " + v;
      }
      this.__overflow_button = new CUI.defaults["class"].Button(btn_opts);
      this.append(this.__overflow_button);
      Events.listen({
        node: this.DOM,
        type: "viewport-resize",
        call: (function(_this) {
          return function() {
            return _this.checkOverflowSize();
          };
        })(this)
      });
    }
    return;
  }

  Label.prototype.initOpts = function() {
    Label.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        check: function(v) {
          return isString(v) || isNumber(v);
        }
      },
      content: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v) || v === true;
        }
      },
      size: {
        check: ["mini", "normal", "big", "bigger"]
      },
      appearance: {
        check: ["normal", "important", "title", "secondary"]
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      markdown_opts: {
        check: "PlainObject"
      },
      tooltip: {
        check: "PlainObject"
      },
      group: {
        check: String
      },
      rotate_90: {
        "default": false,
        check: Boolean
      },
      centered: {
        "default": false,
        check: Boolean
      },
      multiline: {
        "default": false,
        check: Boolean
      },
      padded: {
        "default": false,
        check: Boolean
      },
      manage_overflow: {
        check: function(v) {
          return CUI.isPlainObject(v) || v === true || v === false;
        }
      }
    });
  };

  Label.prototype.readOpts = function() {
    var k, ref, v;
    Label.__super__.readOpts.call(this);
    if (isNull(this._text) && isNull(this._content)) {
      this._text = "";
    }
    if (this._markdown) {
      assert(!this._content, "new " + this.__cls, "opts.markdown cannot be combined with opts.content, use opts.text instead.", {
        opts: this.opts
      });
      if (!marked) {
        CUI.error("new Label: Could not find markdown renderer 'marked'. Disabling markedown option.", {
          opts: this.opts
        });
        this.__markdown = false;
      } else {
        this.__markdown = true;
      }
    }
    this.__currentText = null;
    assert(xor(isNull(this._text), isNull(this._content)), "new Label", "opts.text and opts.content cannot both be set.", {
      opts: this.opts
    });
    if (this._markdown_opts) {
      this.__markdown_opts = copyObject(CUI.defaults.marked_opts, false);
      ref = this._markdown_opts;
      for (k in ref) {
        v = ref[k];
        this.__markdown_opts[k] = v;
      }
    } else {
      this.__markdown_opts = CUI.defaults.marked_opts;
    }
    if (this._manage_overflow) {
      assert(this._multiline, "new Label", "opts.multiline needs to be set for opts.manage_overflow", {
        opts: this.opts
      });
    }
    return this;
  };

  Label.prototype.setText = function(__currentText, markdown) {
    this.__currentText = __currentText;
    if (markdown == null) {
      markdown = this.__markdown;
    }
    if (isEmpty(this.__currentText)) {
      this.empty("content");
    } else if (markdown) {
      this.setContent(CUI.DOM.htmlToNodes(window.marked(this.__currentText, this.__markdown_opts)));
      this.addClass("cui-label-markdown");
    } else {
      this.setContent($text(this.__currentText));
      this.removeClass("cui-label-markdown");
    }
    return this;
  };

  Label.prototype.setTextMaxChars = function(max_chars) {
    return CUI.DOM.setAttribute(this.__label.map.content[0], "data-max-chars", max_chars);
  };

  Label.prototype.getText = function() {
    return this.__currentText;
  };

  Label.prototype.setContent = function(content) {
    if (isString(content)) {
      this.replace(CUI.DOM.htmlToNodes(content), 'content');
    } else {
      this.replace(content, "content");
    }
    if (!this._manage_overflow) {
      return;
    }
    this.append(this.__overflow_button);
    CUI.DOM.waitForDOMInsert({
      node: this.DOM
    }).done((function(_this) {
      return function() {
        return _this.checkOverflowSize();
      };
    })(this));
  };

  Label.prototype.checkOverflowSize = function() {
    var dim_div, max_height;
    if (!this.__overflow_button) {
      return;
    }
    this.__label.removeClass("cui-label--show-overflow");
    this.__label.addClass("cui-label--measure-overflow");
    this.__overflow_button.hide();
    dim_div = DOM.getDimensions(this.__label.map.content);
    max_height = CUI.DOM.getCSSFloatValue(dim_div.computedStyle.maxHeight);
    if (!(max_height > 0)) {
      max_height = dim_div.clientHeight;
    }
    if (dim_div.scrollHeight > max_height) {
      this.__overflow_button.show();
      if (this.__overflow_button.isActive()) {
        this.__label.addClass("cui-label--show-overflow");
      }
    } else {
      this.__label.addClass("cui-label--show-overflow");
    }
    this.__label.removeClass("cui-label--measure-overflow");
    return this;
  };

  Label.prototype.getGroup = function() {
    return this._group;
  };

  Label.prototype.setIcon = function(icon) {
    var __icon;
    if (icon instanceof Icon) {
      __icon = icon;
    } else if (!isEmpty(icon)) {
      __icon = new Icon({
        icon: icon
      });
    } else {
      __icon = null;
    }
    this.replace(__icon, "icon");
    return this;
  };

  Label.prototype.destroy = function() {
    var ref;
    if ((ref = this.__tooltip) != null) {
      ref.destroy();
    }
    return Label.__super__.destroy.call(this);
  };

  return Label;

})(CUI.DOM);

CUI.defaults["class"].Label = CUI.Label;

Label = CUI.Label;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MultilineLabel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultilineLabel = (function(superClass) {
  extend(MultilineLabel, superClass);

  function MultilineLabel(opts) {
    this.opts = opts != null ? opts : {};
    MultilineLabel.__super__.constructor.call(this, this.opts);
    this.addClass("cui-label");
  }

  MultilineLabel.prototype.initOpts = function() {
    MultilineLabel.__super__.initOpts.call(this);
    return this.mergeOpt("multiline", {
      "default": true
    });
  };

  return MultilineLabel;

})(Label);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var EmptyLabel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EmptyLabel = (function(superClass) {
  extend(EmptyLabel, superClass);

  function EmptyLabel(opts) {
    this.opts = opts != null ? opts : {};
    EmptyLabel.__super__.constructor.call(this, this.opts);
    this.addClass("cui-empty-label");
  }

  EmptyLabel.prototype.readOpts = function() {
    return EmptyLabel.__super__.readOpts.call(this);
  };

  return EmptyLabel;

})(MultilineLabel);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ProgressMeter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ProgressMeter = (function(superClass) {
  extend(ProgressMeter, superClass);

  function ProgressMeter(opts) {
    this.opts = opts != null ? opts : {};
    ProgressMeter.__super__.constructor.call(this, this.opts);
    this.__meter = new Template({
      name: "progress-meter",
      map: {
        icon: true,
        text: true,
        fill: true
      }
    });
    this.registerTemplate(this.__meter);
    if (this._state) {
      this.setState(this._state);
    } else if (this._states.length) {
      this.setState(this._states[0]);
    }
  }

  ProgressMeter.prototype.__checkState = function(state) {
    return indexOf.call(this._states, state) >= 0 || (typeof state === "number" && state >= 0 && state <= 100);
  };

  ProgressMeter.prototype.initOpts = function() {
    var i, len, ref, results, state;
    ProgressMeter.__super__.initOpts.call(this);
    if (!this.opts.states) {
      this.opts.states = Object.keys(CUI.defaults.ProgressMeter.states);
    }
    this.addOpts({
      states: {
        check: Array
      },
      state: {
        check: (function(_this) {
          return function(v) {
            return _this.__checkState(v);
          };
        })(this)
      },
      css_property_percent: {
        "default": "width",
        check: String
      },
      size: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "mini", "normal", "big"]
      },
      appearance: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "normal", "important"]
      },
      onUpdate: {
        check: Function
      }
    });
    ref = this.opts.states;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      state = ref[i];
      results.push(this.addOpt("icon_" + state, {
        "default": CUI.defaults.ProgressMeter.states[state],
        check: (function(_this) {
          return function(v) {
            return v instanceof Icon || isString(v);
          };
        })(this)
      }));
    }
    return results;
  };

  ProgressMeter.prototype.getState = function() {
    return this.__state;
  };

  ProgressMeter.prototype.getMeter = function() {
    return this.__meter;
  };

  ProgressMeter.prototype.setState = function(state) {
    var fill_css, icon, ref, ref1;
    assert(this.__checkState(state), "ProgressMeter.setState", "state needs to be " + this._states.join(",") + " or between 0 and 100.", {
      state: state
    });
    if (typeof state === "number") {
      state = Math.round(state * 100) / 100;
    }
    if (this.__state === state) {
      return;
    }
    this.__state = state;
    if (ref = this.__state, indexOf.call(this._states, ref) >= 0) {
      icon = this["_icon_" + this.__state];
      if (icon instanceof Icon) {
        this.__meter.replace(icon, "icon");
      } else if (!isEmpty(icon)) {
        this.__meter.replace(new Icon({
          icon: icon
        }), "icon");
      } else {
        this.__meter.empty("icon");
      }
      this.__meter.DOM.attr("state", this.__state);
      this.__meter.empty("text");
      fill_css = {};
      fill_css[this._css_property_percent] = "";
    } else {
      this.__meter.DOM.attr("state", "percent");
      this.__meter.empty("icon");
      this.__meter.replace(Math.round(this.__state) + "%", "text");
      fill_css = {};
      fill_css[this._css_property_percent] = this.__state + "%";
    }
    this.__meter.map.fill.css(fill_css);
    if ((ref1 = this._onUpdate) != null) {
      ref1.call(this, this);
    }
    return this;
  };

  return ProgressMeter;

})(CUI.DOM);

CUI.defaults.ProgressMeter = {
  states: {
    waiting: "fa-hourglass",
    spinning: "svg-spinner cui-spin-stepped"
  }
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Block,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Block = (function(superClass) {
  extend(Block, superClass);

  function Block(opts) {
    this.opts = opts != null ? opts : {};
    Block.__super__.constructor.call(this, this.opts);
    this.__block = new Template({
      name: this.getTemplateName(),
      map: {
        header: true,
        content: true
      }
    });
    this.registerTemplate(this.__block);
    if (this._header) {
      this.setHeader(this._header);
    } else {
      if (this._text || this._icon) {
        this.__label = new Label({
          text: this._text,
          icon: this._icon,
          multiline: true
        });
        this.setHeader(this.__label);
      }
    }
    if (this._content) {
      this.setContent(this._content);
    }
    this.addClass("appearance-" + this._appearance);
    this.addClass("cui-block-level-" + this._level);
    if (this._padded) {
      this.addClass("cui-block--padded");
    }
  }

  Block.prototype.initOpts = function() {
    Block.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        check: String
      },
      header: {
        check: function(v) {
          return !!(isContent(v) || isString(v) || (v != null ? v.DOM : void 0));
        }
      },
      icon: {
        check: Icon
      },
      content: {
        check: function(v) {
          return !!(isContent(v) || isString(v) || (v != null ? v.DOM : void 0));
        }
      },
      level: {
        mandatory: true,
        "default": 1,
        check: [1, 2, 3]
      },
      appearance: {
        deprectated: true,
        "default": "normal",
        mandatory: true,
        check: ["title", "subtitle", "normal"]
      },
      padded: {
        check: Boolean,
        "default": true
      }
    });
  };

  Block.prototype.readOpts = function() {
    Block.__super__.readOpts.call(this);
    assert(!((this._text || this._icon) && this._header), "new Block", "opts.text and opts.header are mutually exclusive.", {
      opts: this.opts
    });
    return this;
  };

  Block.prototype.getTemplateName = function() {
    return "block";
  };

  Block.prototype.setText = function(txt) {
    assert(this.__label, "Block.setText", "Block must not be called with opts.header and with opts.text or opts.icon.", {
      opts: this.opts
    });
    return this.__label.setText(txt);
  };

  Block.prototype.setIcon = function(icon) {
    assert(this.__label, "Block.setText", "Block must not be called with opts.header and with opts.text or opts.icon.", {
      opts: this.opts
    });
    return this.__label.setIcon(icon);
  };

  Block.prototype.setHeader = function(header) {
    return this.__block.replace(header, "header");
  };

  Block.prototype.setContent = function(content) {
    return this.__block.replace(content, "content");
  };

  Block.prototype.appendContent = function(content) {
    return this.__block.append(content, "content");
  };

  return Block;

})(CUI.DOM);

Block = CUI.Block;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var WaitBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.WaitBlock = (function(superClass) {
  extend(WaitBlock, superClass);

  function WaitBlock(opts) {
    this.opts = opts != null ? opts : {};
    WaitBlock.__super__.constructor.call(this, this.opts);
    if (this._inactive) {
      this.DOM.addClass("cui-wait-block-inactive");
    }
    if (this._fullscreen) {
      this.DOM.addClass("cui-wait-block-fullscreen");
    }
  }

  WaitBlock.prototype.initOpts = function() {
    WaitBlock.__super__.initOpts.call(this);
    this.mergeOpt("icon", {
      check: function(v) {
        return v instanceof Icon || isString(v);
      }
    });
    this.removeOpt("header");
    this.removeOpt("content");
    return this.addOpts({
      inactive: {
        check: Boolean
      },
      element: {
        check: function(v) {
          return isElement(v) || isElement(v.DOM);
        }
      },
      fullscreen: {
        check: Boolean
      }
    });
  };

  WaitBlock.prototype.readOpts = function() {
    WaitBlock.__super__.readOpts.call(this);
    assert(xor(this._element, this._fullscreen), "new WaitBlock", "opts.element or opt.fullscreen needs to be set.", {
      opts: this.opts
    });
    if (this._fullscreen) {
      this.__element = $(document.body);
    } else if (this._element.DOM) {
      this.__element = this._element.DOM;
    } else {
      this.__element = this._element;
    }
    if (!this._inactive && !this.opts.hasOwnProperty("icon")) {
      this._icon = "spinner";
    }
    this.__shown = false;
    this.__savedPosition = null;
    return this;
  };

  WaitBlock.prototype.getTemplateName = function() {
    return "wait-block";
  };

  WaitBlock.prototype.show = function() {
    var position;
    position = this.__element[0].style.position;
    if (!DOM.isPositioned(this.__element[0])) {
      this.__savedPosition = this.__element[0].style.position;
      this.__element[0].style.position = "relative";
    } else {
      this.__savedPosition = null;
    }
    this.__element.addClass("cui-wait-block-active");
    if (this._fullscreen) {
      this.DOM.appendTo(this.__element);
    } else {
      this.__element.append(this.DOM);
    }
    this.__shown = true;
    return this;
  };

  WaitBlock.prototype.isShown = function() {
    return !!this.__shown;
  };

  WaitBlock.prototype.hide = function() {
    if (!this.isShown()) {
      return this;
    }
    this.DOM.detach();
    if (this.__savedPosition !== null) {
      this.__element[0].style.position = this.__savedPosition;
    }
    this.__element.removeClass("cui-wait-block-active");
    this.__shown = false;
    this.__savedPosition = null;
    return this;
  };

  WaitBlock.prototype.destroy = function() {
    this.hide();
    return WaitBlock.__super__.destroy.call(this);
  };

  return WaitBlock;

})(CUI.Block);

WaitBlock = CUI.WaitBlock;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var BorderLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BorderLayout = (function(superClass) {
  extend(BorderLayout, superClass);

  function BorderLayout() {
    return BorderLayout.__super__.constructor.apply(this, arguments);
  }

  BorderLayout.prototype.getName = function() {
    return "border-layout";
  };

  BorderLayout.prototype.getPanes = function() {
    return ["north", "west", "east", "south"];
  };

  BorderLayout.prototype.getSupportedPanes = function() {
    return this.getPanes();
  };

  BorderLayout.prototype.getTemplateMap = function() {
    var map;
    map = BorderLayout.__super__.getTemplateMap.call(this);
    map.row = true;
    return map;
  };

  BorderLayout.prototype.__init = function() {
    BorderLayout.__super__.__init.call(this);
    if (this._absolute) {
      this.getLayout().map.row.addClass("cui-absolute");
      Events.listen({
        type: "viewport-resize",
        node: this.getLayout().map.row,
        call: (function(_this) {
          return function(ev) {
            ev.stopPropagation();
            return Layout.setAbsolute(_this.getLayout().map.row);
          };
        })(this)
      });
    }
    return this;
  };

  return BorderLayout;

})(Layout);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Console = (function(superClass) {
  extend(Console, superClass);

  function Console(opts) {
    this.opts = opts != null ? opts : {};
    Console.__super__.constructor.call(this, this.opts);
    this.__console = CUI.DOM.element("DIV", {
      "class": "cui-console"
    });
    this.registerDOMElement(this.__console);
  }

  Console.prototype.initOpts = function() {
    Console.__super__.initOpts.call(this);
    return this.addOpts({
      markdown: {
        mandatory: true,
        "default": true,
        check: Boolean
      }
    });
  };

  Console.prototype.clear = function() {
    return this.__console.innerHTML = "";
  };

  Console.prototype.log = function(txt, markdown) {
    var lbl;
    if (markdown == null) {
      markdown = this._markdown;
    }
    lbl = new CUI.defaults["class"].Label({
      text: txt,
      multiline: true,
      markdown: markdown
    });
    this.__console.appendChild(lbl.DOM[0]);
    return this.__console.scrollTop = this.__console.scrollHeight;
  };

  return Console;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var HorizontalLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.HorizontalLayout = (function(superClass) {
  extend(HorizontalLayout, superClass);

  function HorizontalLayout() {
    return HorizontalLayout.__super__.constructor.apply(this, arguments);
  }

  HorizontalLayout.prototype.getName = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return "horizontal-layout";
    }
    panes = this.getPanes();
    if (panes.length === 2) {
      return "horizontal-layout-left-center-right";
    } else if (indexOf.call(panes, "left") >= 0) {
      return "horizontal-layout-left-center";
    } else if (indexOf.call(panes, "right") >= 0) {
      return "horizontal-layout-center-right";
    } else {
      return "horizontal-layout-center";
    }
  };

  HorizontalLayout.prototype.getMapPrefix = function() {
    return "cui-horizontal-layout";
  };

  HorizontalLayout.prototype.hasFlexHandles = function() {
    var ref, ref1;
    if (((ref = this._left) != null ? ref.flexHandle : void 0) || ((ref1 = this._right) != null ? ref1.flexHandle : void 0)) {
      return true;
    }
    return false;
  };

  HorizontalLayout.prototype.getPanes = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return ["left", "right"];
    }
    panes = [];
    if (this._left) {
      panes.push("left");
    }
    if (this._right) {
      panes.push("right");
    }
    return panes;
  };

  HorizontalLayout.prototype.getSupportedPanes = function() {
    return ["left", "right"];
  };

  return HorizontalLayout;

})(CUI.Layout);

HorizontalLayout = CUI.HorizontalLayout;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var VerticalLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.VerticalLayout = (function(superClass) {
  extend(VerticalLayout, superClass);

  function VerticalLayout() {
    return VerticalLayout.__super__.constructor.apply(this, arguments);
  }

  VerticalLayout.prototype.getName = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return "vertical-layout";
    }
    panes = this.getPanes();
    if (panes.length === 2) {
      return "vertical-layout-top-center-bottom";
    } else if (indexOf.call(panes, "top") >= 0) {
      return "vertical-layout-top-center";
    } else if (indexOf.call(panes, "bottom") >= 0) {
      return "vertical-layout-center-bottom";
    } else {
      return "vertical-layout-center";
    }
  };

  VerticalLayout.prototype.getMapPrefix = function() {
    return "cui-vertical-layout";
  };

  VerticalLayout.prototype.hasFlexHandles = function() {
    var ref, ref1;
    if (((ref = this._top) != null ? ref.flexHandle : void 0) || ((ref1 = this._bottom) != null ? ref1.flexHandle : void 0)) {
      return true;
    }
    return false;
  };

  VerticalLayout.prototype.getPanes = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return ["top", "bottom"];
    }
    panes = [];
    if (this._top) {
      panes.push("top");
    }
    if (this._bottom) {
      panes.push("bottom");
    }
    return panes;
  };

  VerticalLayout.prototype.getSupportedPanes = function() {
    return ["top", "bottom"];
  };

  return VerticalLayout;

})(CUI.Layout);

VerticalLayout = CUI.VerticalLayout;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.sorg
 */
var VerticalList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.VerticalList = (function(superClass) {
  extend(VerticalList, superClass);

  function VerticalList() {
    return VerticalList.__super__.constructor.apply(this, arguments);
  }

  VerticalList.prototype.initOpts = function() {
    VerticalList.__super__.initOpts.call(this);
    this.mergeOpt("maximize", {
      "default": false
    });
    this.removeOpt("center");
    return this.addOpts({
      content: {}
    });
  };

  VerticalList.prototype.readOpts = function() {
    VerticalList.__super__.readOpts.call(this);
    return this._center = {
      content: this._content
    };
  };

  VerticalList.prototype.getSupportedPanes = function() {
    return [];
  };

  return VerticalList;

})(CUI.VerticalLayout);

VerticalList = CUI.VerticalList;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var HorizontalList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.HorizontalList = (function(superClass) {
  extend(HorizontalList, superClass);

  function HorizontalList() {
    return HorizontalList.__super__.constructor.apply(this, arguments);
  }

  HorizontalList.prototype.initOpts = function() {
    HorizontalList.__super__.initOpts.call(this);
    this.mergeOpt("maximize", {
      "default": false
    });
    this.removeOpt("center");
    return this.addOpts({
      content: {}
    });
  };

  HorizontalList.prototype.readOpts = function() {
    HorizontalList.__super__.readOpts.call(this);
    return this._center = {
      content: this._content
    };
  };

  HorizontalList.prototype.getSupportedPanes = function() {
    return [];
  };

  return HorizontalList;

})(CUI.HorizontalLayout);

HorizontalList = CUI.HorizontalList;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Toolbar,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Toolbar = (function(superClass) {
  extend(Toolbar, superClass);

  function Toolbar() {
    return Toolbar.__super__.constructor.apply(this, arguments);
  }

  Toolbar.prototype.init = function() {
    Toolbar.__super__.init.call(this);
    return this.addClass("cui-toolbar");
  };

  Toolbar.prototype.initOpts = function() {
    Toolbar.__super__.initOpts.call(this);
    if (CUI.__ng__) {
      this.removeOpt("maximize");
      this.removeOpt("maximize_horizontal");
      this.removeOpt("maximize_vertical");
      return this.addOpts({
        maximize_horizontal: {
          "default": true,
          mandatory: true,
          check: Boolean
        }
      });
    }
  };

  Toolbar.prototype.hasFlexHandles = function() {
    return false;
  };

  Toolbar.prototype.getPanes = function() {
    return ["left", "right"];
  };

  return Toolbar;

})(HorizontalLayout);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Pane,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Pane = (function(superClass) {
  extend(Pane, superClass);

  function Pane() {
    return Pane.__super__.constructor.apply(this, arguments);
  }

  Pane.defaults = {
    button_tooltip: {
      text: "Turn fullscreen on / off"
    }
  };

  Pane.prototype.__init = function() {
    Pane.__super__.__init.call(this);
    this.addClass("cui-pane");
    this.__fill_screen_is_on = false;
    if (this._padded) {
      return this.addClass("cui-pane--padded");
    }
  };

  Pane.prototype.initOpts = function() {
    Pane.__super__.initOpts.call(this);
    return this.addOpts({
      padded: {
        check: Boolean,
        "default": false
      }
    });
  };

  Pane.prototype.readOpts = function() {
    this.initDefaultPanes();
    return Pane.__super__.readOpts.call(this);
  };

  Pane.prototype.hasHeader = function() {
    return !!this._top;
  };

  Pane.prototype.hasFooter = function() {
    return !!this._bottom;
  };

  Pane.prototype.getFillScreenState = function() {
    return this.__fill_screen_is_on;
  };

  Pane.prototype.endFillScreen = function(transition) {
    var end_fill_screen;
    if (transition == null) {
      transition = true;
    }
    if (!this.getFillScreenState()) {
      return;
    }
    this.__fill_screen_is_on = false;
    if (!$elementIsInDOM(this.__placeholder)) {
      this.__fillscreenTmpl.destroy();
      this.__placeholder = null;
    } else {
      end_fill_screen = (function(_this) {
        return function() {
          _this.__placeholder.before(_this.DOM);
          _this.__placeholder.remove();
          _this.__fillscreenTmpl.destroy();
          delete _this.__fillscreenTmpl;
          Events.trigger({
            type: "end-fill-screen",
            node: _this.DOM
          });
          return Events.trigger({
            type: "viewport-resize",
            node: _this.DOM
          });
        };
      })(this);
      if (transition) {
        Events.wait({
          type: "transitionend",
          node: this.__fillscreenTmpl
        }).always((function(_this) {
          return function() {
            return end_fill_screen();
          };
        })(this));
        this.__fillscreenTmpl.removeClass("cui-pane-fill-screen-is-on");
      } else {
        end_fill_screen();
      }
    }
    return this;
  };

  Pane.prototype.startFillScreen = function() {
    var adjust, checkToggle, i, inner, key_copy, len, rect, rect_fill, rect_fill_inner, ref, start_rect, vp;
    if (this.getFillScreenState()) {
      return;
    }
    this.__fillscreenTmpl = new Template({
      name: "pane-fill-screen",
      map: {
        inner: true
      }
    });
    rect = this.DOM.rect();
    vp = CUI.DOM.getDimensions(window);
    this.__placeholderTmpl = new Template({
      name: "pane-fill-screen-placeholder"
    });
    this.__placeholder = this.__placeholderTmpl.DOM;
    inner = this.__fillscreenTmpl.map.inner;
    this.__fillscreenTmpl.DOM.appendTo(document.body);
    rect_fill = this.__fillscreenTmpl.DOM.rect();
    rect_fill_inner = inner.rect();
    adjust = {
      left: (rect_fill_inner.left - rect_fill.left) + inner.cssEdgeSpace("left"),
      top: (rect_fill_inner.top - rect_fill.top) + inner.cssEdgeSpace("top"),
      right: (rect_fill.right - rect_fill_inner.right) + inner.cssEdgeSpace("right"),
      bottom: (rect_fill.bottom - rect_fill_inner.bottom) + inner.cssEdgeSpace("bottom")
    };
    start_rect = {
      top: rect.top - adjust.top,
      left: rect.left - adjust.left,
      bottom: vp.height - rect.bottom - adjust.bottom,
      right: vp.width - rect.right - adjust.right
    };
    this.__fillscreenTmpl.DOM.detach();
    this.__fillscreenTmpl.DOM.css(start_rect);
    this.__fillscreenTmpl.DOM.appendTo(document.body);
    this.__placeholder.css({
      width: this.DOM.outerWidth(true),
      height: this.DOM.outerHeight(true)
    });
    ref = ["position", "top", "left", "right", "bottom"];
    for (i = 0, len = ref.length; i < len; i++) {
      key_copy = ref[i];
      this.__placeholder.css(key_copy, this.DOM.css(key_copy));
    }
    this.DOM.after(this.__placeholder);
    this.__fillscreenTmpl.replace(this.DOM, "inner");
    Events.wait({
      type: "transitionend",
      node: this.__fillscreenTmpl
    }).always((function(_this) {
      return function() {
        Events.trigger({
          type: "start-fill-screen",
          node: _this.DOM
        });
        return Events.trigger({
          type: "viewport-resize",
          node: _this.DOM
        });
      };
    })(this));
    this.__fillscreenTmpl.addClass("cui-pane-fill-screen-is-on");
    this.__fill_screen_is_on = true;
    checkToggle = (function(_this) {
      return function() {
        if (!_this.getFillScreenState()) {
          return;
        }
        if (!$elementIsInDOM(_this.__placeholder)) {
          _this.endFillScreen();
        }
        return CUI.setTimeout(checkToggle, 50);
      };
    })(this);
    checkToggle();
    return this.__fill_screen_is_on;
  };

  Pane.prototype.toggleFillScreen = function() {
    if (this.getFillScreenState()) {
      return this.endFillScreen();
    } else {
      return this.startFillScreen();
    }
  };

  Pane.getToggleFillScreenButton = function(opts) {
    var k, ref, v;
    if (opts == null) {
      opts = {};
    }
    ref = {
      icon_inactive: new Icon({
        "class": "fa-expand"
      }),
      icon_active: new Icon({
        "class": "fa-compress"
      }),
      "switch": true,
      onClick: (function(_this) {
        return function(ev, btn) {
          return DOM.data(btn.DOM.closest(".cui-pane")[0], "element").toggleFillScreen();
        };
      })(this)
    };
    for (k in ref) {
      v = ref[k];
      opts[k] = v;
    }
    if (!opts.tooltip) {
      opts.tooltip = CUI.Pane.defaults.button_tooltip;
    }
    return new CUI.defaults["class"].Button(opts);
  };

  return Pane;

})(CUI.VerticalLayout);

CUI.Events.registerEvent({
  type: ["start-fill-screen", "end-fill-screen"],
  sink: true
});

Pane = CUI.Pane;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.LayerPane = (function(superClass) {
  extend(LayerPane, superClass);

  function LayerPane(opts) {
    this.opts = opts != null ? opts : {};
    LayerPane.__super__.constructor.call(this, this.opts);
    this.setPane(this._pane);
  }

  LayerPane.prototype.initOpts = function() {
    LayerPane.__super__.initOpts.call(this);
    return this.addOpts({
      pane: {
        mandatory: true,
        "default": new SimplePane(),
        check: function(v) {
          return v instanceof Pane || CUI.isPlainObject(v);
        }
      }
    });
  };

  LayerPane.prototype.getPane = function() {
    return this.__pane;
  };

  LayerPane.prototype.setPane = function(pane) {
    if (CUI.isPlainObject(pane)) {
      this.__pane = new SimplePane(pane);
    } else {
      this.__pane = pane;
    }
    if (this.__pane.hasHeader()) {
      this.__layer_root.DOM.classList.add("cui-pane--has-header");
    }
    if (this.__pane.hasFooter()) {
      this.__layer_root.DOM.classList.add("cui-pane--has-footer");
    }
    this.__pane.addClass("cui-layer-pane");
    return CUI.Layer.prototype.replace.call(this, this.__pane);
  };

  LayerPane.prototype.destroy = function() {
    this.__pane.destroy();
    return LayerPane.__super__.destroy.call(this);
  };

  return LayerPane;

})(CUI.Layer);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var SimplePane,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.SimplePane = (function(superClass) {
  extend(SimplePane, superClass);

  function SimplePane() {
    return SimplePane.__super__.constructor.apply(this, arguments);
  }

  SimplePane.prototype.__init = function() {
    var i, k, len, ref, value;
    SimplePane.__super__.__init.call(this);
    ref = ["header_left", "header_center", "header_right", "footer_left", "footer_right"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      value = this["_" + k];
      if (!value) {
        continue;
      }
      this.append(value, k);
    }
    if (this._title) {
      this.append(new Label({
        text: this._title
      }), "header_left");
    }
    if (!CUI.__ng__) {
      return this.addClass("cui-simple-pane");
    }
  };

  SimplePane.prototype.initOpts = function() {
    SimplePane.__super__.initOpts.call(this);
    this.addOpts({
      title: {},
      header_right: {},
      header_center: {},
      header_left: {},
      footer_left: {},
      footer_right: {},
      content: {},
      force_header: {
        mandatory: true,
        check: Boolean,
        "default": false
      },
      force_footer: {
        mandatory: true,
        check: Boolean,
        "default": false
      }
    });
    this.removeOpt("top");
    this.removeOpt("bottom");
    this.removeOpt("center");
    return this;
  };

  SimplePane.prototype.readOpts = function() {
    VerticalLayout.prototype.readOpts.call(this);
    if (this._title) {
      assert(!this._header_left, "new SimplePane", "opts.header_left conflicts with opts.title", {
        opts: this.opts
      });
    }
    if (this.forceHeader() || !(isUndef(this._header_left) && isUndef(this._header_center) && isUndef(this._header_right)) || this._title) {
      this.__pane_header = new PaneHeader();
      this._top = {
        content: this.__pane_header
      };
    }
    if (this.forceFooter() || !(isUndef(this._footer_left) && isUndef(this._footer_right))) {
      this.__pane_footer = new PaneFooter();
      this._bottom = {
        content: this.__pane_footer
      };
    }
    this._center = {
      content: this._content
    };
    return this;
  };

  SimplePane.prototype.forceHeader = function() {
    return this._force_header;
  };

  SimplePane.prototype.forceFooter = function() {
    return this._force_footer;
  };

  SimplePane.prototype.hasHeader = function() {
    return !!this.__pane_header;
  };

  SimplePane.prototype.hasFooter = function() {
    return !!this.__pane_footer;
  };

  SimplePane.prototype.destroy = function() {
    var ref, ref1;
    if ((ref = this.__pane_header) != null) {
      ref.destroy();
    }
    this.__pane_header = null;
    if ((ref1 = this.__pane_footer) != null) {
      ref1.destroy();
    }
    this.__pane_footer = null;
    return SimplePane.__super__.destroy.call(this);
  };

  SimplePane.prototype.getPaneAndKey = function(key) {
    var m, pane, pn;
    if (key === "center" || key === "top" || key === "bottom") {
      return [this.getLayout(), key];
    } else if (key === "content") {
      return [this.getLayout(), "center"];
    } else {
      m = key.match(/^(.*?)_(.*)$/);
      assert((m != null ? m.length : void 0) === 3, "SimplePane.getPaneAndKey", "key " + key + " not matched.", {
        matched: m
      });
      pn = "__pane_" + (m != null ? m[1] : void 0);
      pane = this[pn];
      assert(pane, "SimplePane.getPaneAndKey", "pane " + pn + " not found.");
      return [pane, m[2]];
    }
  };

  SimplePane.prototype.empty = function(key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.empty(_key);
    return this;
  };

  SimplePane.prototype.append = function(content, key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.append(content, _key);
    return this;
  };

  SimplePane.prototype.replace = function(content, key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.replace(content, _key);
    return this;
  };

  return SimplePane;

})(CUI.Pane);

SimplePane = CUI.SimplePane;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var PaneToolbar,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneToolbar = (function(superClass) {
  extend(PaneToolbar, superClass);

  function PaneToolbar() {
    return PaneToolbar.__super__.constructor.apply(this, arguments);
  }

  PaneToolbar.prototype.init = function() {
    PaneToolbar.__super__.init.call(this);
    return this.addClass("cui-pane-toolbar");
  };

  return PaneToolbar;

})(Toolbar);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var PaneHeader,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneHeader = (function(superClass) {
  extend(PaneHeader, superClass);

  function PaneHeader() {
    return PaneHeader.__super__.constructor.apply(this, arguments);
  }

  PaneHeader.prototype.init = function() {
    PaneHeader.__super__.init.call(this);
    return this.addClass("cui-pane-header");
  };

  return PaneHeader;

})(Toolbar);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var PaneFooter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneFooter = (function(superClass) {
  extend(PaneFooter, superClass);

  function PaneFooter() {
    return PaneFooter.__super__.constructor.apply(this, arguments);
  }

  PaneFooter.prototype.init = function() {
    PaneFooter.__super__.init.call(this);
    return this.addClass("cui-pane-footer");
  };

  return PaneFooter;

})(Toolbar);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Tab,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tab = (function(superClass) {
  extend(Tab, superClass);

  function Tab(opts) {
    var cls;
    this.opts = opts != null ? opts : {};
    Tab.__super__.constructor.call(this, this.opts);
    if (!isEmpty(this._name)) {
      cls = "ez-tab-" + (toClass(this._name));
    } else {
      cls = null;
    }
    this.__body = new Template({
      name: "tab-body",
      "class": cls
    });
    this.registerTemplate(this.__body);
    if (this._content_placeholder) {
      this.append(this._content_placeholder);
      this.__has_placeholder = true;
    }
    if (CUI.isFunction(this._content)) {
      if (!this._load_on_show) {
        this.loadContent();
      }
    } else if (this._content) {
      this.append(this._content);
    }
    this.__activations = 0;
  }

  Tab.prototype.initButton = function(tabs) {
    assert(tabs instanceof CUI.Tabs, "Tab.initButton", "Parameter #1 need to be instance of Tabs.", {
      tabs: tabs
    });
    this.__button = new Button({
      role: "tab-header",
      radio: "tabs--" + tabs.getUniqueId(),
      "class": "cui-tab-header-button",
      disabled: this._disabled,
      size: CUI.__ng__ ? "normal" : "big",
      group: CUI.__ng__ ? "tabs" : null,
      text: this._text,
      attr: {
        tab: this._name
      },
      active: false,
      onActivate: (function(_this) {
        return function(btn) {
          _this.__activations++;
          if (_this._load_on_show && !_this.__content_loaded) {
            _this.loadContent();
          }
          _this.show();
          if (_this.__activations === 1) {
            if (typeof _this._onFirstActivate === "function") {
              _this._onFirstActivate(_this);
            }
          }
          if (typeof _this._onActivate === "function") {
            _this._onActivate(_this);
          }
          return Events.trigger({
            type: "tab_activate",
            node: _this.DOM
          });
        };
      })(this),
      onDeactivate: (function(_this) {
        return function(btn) {
          _this.hide();
          if (typeof _this._onDeactivate === "function") {
            _this._onDeactivate(_this);
          }
          return Events.trigger({
            type: "tab_deactivate",
            node: _this.DOM
          });
        };
      })(this)
    });
    return this;
  };

  Tab.prototype.initOpts = function() {
    Tab.__super__.initOpts.call(this);
    return this.addOpts({
      name: {
        check: String
      },
      text: {
        mandatory: true,
        check: String
      },
      disabled: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      content: {
        mandatory: true,
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      onFirstActivate: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      content_placeholder: {
        check: function(v) {
          return isContent(v);
        }
      },
      load_on_show: {
        check: Boolean
      }
    });
  };

  Tab.prototype.loadContent = function() {
    return Panel.prototype.loadContent.call(this);
  };

  Tab.prototype.setContent = function(content) {
    return Panel.prototype.setContent.call(this, content, false);
  };

  Tab.prototype.appendContent = function(content) {
    return Panel.prototype.appendContent.call(this, content, false);
  };

  Tab.prototype.getText = function() {
    return this._text;
  };

  Tab.prototype.hide = function() {
    this.DOM.addClass("cui-tab-hidden");
    return this;
  };

  Tab.prototype.show = function() {
    this.DOM.removeClass("cui-tab-hidden");
    if (CUI.__ng__) {
      Events.trigger({
        type: "viewport-resize",
        node: this.DOM,
        info: {
          tab: true
        }
      });
    }
    return this;
  };

  Tab.prototype.destroy = function() {
    Events.trigger({
      type: "tab_destroy",
      node: this.DOM
    });
    this.__button.destroy();
    return Tab.__super__.destroy.call(this);
  };

  Tab.prototype.disable = function() {
    this.__button.disable();
    return this;
  };

  Tab.prototype.enable = function() {
    this.__button.enable();
    return this;
  };

  Tab.prototype.activate = function() {
    this.__button.activate();
    return this;
  };

  Tab.prototype.deactivate = function() {
    this.__button.deactivate();
    return this;
  };

  Tab.prototype.isActive = function() {
    return this.__button.isActive();
  };

  Tab.prototype.getButton = function() {
    return this.__button;
  };

  Tab.prototype.getBody = function() {
    return this.DOM;
  };

  return Tab;

})(CUI.DOM);

CUI.ready((function(_this) {
  return function() {
    Events.registerEvent({
      type: "tab_destroy"
    });
    Events.registerEvent({
      type: "tab_deactivate"
    });
    return Events.registerEvent({
      type: "tab_activate"
    });
  };
})(this));

Tab = CUI.Tab;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Tabs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tabs = (function(superClass) {
  extend(Tabs, superClass);

  function Tabs() {
    return Tabs.__super__.constructor.apply(this, arguments);
  }

  Tabs.defaults = {
    overflow_button_tooltip: null
  };

  Tabs.prototype.initOpts = function() {
    Tabs.__super__.initOpts.call(this);
    this.removeOpt("header_center");
    this.removeOpt("content");
    this.removeOpt("force_footer");
    this.removeOpt("force_header");
    return this.addOpts({
      tabs: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) && v.length > 0;
        }
      },
      active_idx: {
        check: "Integer"
      },
      appearance: {
        check: ["normal", "mini"]
      }
    });
  };

  Tabs.prototype.forceHeader = function() {
    return true;
  };

  Tabs.prototype.forceFooter = function() {
    return true;
  };

  Tabs.prototype.__checkOverflowButton = function() {
    var header_dim, ref;
    if (!this.__maximize_horizontal) {
      return;
    }
    header_dim = DOM.getDimensions(this.__header);
    if (header_dim.scrollWidth > header_dim.clientWidth) {
      this.__overflowBtn.show();
      CUI.DOM.addClass(this.__pane_header.DOM, "cui-tabs-pane-header--overflow");
      this.__dragscroll = new CUI.Dragscroll({
        element: this.__buttonbar.DOM,
        scroll_element: this.__header
      });
    } else {
      if ((ref = this.__dragscroll) != null) {
        ref.destroy();
      }
      this.__dragscroll = null;
      this.__overflowBtn.hide();
      CUI.DOM.removeClass(this.__pane_header.DOM, "cui-tabs-pane-header--overflow");
    }
    return this;
  };

  Tabs.prototype.__setActiveMarker = function() {
    var btn, btn_dim, ref;
    btn = (ref = this.getActiveTab()) != null ? ref.getButton().DOM[0] : void 0;
    if (!btn) {
      CUI.DOM.hideElement(this.__tabs_marker);
      return;
    }
    CUI.DOM.showElement(this.__tabs_marker);
    btn_dim = DOM.getDimensions(btn);
    DOM.setStyle(this.__tabs_marker, {
      left: btn_dim.offsetLeft,
      width: btn_dim.borderBoxWidth
    });
    return this;
  };

  Tabs.prototype.init = function() {
    var _tab, i, idx, len, pane_key, ref, tab;
    Tabs.__super__.init.call(this);
    this.__tabs_marker = CUI.DOM.element("DIV", {
      "class": "cui-tabs-active-marker"
    });
    this.__tabs_bodies = new Template({
      name: "tabs-bodies"
    });
    this.__pane_header.addClass("cui-tabs-pane-header");
    if (this._appearance === "mini") {
      this.__pane_header.addClass("cui-tabs-pane-header--mini");
    }
    this.__buttonbar = new Buttonbar();
    pane_key = "center";
    this.__pane_header.append(this.__buttonbar, pane_key);
    this.__pane_header.append(this.__tabs_marker, pane_key);
    this.__header = this.__pane_header[pane_key]()[0];
    Events.listen({
      type: "scroll",
      node: this.__header,
      call: (function(_this) {
        return function(ev) {
          var dim;
          dim = CUI.DOM.getDimensions(_this.__header);
          CUI.DOM.setClass(_this.__pane_header.DOM, "cui-tabs-pane-header--scroll-at-end", dim.horizontalScrollbarAtEnd);
          return CUI.DOM.setClass(_this.__pane_header.DOM, "cui-tabs-pane-header--scroll-at-start", dim.horizontalScrollbarAtStart);
        };
      })(this)
    });
    this.__overflowBtn = new Button({
      icon: "ellipsis_h",
      "class": "cui-tab-header-button-overflow",
      icon_right: false,
      size: this._appearance === "mini" ? "mini" : void 0,
      tooltip: {
        text: CUI.Tabs.defaults.overflow_button_tooltip
      },
      menu: {
        items: (function(_this) {
          return function() {
            var btns, fn, i, len, ref, tab;
            btns = [];
            ref = _this.__tabs;
            fn = function(tab) {
              return btns.push({
                text: tab.getText(),
                active: tab === _this.getActiveTab(),
                onClick: function() {
                  return tab.activate();
                }
              });
            };
            for (i = 0, len = ref.length; i < len; i++) {
              tab = ref[i];
              fn(tab);
            }
            return btns;
          };
        })(this)
      }
    });
    this.__overflowBtn.hide();
    this.__pane_header.prepend(this.__overflowBtn, "right");
    this.getLayout().append(this.__tabs_bodies, "center");
    if (this._appearance === "mini") {
      this.addClass("cui-tabs--mini");
    }
    if (!CUI.__ng__) {
      if (!this.__maximize_horizontal || !this.__maximize_vertical) {
        Events.listen({
          node: this.getLayout(),
          type: "content-resize",
          call: (function(_this) {
            return function(event, info) {
              event.stopPropagation();
              return _this.__doLayout();
            };
          })(this)
        });
      }
    }
    this.__tabs = [];
    ref = this._tabs;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      tab = ref[idx];
      if (!tab) {
        continue;
      }
      if (tab instanceof Tab) {
        _tab = this.addTab(tab);
      } else if (CUI.isPlainObject(tab)) {
        _tab = this.addTab(new Tab(tab));
      } else {
        assert(false, "new " + this.__cls, "opts.tabs[" + idx + "] must be PlainObject or Tab but is " + (getObjectClass(tab)), {
          opts: this.opts
        });
      }
      if (this._appearance === "mini") {
        _tab.getButton().setSize("mini");
      }
    }
    this.__tabs[this._active_idx || 0].activate();
    DOM.waitForDOMInsert({
      node: this.getLayout()
    }).done((function(_this) {
      return function() {
        if (_this.isDestroyed()) {
          return;
        }
        Events.listen({
          node: _this.getLayout(),
          type: "viewport-resize",
          call: function() {
            _this.__checkOverflowButton();
            return _this.__setActiveMarker();
          }
        });
        assert(DOM.isInDOM(_this.getLayout().DOM[0]), "Tabs getting DOM insert event without being in DOM.");
        _this.__checkOverflowButton();
        _this.__setActiveMarker();
        if (!CUI.__ng__) {
          return _this.__doLayout();
        }
      };
    })(this));
    this.addClass("cui-tabs");
    this.__max_width = -1;
    this.__max_height = -1;
    return this;
  };

  Tabs.prototype.setFooterRight = function(content) {
    return this.replace(content, "footer_right");
  };

  Tabs.prototype.setFooterLeft = function(content) {
    return this.replace(content, "footer_left");
  };

  Tabs.prototype.__doLayout = function() {
    if (this.__maximize_horizontal && this.__maximize_vertical) {
      return;
    }
    if (this.__measureAndSetBodyWidth()) {
      Events.trigger({
        type: "content-resize",
        node: this.DOM.parentNode
      });
    }
    return this;
  };

  Tabs.prototype.addTab = function(tab) {
    assert(tab instanceof Tab, this.__cls + ".addTab", "Tab must be instance of Tab but is " + (getObjectClass(tab)), {
      tab: tab
    });
    if (!this.hasTab(tab)) {
      this.__tabs.push(tab);
      Events.listen({
        node: tab,
        type: "tab_activate",
        call: (function(_this) {
          return function() {
            if (_this.__overflowBtn.isShown()) {
              DOM.scrollIntoView(tab.getButton().DOM[0]);
            }
            if (CUI.__ng__) {
              if (!_this._maximize_vertical) {
                DOM.setStyle(_this.__tabs[0].DOM[0], {
                  marginLeft: -100 * idxInArray(tab, _this.__tabs) + "%"
                });
              }
            }
            _this.__active_tab = tab;
            _this.__setActiveMarker();
            return DOM.setAttribute(_this.DOM[0], "active-tab-idx", idxInArray(tab, _this.__tabs));
          };
        })(this)
      });
      Events.listen({
        node: tab,
        type: "tab_deactivate",
        call: (function(_this) {
          return function() {
            _this.__active_tab = null;
            return DOM.setAttribute(_this.DOM[0], "active-tab-idx", "");
          };
        })(this)
      });
      Events.listen({
        node: tab,
        type: "tab_destroy",
        call: (function(_this) {
          return function() {
            var idx, ref;
            idx = _this.__tabs.indexOf(tab);
            removeFromArray(tab, _this.__tabs);
            idx--;
            return (ref = _this.__tabs[idx]) != null ? ref.activate() : void 0;
          };
        })(this)
      });
    }
    tab.hide();
    tab.initButton(this);
    this.__buttonbar.addButton(tab.getButton());
    this.__tabs_bodies.append(tab);
    return tab;
  };

  Tabs.prototype.__measureAndSetBodyWidth = function() {
    var dim, i, j, k, l, len, len1, len2, len3, max_height, max_width, parent, ref, ref1, ref2, ref3, scrollSaveParent, size_has_changed, tab;
    ref = this.DOM.parents();
    for (i = 0, len = ref.length; i < len; i++) {
      parent = ref[i];
      if (parent.scrollTop || parent.scrollLeft) {
        scrollSaveParent = {
          node: parent,
          top: parent.scrollTop,
          left: parent.scrollLeft
        };
        break;
      }
    }
    ref1 = this.__tabs;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      tab = ref1[j];
      tab.getBody().css({
        "min-width": "",
        height: ""
      });
    }
    this.__tabs_bodies.DOM.css({
      "min-width": "",
      height: ""
    });
    max_width = -1;
    max_height = -1;
    ref2 = this.__tabs;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      tab = ref2[k];
      dim = {
        width: tab.getBody().outerWidth(true),
        height: tab.getBody().outerHeight(true)
      };
      if (dim.width > max_width) {
        max_width = dim.width;
      }
      if (dim.height > max_height) {
        max_height = dim.height;
      }
    }
    this.__tabs_bodies.DOM.css({
      "min-width": max_width,
      height: max_height
    });
    ref3 = this.__tabs;
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      tab = ref3[l];
      tab.getBody().css({
        "min-width": max_width,
        height: max_height
      });
    }
    if (this.max_width !== this.__max_width || this.max_height !== this.__max_height) {
      this.__max_width = max_width;
      this.__max_height = max_height;
      size_has_changed = true;
    } else {
      size_has_changed = false;
    }
    if (scrollSaveParent) {
      scrollSaveParent.node.scrollTop = scrollSaveParent.top;
      scrollSaveParent.node.scrollLeft = scrollSaveParent.left;
    }
    return size_has_changed;
  };

  Tabs.prototype.hasTab = function(tab_or_idx_or_name) {
    return this.getTab(tab_or_idx_or_name);
  };

  Tabs.prototype.getTab = function(tab_or_idx_or_name) {
    var found_tab, i, len, ref, tab;
    found_tab = null;
    if (isString(tab_or_idx_or_name)) {
      ref = this.__tabs;
      for (i = 0, len = ref.length; i < len; i++) {
        tab = ref[i];
        if (tab._name === tab_or_idx_or_name) {
          found_tab = tab;
          break;
        }
      }
    } else if (tab_or_idx_or_name instanceof Tab) {
      if (this.__tabs.indexOf(tab_or_idx_or_name) > -1) {
        found_tab = tab_or_idx_or_name;
      }
    } else {
      found_tab = this.__tabs[tab_or_idx_or_name];
    }
    return found_tab;
  };

  Tabs.prototype.getActiveTab = function() {
    return this.__active_tab;
  };

  Tabs.prototype.activate = function(tab_or_idx_or_name) {
    var tab;
    tab = this.getTab(tab_or_idx_or_name);
    tab.activate();
    return this;
  };

  return Tabs;

})(CUI.SimplePane);

Tabs = CUI.Tabs;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Modal,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Modal = (function(superClass) {
  extend(Modal, superClass);

  Modal.defaults = {
    cancel_tooltip: {
      text: "Close Dialog"
    }
  };

  function Modal(opts) {
    this.opts = opts != null ? opts : {};
    Modal.__super__.constructor.call(this, this.opts);
    this.__addHeaderButton("fill_screen_button", Pane.getToggleFillScreenButton({
      tooltip: this._fill_screen_button_tooltip
    }));
    this.__addHeaderButton("cancel", {
      "class": "ez5-modal-close-button",
      icon: "close",
      tooltip: this._cancel_tooltip || CUI.Modal.defaults.cancel_tooltip,
      appearance: CUI.__ng__ ? "normal" : "flat",
      onClick: (function(_this) {
        return function(ev, btn) {
          return _this.doCancel(ev, false, btn);
        };
      })(this)
    });
  }

  Modal.prototype.initOpts = function() {
    Modal.__super__.initOpts.call(this);
    this.mergeOpt("backdrop", {
      "default": {
        policy: "modal",
        add_bounce_class: true,
        content: null
      }
    });
    this.addOpts({
      cancel: {
        check: Boolean
      },
      cancel_action: {
        "default": "destroy",
        check: ["destroy", "hide"]
      },
      cancel_tooltip: {
        check: "PlainObject"
      },
      onCancel: {
        check: Function
      },
      fill_screen_button: {
        check: Boolean
      },
      fill_screen_button_tooltip: {
        check: "PlainObject"
      },
      onToggleFillScreen: {
        check: Function
      }
    });
    return this.mergeOpt("placement", {
      "default": "c"
    });
  };

  Modal.prototype.__addHeaderButton = function(pname, _btn) {
    var btn;
    if (!this["_" + pname]) {
      return;
    }
    if (CUI.isPlainObject(_btn)) {
      btn = new CUI.defaults["class"].Button(_btn);
    } else {
      btn = _btn;
    }
    assert(btn instanceof Button, "Modal.__addHeaderButton", "Button needs to be instance of Button", {
      btn: btn
    });
    assert(this.__pane instanceof SimplePane, "new " + this.__cls, "opts." + pname + " can only be used if opts.pane is instance of SimplePane.", {
      pane: this.__pane,
      opts: this.opts
    });
    this.append(btn, "header_right");
    return this;
  };

  Modal.prototype.__runOnAllButtons = function(func) {
    var btn, el, i, len, ref;
    ref = this.__layer.DOM.find(".cui-button");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      btn = DOM.data(el, "element");
      if (btn instanceof Button) {
        btn[func]();
      }
    }
  };

  Modal.prototype.disableAllButtons = function() {
    return this.__runOnAllButtons("disable");
  };

  Modal.prototype.enableAllButtons = function() {
    return this.__runOnAllButtons("enable");
  };

  Modal.prototype.isKeyboardCancellable = function(ev) {
    if (this._cancel) {
      return true;
    } else {
      return Modal.__super__.isKeyboardCancellable.call(this, ev);
    }
  };

  Modal.prototype.doCancel = function(ev, force_callback, button) {
    var ret;
    if (force_callback == null) {
      force_callback = false;
    }
    if (button == null) {
      button = null;
    }
    if (!this._cancel && !force_callback) {
      Modal.__super__.doCancel.call(this, ev);
    } else {
      ret = typeof this._onCancel === "function" ? this._onCancel(ev, this) : void 0;
      if (isPromise(ret)) {
        if (button) {
          button.disable();
          button.startSpinner();
          ret.always((function(_this) {
            return function() {
              button.stopSpinner();
              return button.enable();
            };
          })(this));
        }
        ret.done((function(_this) {
          return function(value) {
            return _this[_this._cancel_action](ev, value);
          };
        })(this));
      } else if (ret !== false) {
        this[this._cancel_action](ev, ret);
      }
    }
  };

  Modal.prototype.empty = function(key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().empty(key);
    this.position();
    return this;
  };

  Modal.prototype.append = function(content, key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().append(content, key);
    this.position();
    return this;
  };

  Modal.prototype.replace = function(content, key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().replace(content, key);
    this.position();
    return this;
  };

  Modal.prototype.setContent = function(content) {
    this.getPane().replace(content, 'center');
    this.position();
    return this;
  };

  Modal.prototype.hide = function(ev) {
    this.getPane().endFillScreen(false);
    return Modal.__super__.hide.call(this, ev);
  };

  return Modal;

})(CUI.LayerPane);

Modal = CUI.Modal;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ConfirmationDialog = (function(superClass) {
  extend(ConfirmationDialog, superClass);

  function ConfirmationDialog(opts) {
    this.opts = opts;
    ConfirmationDialog.__super__.constructor.call(this, this.opts);
    this.__layer_root.addClass("cui-confirmation-dialog");
    this.init();
  }

  ConfirmationDialog.prototype.initOpts = function() {
    ConfirmationDialog.__super__.initOpts.call(this);
    this.addOpts({
      title: {
        check: String
      },
      text: {
        check: String
      },
      text_icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      markdown_opts: {
        check: "PlainObject"
      },
      html: {
        check: String
      },
      content: {
        check: function(v) {
          return isContent(v) || (v != null ? v.DOM : void 0);
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      buttons: {
        check: function(v) {
          return (CUI.isArray(v) && v.length > 0) || CUI.isFunction(v);
        }
      },
      footer_left: {},
      header_right: {}
    });
    return this.removeOpt("pane");
  };

  ConfirmationDialog.prototype.setPane = function() {
    return ConfirmationDialog.__super__.setPane.call(this, {
      padded: true,
      force_header: true,
      force_footer: true
    });
  };

  ConfirmationDialog.prototype.readOpts = function() {
    ConfirmationDialog.__super__.readOpts.call(this);
    return this._pane = {};
  };

  ConfirmationDialog.prototype.init = function() {
    var c, content, key, l, pane, ref;
    if (!xor(this._html, xor(this._content, this._text))) {
      console.warn(this.__cls + ".readOpts", "Exactly on opts.content, opts.text, or opts.html needs to be set", {
        opts: this.opts
      });
      this._text = "";
    }
    if (!this._title) {
      this.addClass("cui-confirmation-dialog--no-title");
    }
    if (!isEmpty(this._text)) {
      this.__label = c = new MultilineLabel({
        markdown: this._markdown,
        markdown_opts: this._markdown_opts,
        text: this._text,
        icon: this._text_icon
      });
    } else if (!isEmpty(this._html)) {
      this.__label = c = new MultilineLabel({
        content: this._html
      });
    } else {
      c = this._content;
    }
    if (!isEmpty(this._title) || !isNull(this._icon)) {
      l = new Label({
        text: this._title,
        icon: this._icon
      });
    }
    pane = this.getPane();
    ref = {
      header_left: l,
      header_right: this._header_right,
      content: c,
      footer_right: this._buttons,
      footer_left: this._footer_left
    };
    for (key in ref) {
      content = ref[key];
      if (content) {
        pane.append(content, key);
      }
    }
  };

  ConfirmationDialog.prototype.updateText = function(txt) {
    var ref;
    if ((ref = this.__label) != null) {
      ref.setText(txt);
    }
    return this;
  };

  ConfirmationDialog.prototype.setText = function(text, markdown, markdown_opts) {
    if (markdown == null) {
      markdown = this._markdown;
    }
    if (markdown_opts == null) {
      markdown_opts = this._markdown_opts;
    }
    this.__label = new MultilineLabel({
      markdown: markdown,
      markdown_opts: markdown_opts,
      text: text,
      icon: this._text_icon
    });
    return this.setContent(this.__label);
  };

  ConfirmationDialog.prototype.getButtons = function() {
    var buttons, el, els, i, key, len, pane, ref;
    ref = this.getPane().getPaneAndKey("footer_right"), pane = ref[0], key = ref[1];
    els = DOM.findElements(pane[key]()[0], ".cui-button");
    buttons = [];
    for (i = 0, len = els.length; i < len; i++) {
      el = els[i];
      buttons.push(DOM.data(el, "element"));
    }
    return buttons;
  };

  return ConfirmationDialog;

})(CUI.Modal);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ConfirmationChoice = (function(superClass) {
  extend(ConfirmationChoice, superClass);

  function ConfirmationChoice(opts1) {
    this.opts = opts1;
    this.__getResolveValue = bind(this.__getResolveValue, this);
    ConfirmationChoice.__super__.constructor.call(this, this.opts);
    this.__layer_root.addClass("cui-confirmation-choice");
  }

  ConfirmationChoice.defaults = {
    ok: "Ok",
    cancel: "Cancel"
  };

  ConfirmationChoice.prototype.initOpts = function() {
    ConfirmationChoice.__super__.initOpts.call(this);
    this.removeOpt("buttons");
    this.removeOpt("header_right");
    this.removeOpt("cancel_action");
    return this.addOpts({
      onChoice: {
        check: Function
      },
      choices: {
        mandatory: true,
        "default": [],
        check: function(v) {
          var choice, i, idx, len;
          if (!CUI.isArray(v)) {
            return false;
          }
          for (idx = i = 0, len = v.length; i < len; idx = ++i) {
            choice = v[idx];
            if (!choice) {
              continue;
            }
            CUI.Element.readOpts(choice, "new ConfirmationChoice[choice#" + idx + "]", CUI.ConfirmationChoice.choiceOpts);
          }
          return true;
        }
      }
    });
  };

  ConfirmationChoice.choiceOpts = {
    text: {
      mandatory: true,
      check: String
    },
    onClick: {
      check: Function
    },
    icon: {
      check: Icon
    },
    choice: {
      check: String
    },
    cancel: {
      "default": false,
      check: Boolean
    },
    primary: {
      mandatory: true,
      "default": false,
      check: Boolean
    },
    disabled: {
      mandatory: true,
      "default": false,
      check: Boolean
    }
  };

  ConfirmationChoice.prototype.readOpts = function() {
    ConfirmationChoice.__super__.readOpts.call(this);
    return this._cancel_action = "cancel";
  };

  ConfirmationChoice.prototype.init = function() {
    var btn_opts, choice, i, key, len, ref;
    this._buttons = [];
    ref = this._choices;
    for (i = 0, len = ref.length; i < len; i++) {
      choice = ref[i];
      if (!choice) {
        continue;
      }
      btn_opts = {
        left: true,
        value: choice,
        disabled: choice.disabled,
        onClick: (function(_this) {
          return function(ev, btn) {
            _this.__choice = btn.getValue();
            CUI.chainedCall(function() {
              var ref1, ret;
              return ret = (ref1 = _this.__choice.onClick) != null ? ref1.call(_this, ev, btn) : void 0;
            }, function() {
              var ref1;
              if (_this.__choice.cancel) {
                _this.doCancel(ev, true);
                return false;
              }
              return (ref1 = _this._onChoice) != null ? ref1.call(_this, ev, _this.__choice, _this, btn) : void 0;
            }).done(function(ret1, ret2) {
              if (ev.isImmediatePropagationStopped() || ret1 === false || ret2 === false) {
                return;
              }
              _this.__deferred.resolve(_this.__getResolveValue(), btn, ev);
              return _this.destroy();
            });
          };
        })(this)
      };
      for (key in CUI.ConfirmationChoice.choiceOpts) {
        if (key !== "onClick" && key !== "cancel" && key !== "choice") {
          btn_opts[key] = choice[key];
        }
      }
      this._buttons.push(btn_opts);
    }
    ConfirmationChoice.__super__.init.call(this);
  };

  ConfirmationChoice.prototype.__getResolveValue = function() {
    return this.__choice;
  };

  ConfirmationChoice.prototype.show = function() {
    return assert(false, "ConfirmationChoice.show", "Use .open to open the ConfirmationChoice");
  };

  ConfirmationChoice.prototype.cancel = function(ev, ret) {
    this.hide(ev);
    return this.__deferred.reject(this.__choice, ret);
  };

  ConfirmationChoice.prototype.destroy = function() {
    this.__deferred = null;
    return ConfirmationChoice.__super__.destroy.call(this);
  };

  ConfirmationChoice.prototype.open = function() {
    if (this.__deferred) {
      return this.__deferred.promise();
    }
    this.__deferred = new CUI.Deferred();
    CUI.ConfirmationDialog.prototype.show.call(this);
    this.__deferred.always((function(_this) {
      return function() {
        return _this.__deferred = null;
      };
    })(this));
    return this.__deferred.promise();
  };

  return ConfirmationChoice;

})(CUI.ConfirmationDialog);

CUI.choice = function(opts) {
  if (opts == null) {
    opts = {
      text: "CUI.ConfirmationChoice"
    };
  }
  return new CUI.ConfirmationChoice(opts).open();
};

CUI.defaults["class"].ConfirmationChoice = CUI.ConfirmationChoice;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Alert = (function(superClass) {
  extend(Alert, superClass);

  function Alert() {
    return Alert.__super__.constructor.apply(this, arguments);
  }

  Alert.prototype.initOpts = function() {
    Alert.__super__.initOpts.call(this);
    this.mergeOpt("choices", {
      mandatory: false,
      "default": void 0
    });
    return this.addOpts({
      button_text_ok: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.ok,
        check: String
      }
    });
  };

  Alert.prototype.isKeyboardCancellable = function(ev) {
    return true;
  };

  Alert.prototype.readOpts = function() {
    Alert.__super__.readOpts.call(this);
    if (!this._choices) {
      return this._choices = [
        {
          text: this._button_text_ok
        }
      ];
    }
  };

  return Alert;

})(CUI.ConfirmationChoice);

CUI.alert = function(opts) {
  if (opts == null) {
    opts = {
      text: "CUI.alert"
    };
  }
  return new CUI.Alert(opts).open();
};

CUI.AlertProblem = (function(superClass) {
  extend(AlertProblem, superClass);

  function AlertProblem() {
    return AlertProblem.__super__.constructor.apply(this, arguments);
  }

  return AlertProblem;

})(CUI.Alert);

CUI.problem = function(opts) {
  if (opts == null) {
    opts = {
      text: "CUI.problem"
    };
  }
  return new CUI.AlertProblem(opts).open();
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Toaster = (function(superClass) {
  extend(Toaster, superClass);

  function Toaster() {
    return Toaster.__super__.constructor.apply(this, arguments);
  }

  Toaster.prototype.initOpts = function() {
    Toaster.__super__.initOpts.call(this);
    this.removeOpt("choices");
    this.mergeOpt("backdrop", {
      "default": false
    });
    return this.mergeOpt("show_ms", {
      check: function(v) {
        return v >= 0;
      }
    });
  };

  Toaster.prototype.readOpts = function() {
    if (this.opts.show_ms === 0 && this.opts.backdrop === void 0) {
      this.opts.backdrop = {
        policy: "modal"
      };
    }
    Toaster.__super__.readOpts.call(this);
    return this._choices = [];
  };

  Toaster.prototype.open = function() {
    if (this.__deferred) {
      return this.__deferred.promise();
    }
    Toaster.__super__.open.call(this);
    if (this._show_ms > 0) {
      CUI.setTimeout({
        ms: this._show_ms,
        call: (function(_this) {
          return function() {
            _this.hide();
            return _this.__deferred.resolve();
          };
        })(this)
      });
    }
    return this.__deferred.promise();
  };

  return Toaster;

})(CUI.ConfirmationChoice);

CUI.toaster = function(opts) {
  var toaster;
  if (opts == null) {
    opts = {
      text: "CUI.toaster"
    };
  }
  toaster = new CUI.Toaster(opts);
  toaster.open();
  return toaster;
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Spinner = (function(superClass) {
  extend(Spinner, superClass);

  function Spinner() {
    return Spinner.__super__.constructor.apply(this, arguments);
  }

  Spinner.prototype.initOpts = function() {
    Spinner.__super__.initOpts.call(this);
    this.mergeOpt("text_icon", {
      "default": "spinner"
    });
    this.mergeOpt("show_ms", {
      "default": 0
    });
    return this.mergeOpt("backdrop", {
      "default": {
        policy: "modal"
      }
    });
  };

  Spinner.prototype.open = function() {
    Spinner.__super__.open.call(this);
    if (this._show_ms > 0) {
      CUI.setTimeout({
        ms: this._show_ms,
        call: (function(_this) {
          return function() {
            _this.hide();
            return _this.__deferred.resolve();
          };
        })(this)
      });
    }
    return this.__deferred.promise();
  };

  return Spinner;

})(CUI.Toaster);

CUI.spinner = function(opts) {
  var spinner;
  if (opts == null) {
    opts = {
      text: "CUI.spinner"
    };
  }
  spinner = new CUI.Spinner(opts);
  spinner.open();
  return spinner;
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Confirm = (function(superClass) {
  extend(Confirm, superClass);

  function Confirm() {
    return Confirm.__super__.constructor.apply(this, arguments);
  }

  Confirm.prototype.initOpts = function() {
    Confirm.__super__.initOpts.call(this);
    this.removeOpt("choices");
    this.mergeOpt("text", {
      mandatory: true
    });
    return this.addOpts({
      button_text_ok: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.ok,
        check: String
      },
      button_text_cancel: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.cancel,
        check: String
      },
      button_primary: {
        mandatory: true,
        "default": "ok",
        check: ["ok", "cancel"]
      }
    });
  };

  Confirm.prototype.readOpts = function() {
    Confirm.__super__.readOpts.call(this);
    return this._choices = [
      {
        text: this._button_text_cancel,
        cancel: true,
        choice: "cancel",
        primary: this._button_primary === "cancel"
      }, {
        text: this._button_text_ok,
        choice: "ok",
        primary: this._button_primary === "ok"
      }
    ];
  };

  return Confirm;

})(CUI.ConfirmationChoice);

CUI.confirm = function(opts) {
  return new CUI.Confirm(opts).open();
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Prompt = (function(superClass) {
  extend(Prompt, superClass);

  function Prompt() {
    this.__checkOkBtn = bind(this.__checkOkBtn, this);
    return Prompt.__super__.constructor.apply(this, arguments);
  }

  Prompt.prototype.initOpts = function() {
    Prompt.__super__.initOpts.call(this);
    this.removeOpt("choices");
    return this.addOpts({
      "default": {
        "default": "",
        check: String
      },
      placeholder: {
        check: String
      },
      min_length: {
        mandatory: true,
        "default": 1,
        check: (function(_this) {
          return function(v) {
            return v >= 0;
          };
        })(this)
      }
    });
  };

  Prompt.prototype.readOpts = function() {
    var text;
    Prompt.__super__.readOpts.call(this);
    text = this._text;
    delete this._text;
    this.__input = null;
    this.__data = {
      input: this._default + ""
    };
    return this._content = new Form({
      fields: [
        {
          type: Output,
          multiline: true,
          text: text
        }, {
          type: Input,
          name: "input",
          placeholder: this._placeholder,
          data: this.__data,
          onConstruct: (function(_this) {
            return function(__input) {
              _this.__input = __input;
            };
          })(this),
          onKeyup: (function(_this) {
            return function(inp, ev) {
              if (ev.keyCode() === 13) {
                return _this.getButtons()[1].onClickAction(ev);
              }
            };
          })(this),
          onDataChanged: (function(_this) {
            return function() {
              return _this.__checkOkBtn();
            };
          })(this)
        }
      ]
    }).start();
  };

  Prompt.prototype.getValue = function() {
    return this.__input.getValue();
  };

  Prompt.prototype.open = function() {
    var dfr;
    this.__checkOkBtn();
    dfr = new CUI.Deferred();
    Prompt.__super__.open.call(this).done((function(_this) {
      return function(choice) {
        return dfr.resolve(_this.__data.input);
      };
    })(this)).fail(dfr.reject);
    CUI.setTimeout({
      call: (function(_this) {
        return function() {
          return _this.__input.focus().selectAll();
        };
      })(this)
    });
    return dfr.promise();
  };

  Prompt.prototype.__checkOkBtn = function() {
    var buttons;
    buttons = this.getButtons();
    if (this.__data.input.trim().length >= this._min_length) {
      return buttons[1].enable();
    } else {
      return buttons[1].disable();
    }
  };

  return Prompt;

})(CUI.Confirm);

CUI.prompt = function(opts) {
  return new CUI.Prompt(opts).open();
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Popover,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Popover = (function(superClass) {
  extend(Popover, superClass);

  function Popover() {
    return Popover.__super__.constructor.apply(this, arguments);
  }

  Popover.prototype.initOpts = function() {
    Popover.__super__.initOpts.call(this);
    this.mergeOpt("placement", {
      "default": null
    });
    return this.mergeOpt("pointer", {
      "default": "arrow"
    });
  };

  Popover.prototype.readOpts = function() {
    var ref;
    Popover.__super__.readOpts.call(this);
    if (!((ref = this.opts.backdrop) != null ? ref.policy : void 0)) {
      return this._backdrop.policy = "click-thru";
    }
  };

  Popover.prototype.knownPlacements = ["s", "e", "w", "ws", "wn", "n", "se", "ne", "es", "en", "nw", "sw"];

  return Popover;

})(CUI.Modal);

Popover = CUI.Popover;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Tooltip,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tooltip = (function(superClass) {
  extend(Tooltip, superClass);

  function Tooltip(opts) {
    this.opts = opts != null ? opts : {};
    Tooltip.__super__.constructor.call(this, this.opts);
    assert(xor(this._text, this._content), "new " + this.__cls, "One of opts.text or opts.content must be set.", {
      opts: this.opts
    });
    if (!CUI.isFunction(this._text) && !CUI.isFunction(this._content)) {
      this.__static = true;
      this.fillContent();
    } else {
      this.__static = false;
    }
    this.__dummyInst = new CUI.Dummy();
    if (this._on_hover) {
      assert(this.__element, "Element not set in Tooltip.");
      Events.listen({
        type: "mouseenter",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (window.globalDrag) {
              return;
            }
            if (_this._on_hover === true || _this._on_hover(_this)) {
              _this.showTimeout(null, ev);
            }
          };
        })(this)
      });
      Events.listen({
        type: "mouseleave",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (window.globalDrag) {
              _this.hide(ev);
            } else {
              _this.hideTimeout(null, ev);
            }
          };
        })(this)
      });
      this.__element.addClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-hover");
      return;
    }
    if (this._on_click) {
      this.__element.addClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-click");
      Events.listen({
        type: "click",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (ev.hasModifierKey()) {
              return;
            }
            _this.show();
          };
        })(this)
      });
    }
  }

  Tooltip.prototype.initOpts = function() {
    Tooltip.__super__.initOpts.call(this);
    this.addOpts({
      text: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v);
        }
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      content: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v) || isElement(v) || CUI.isArray(v) || isElement(v != null ? v.DOM : void 0);
        }
      },
      on_click: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      on_hover: {
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      }
    });
  };

  Tooltip.prototype.readOpts = function() {
    if (!this.opts.hasOwnProperty("on_hover")) {
      this.opts.on_hover = !this.opts.on_click;
    }
    if (this.opts.on_click) {
      if (!this.opts.backdrop) {
        this.opts.backdrop = {};
      }
      if (!this.opts.backdrop.policy) {
        this.opts.backdrop.policy = "click";
      }
    }
    if (isUndef(this.opts.backdrop)) {
      this.opts.backdrop = false;
    }
    this.opts.pointer = "arrow";
    this.opts.check_for_element = true;
    this.opts.placement = this.opts.placement || "n";
    Tooltip.__super__.readOpts.call(this);
    assert(!(this._on_click && this._on_hover), "new Tooltip", "opts.on_click and opts.on_hover cannot be used together.", {
      opts: this.opts
    });
    return this;
  };

  Tooltip.current = null;

  Tooltip.prototype.focusOnHide = function(ev) {};

  Tooltip.prototype.focusOnShow = function(ev) {};

  Tooltip.prototype.showTimeout = function(ms, ev) {
    if (ms == null) {
      ms = this._show_ms;
    }
    if (CUI.Tooltip.current) {
      this.show(ev);
      return CUI.resolvedPromise();
    } else {
      CUI.Tooltip.current = this;
      return Tooltip.__super__.showTimeout.call(this, ms, ev);
    }
  };

  Tooltip.prototype.hideTimeout = function(ms, ev) {
    if (ms == null) {
      ms = this._show_ms;
    }
    CUI.Tooltip.current = null;
    return Tooltip.__super__.hideTimeout.call(this, ev);
  };

  Tooltip.prototype.hide = function(ev) {
    CUI.Tooltip.current = null;
    return Tooltip.__super__.hide.call(this, ev);
  };

  Tooltip.prototype.show = function(ev) {
    if (CUI.Tooltip.current && CUI.Tooltip.current !== this) {
      CUI.Tooltip.current.hide(ev);
    }
    CUI.Tooltip.current = this;
    if (this.__static) {
      Tooltip.__super__.show.call(this, ev);
    } else {
      this.fillContent().done((function(_this) {
        return function() {
          return Tooltip.__super__.show.call(_this, ev);
        };
      })(this));
    }
    return this;
  };

  Tooltip.prototype.getElementOpenClass = function() {
    return null;
  };

  Tooltip.prototype.fillContent = function() {
    var dfr, fill_content, fill_text, ret;
    dfr = new CUI.Deferred();
    dfr.fail((function(_this) {
      return function() {
        if (!_this.__pane.isDestroyed()) {
          return _this.__pane.empty("center");
        }
      };
    })(this));
    fill_text = (function(_this) {
      return function(text) {
        if (isEmpty(text)) {
          return dfr.reject();
        }
        return fill_content(new Label({
          markdown: _this._markdown,
          text: text,
          multiline: true
        }));
      };
    })(this);
    fill_content = (function(_this) {
      return function(content) {
        if (!content || _this.__pane.isDestroyed()) {
          return dfr.reject();
        }
        _this.__pane.replace(content, "center");
        return dfr.resolve();
      };
    })(this);
    if (CUI.isFunction(this._text)) {
      ret = this._text.call(this, this);
      if (isPromise(ret)) {
        ret.done(function(text) {
          return fill_text(text);
        });
        ret.fail(function() {
          return dfr.reject();
        });
      } else {
        fill_text(ret);
      }
    } else if (CUI.isFunction(this._content)) {
      ret = this._content.call(this, this);
      if (isPromise(ret)) {
        ret.done(function(text) {
          return fill_content(text);
        });
        ret.fail(function(xhr) {
          return dfr.reject(xhr);
        });
      } else {
        fill_content(ret);
      }
    } else if (!isEmpty(this._text)) {
      fill_text(this._text);
    } else {
      fill_content(this._content);
    }
    return dfr.promise();
  };

  Tooltip.prototype.preventOverflow = function() {
    Tooltip.__super__.preventOverflow.call(this);
    return this.DOM.width(this.__layer_dim._css_width);
  };

  Tooltip.prototype.resetLayer = function() {
    Tooltip.__super__.resetLayer.call(this);
    return this.DOM.css("max-width", this.__viewport.width / 2);
  };

  Tooltip.prototype.destroy = function() {
    Events.ignore({
      instance: this.__dummyInst
    });
    Tooltip.__super__.destroy.call(this);
    return this.__element.removeClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-hover cui-dom-element-has-tooltip-on-click");
  };

  return Tooltip;

})(CUI.LayerPane);

Tooltip = CUI.Tooltip;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListView,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.ListView = (function(superClass) {
  extend(ListView, superClass);

  ListView.defaults = {
    row_move_handle_tooltip: "Drag to move row"
  };

  function ListView(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    ListView.__super__.constructor.call(this, this.opts);
    this.initListView();
  }

  ListView.prototype.initListView = function() {
    var col, col_i, j, k, len, len1, ref, ref1;
    this.fixedColsCount = this._fixedCols;
    this.fixedRowsCount = this._fixedRows;
    this.__cols = this._cols.slice(0);
    if (this._colClasses) {
      this.__colClasses = this._colClasses.slice(0);
    }
    if (this._rowMove) {
      assert(!this._rowMovePlaceholder, "new ListView", "opts.rowMove cannot be used with opts.rowMovePlaceholder", {
        opts: this.opts
      });
    }
    if (this._rowMove || this._rowMovePlaceholder) {
      this.__cols.splice(0, 0, "fixed");
      if (!this.__colClasses) {
        this.__colClasses = [];
      }
      this.__colClasses.splice(0, 0, "cui-lv-row-move-handle-column");
    }
    assert(this.fixedColsCount < this.__cols.length, "new ListView", "opts.fixedCols must be less than column count.", {
      opts: this.opts
    });
    if (this._colResize) {
      this.__colResize = true;
    } else if (this.fixedRowsCount > 0 && this._colResize === void 0) {
      this.__colResize = true;
    }
    if (this.__colResize) {
      assert(this.fixedRowsCount > 0, "new ListView", "Cannot enable col resize with no fixed rows.", {
        opts: this.opts
      });
    }
    this.__maxCols = [];
    ref = this.__cols;
    for (col_i = j = 0, len1 = ref.length; j < len1; col_i = ++j) {
      col = ref[col_i];
      assert(col === "auto" || col === "maximize" || col === "fixed" || col === "manual", "new " + this.__cls, "Unkown type of col: \"" + col + "\". opts.cols can only contain \"auto\" and \"maximize\" elements.");
      if (col === "maximize") {
        assert(col_i >= this.fixedColsCount, "new ListView", "maximized columns can only be in the non-fixed side of the ListView.", {
          opts: this.opts
        });
        this.__maxCols.push(col_i);
      }
    }
    if (this.__maximize_horizontal && this.__maxCols.length === 0) {
      len = this.__cols.length - 1;
      if (len >= this.fixedColsCount) {
        this.__maxCols.push(len);
        this.__cols[len] = 'maximize';
      }
    }
    this.rowsCount = 0;
    this.colsCount = this.__cols.length;
    this.listViewCounter = ListView.counter++;
    this.__manualColWidths = [];
    this.__colspanRows = {};
    this.colsOrder = [];
    for (col_i = k = 0, ref1 = this.colsCount; 0 <= ref1 ? k < ref1 : k > ref1; col_i = 0 <= ref1 ? ++k : --k) {
      this.colsOrder.push(col_i);
    }
    this.rowsOrder = [];
    this.__maxRowIdx = -1;
    this.__resetCellDims();
    this.__cells = [];
    this.__rows = [];
    this.__lvClass = "cui-lv-" + this.listViewCounter;
    this.__deferredRows = [];
    this.__isInDOM = false;
    this.__doLayoutBound = (function(_this) {
      return function() {
        return _this.__doLayout();
      };
    })(this);
    return this.addClass("cui-list-view");
  };

  ListView.prototype.initOpts = function() {
    ListView.__super__.initOpts.call(this);
    return this.addOpts({
      colClasses: {
        check: "Array"
      },
      cols: {
        mandatory: true,
        check: "Array"
      },
      fixedCols: {
        "default": 0,
        check: "Integer"
      },
      fixedRows: {
        "default": 0,
        check: "Integer"
      },
      rowMove: {
        "default": false,
        check: Boolean
      },
      rowMoveFixedRows: {
        "default": 0,
        check: "Integer"
      },
      rowMovePlaceholder: {
        "default": false,
        check: Boolean
      },
      colResize: {
        check: Boolean
      },
      selectableRows: {
        check: function(v) {
          return v === false || v === true || v === "multiple";
        }
      },
      onSelect: {
        check: Function
      },
      onDeselect: {
        check: Function
      },
      onRowMove: {
        check: Function
      },
      onScroll: {
        check: Function
      },
      header: {
        deprecated: true
      },
      footer: {
        deprecated: true
      }
    });
  };

  ListView.prototype.readOpts = function() {
    if (this.opts.header) {
      this.opts.header_center = this.opts.header;
    }
    if (this.opts.footer) {
      this.opts.footer_left = this.opts.footer;
    }
    ListView.__super__.readOpts.call(this);
    this.__selectableRows = this._selectableRows;
    return this;
  };

  ListView.prototype.destroy = function() {
    var ref;
    delete this.colsOrder;
    delete this.rowsOrder;
    delete this.__fillRowQ3;
    this.__isInDOM = null;
    CUI.scheduleCallbackCancel({
      call: this.__doLayoutBound
    });
    if ((ref = this.listViewTemplate) != null) {
      ref.destroy();
    }
    this.__layoutIsStopped = false;
    ListView.__super__.destroy.call(this);
    return this;
  };

  ListView.prototype.getListViewClass = function() {
    return this.__lvClass;
  };

  ListView.prototype.getGrid = function() {
    return this.grid;
  };

  ListView.prototype.hasResizableColumns = function() {
    return this.__colResize;
  };

  ListView.prototype.hasMovableRows = function() {
    return this._rowMove;
  };

  ListView.prototype.isInactive = function() {
    return !!this.__inactive;
  };

  ListView.prototype.setInactive = function(inactive, addClass) {
    var ref;
    if (addClass == null) {
      addClass = "inactive";
    }
    this.__inactive = !!inactive;
    if (this.grid) {
      if (this.__inactive) {
        this.grid.addClass(addClass);
        this.__inactiveWaitBlock = new WaitBlock({
          element: this.grid,
          inactive: true
        }).show();
      } else {
        if ((ref = this.__inactiveWaitBlock) != null) {
          ref.destroy();
        }
        this.__inactiveWaitBlock = null;
        this.grid.removeClass(addClass);
      }
    }
    return this;
  };

  ListView.prototype.render = function() {
    var add_quadrant, cls, col, html, j, on_scroll, outer, ref, selector;
    assert(!this.grid, "ListView.render", "ListView already rendered", {
      opts: this.opts
    });
    html = [];
    cls = ["cui-list-view-grid", this.__lvClass];
    if (this._fixedCols === 1 && (this._rowMove || this._rowMovePlaceholder)) {
      cls.push("cui-list-view-grid-fixed-col-has-only-row-move-handle");
    }
    if (this._rowMovePlaceholder) {
      cls.push("cui-list-view-has-row-move-placeholder");
    }
    if (this._rowMove) {
      cls.push("cui-list-view-has-row-move");
    }
    if (this.__maxCols.length > 0) {
      cls.push("cui-list-view-grid-has-maximized-columns");
    }
    if (this.fixedColsCount > 0) {
      cls.push("cui-list-view-grid-has-fixed-cols");
    }
    if (this.fixedRowsCount > 0) {
      cls.push("cui-list-view-grid-has-fixed-rows");
    }
    html.push("<div class=\"");
    html.push(cls.join(" "));
    html.push("\">");
    html.push("<style></style>");
    add_quadrant = (function(_this) {
      return function(qi) {
        var col_i, ft, j, ref, ref1;
        html.push("<div cui-lv-quadrant=\"" + qi + "\" class=\"cui-drag-scroll cui-list-view-grid-quadrant cui-lv-tbody cui-list-view-grid-quadrant-" + qi + " " + _this.__lvClass + "-quadrant\">");
        if (qi === 2 || qi === 3) {
          html.push("<div class=\"cui-lv-tr-fill-outer\"><div class=\"cui-lv-tr\">");
          ft = _this.__getColsFromAndTo(qi);
          for (col_i = j = ref = ft.from, ref1 = ft.to; j <= ref1; col_i = j += 1) {
            cls = _this.__getColClass(col_i);
            html.push("<div class=\"" + cls + " cui-lv-td cui-lv-td-fill cui-list-view-grid-fill-col-" + col_i + "\"></div>");
          }
          html.push("</div></div>");
        }
        html.push("</div>");
      };
    })(this);
    if (this.fixedColsCount > 0 && this.fixedRowsCount > 0) {
      html.push("<div class=\"cui-list-view-grid-inner-top\">");
      add_quadrant(0);
      add_quadrant(1);
      html.push("</div>");
      html.push("<div class=\"cui-list-view-grid-inner-bottom\">");
      add_quadrant(2);
      add_quadrant(3);
      html.push("</div>");
    } else if (this.fixedColsCount > 0) {
      html.push("<div class=\"cui-list-view-grid-inner-bottom\">");
      add_quadrant(2);
      add_quadrant(3);
      html.push("</div>");
    } else if (this.fixedRowsCount > 0) {
      html.push("<div class=\"cui-list-view-grid-inner-top\">");
      add_quadrant(1);
      html.push("</div>");
      html.push("<div class=\"cui-list-view-grid-inner-bottom\">");
      add_quadrant(3);
      html.push("</div>");
    } else {
      add_quadrant(3);
    }
    html.push("</div>");
    outer = this.center()[0];
    outer.innerHTML = html.join("");
    this.grid = $(outer.firstChild);
    this.quadrant = [CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-0")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-1")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-2")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-3")[0]];
    this.styleElement = CUI.DOM.matchSelector(outer, "style")[0];
    this.__fillRowQ3 = CUI.DOM.matchSelector(this.grid[0], ".cui-list-view-grid-fills-3")[0];
    this.__topQuadrants = $(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-inner-top")[0]);
    if (this.fixedColsCount === 0 && this.fixedRowsCount === 0) {
      this.__bottomQuadrants = this.quadrant[3];
    } else {
      this.__bottomQuadrants = $(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-inner-bottom")[0]);
    }
    this.__fillCells = [];
    for (col = j = 0, ref = this.colsCount - 1; j <= ref; col = j += 1) {
      this.__fillCells.push(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-fill-col-" + col)[0]);
    }
    on_scroll = (function(_this) {
      return function() {
        _this.__syncScrolling();
        return typeof _this._onScroll === "function" ? _this._onScroll() : void 0;
      };
    })(this);
    Events.listen({
      node: this.quadrant[3],
      type: "scroll",
      call: on_scroll
    });
    this.__currentScroll = {
      top: 0,
      left: 0
    };
    if (this.hasSelectableRows()) {
      selector = "." + this.__lvClass + "-quadrant > .cui-lv-tr-outer";
      Events.listen({
        type: ["click"],
        node: this.DOM,
        selector: selector,
        call: (function(_this) {
          return function(ev) {
            var ret, row;
            row = DOM.data(ev.getCurrentTarget(), "listViewRow");
            if (!row.isSelectable()) {
              return;
            }
            ev.stopImmediatePropagation();
            ret = _this.selectRow(ev, row);
          };
        })(this)
      });
    }
    if (this.quadrant[2]) {
      Events.listen({
        type: "wheel",
        node: this.quadrant[2],
        call: (function(_this) {
          return function(ev) {
            var scroll_delta;
            scroll_delta = 100;
            if (ev.wheelDeltaY() > 0) {
              if (_this.quadrant[3].scrollTop === (_this.quadrant[3].scrollHeight - _this.quadrant[3].offsetHeight)) {
                return;
              }
              _this.quadrant[3].scrollTop += scroll_delta;
            } else if (ev.wheelDeltaY() < 0) {
              if (_this.quadrant[3].scrollTop === 0) {
                return;
              }
              _this.quadrant[3].scrollTop -= scroll_delta;
            } else {
              return;
            }
            ev.preventDefault();
            on_scroll();
          };
        })(this)
      });
    }
    Events.listen({
      type: "viewport-resize",
      node: this.grid,
      call: (function(_this) {
        return function(ev, info) {
          if (!_this.__hasLayout) {
            return;
          }
          _this.__doLayout({
            resetRows: !!(info.css_load || info.tab)
          });
        };
      })(this)
    });
    Events.listen({
      type: "content-resize",
      node: this.DOM,
      call: (function(_this) {
        return function(ev, info) {
          var cell, row;
          if (!_this.__isInDOM) {
            return;
          }
          cell = DOM.closest(ev.getNode(), ".cui-lv-td");
          if (!cell) {
            return;
          }
          ev.stopPropagation();
          row = parseInt(cell.getAttribute("row"));
          col = parseInt(cell.getAttribute("col"));
          if (_this.fixedColsCount > 0 && DOM.getAttribute(cell.parentNode, "cui-lv-tr-unmeasured")) {
            return;
          }
          _this.__resetRowDim(row);
          _this.__scheduleLayout();
        };
      })(this)
    });
    if (CUI.defaults.debug) {
      this.__addDebugControl();
    }
    if (this.isInactive()) {
      this.setInactive(true);
    }
    this.appendDeferredRows();
    DOM.waitForDOMInsert({
      node: this.DOM
    }).done((function(_this) {
      return function() {
        _this.__isInDOM = true;
        return _this.__doLayout();
      };
    })(this));
    return this.DOM;
  };

  ListView.prototype.__getScrolling = function() {
    var dim;
    dim = {
      top: this.quadrant[3].scrollTop,
      left: this.quadrant[3].scrollLeft,
      height: this.quadrant[3].scrollHeight
    };
    return dim;
  };

  ListView.prototype.getScrollingContainer = function() {
    return this.quadrant[3];
  };

  ListView.prototype.__setScrolling = function(scroll) {
    this.quadrant[3].scrollTop = scroll.top;
    return this.quadrant[3].scrollLeft = scroll.left;
  };

  ListView.prototype.__syncScrolling = function() {
    this.__currentScroll = this.__getScrolling();
    if (this.fixedColsCount > 0) {
      this.quadrant[2].scrollTop = this.__currentScroll.top;
    }
    if (this.fixedRowsCount > 0) {
      this.quadrant[1].scrollLeft = this.__currentScroll.left;
    }
    if (this.__fillRowQ3) {
      this.__fillRowQ3.style.width = "";
      this.__fillRowQ3.style.width = this.__getValue(this.__fillRowQ3.scrollWidth);
    }
    return this;
  };

  ListView.prototype.__setMargins = function() {
    var height, ref, ref1, width;
    width = this.quadrant[3].offsetWidth - this.quadrant[3].clientWidth;
    height = this.quadrant[3].offsetHeight - this.quadrant[3].clientHeight;
    if ((ref = this.quadrant[1]) != null) {
      ref.style.marginRight = this.__getValue(width);
    }
    if ((ref1 = this.quadrant[2]) != null) {
      ref1.style.marginBottom = this.__getValue(height);
    }
    return this;
  };

  ListView.prototype.getSelectedRows = function() {
    var j, len1, listViewRow, ref, row_i, sel_rows;
    sel_rows = [];
    ref = this.rowsOrder;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row_i = ref[j];
      listViewRow = this.getListViewRow(row_i);
      if (listViewRow.isSelected()) {
        sel_rows.push(listViewRow);
      }
    }
    return sel_rows;
  };

  ListView.prototype.hasSelectableRows = function() {
    return !!this.__selectableRows;
  };

  ListView.prototype.selectRowById = function(row_id) {
    return this.selectRow(null, this.getListViewRow(row_id), true);
  };

  ListView.prototype.selectRowByDisplayIdx = function(row_display_idx) {
    return this.selectRowById(this.getRowIdx(row_display_idx));
  };

  ListView.prototype.selectRow = function(ev, row, no_deselect) {
    var _row, dfr, do_select, j, len1, promises, ref, ret;
    if (no_deselect == null) {
      no_deselect = false;
    }
    assert(isNull(row) || row instanceof ListViewRow, this.__cls + ".setSelectedRow", "Parameter needs to be instance of ListViewRow.", {
      selectedRow: row
    });
    dfr = new CUI.Deferred();
    do_select = (function(_this) {
      return function() {
        if (row.isSelected()) {
          if (!no_deselect) {
            row.deselect(ev, row).done(dfr.resolve).fail(dfr.reject);
          } else {
            dfr.resolve();
          }
        } else {
          row.select(ev).done(dfr.resolve).fail(dfr.reject);
        }
      };
    })(this);
    if (this.__selectableRows === true) {
      promises = [];
      ref = this.getSelectedRows();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        _row = ref[j];
        if (row === _row) {
          continue;
        }
        ret = _row.deselect(ev, row);
        if (isPromise(ret)) {
          promises.push(ret);
        }
      }
      CUI.when(promises).done(do_select).fail(dfr.reject);
    } else {
      do_select();
    }
    return dfr.promise();
  };

  ListView.prototype.getCellByTarget = function($target) {
    var cell;
    if ($target.is(".cui-lv-td")) {
      cell = {
        col_i: parseInt($target.attr("col")),
        row_i: parseInt($target.attr("row"))
      };
      cell.display_col_i = this.getDisplayColIdx(cell.col_i);
      cell.display_row_i = this.getDisplayRowIdx(cell.row_i);
      return cell;
    } else {
      return null;
    }
  };

  ListView.prototype.getRowMoveTool = function(opts) {
    if (opts == null) {
      opts = {};
    }
    return new CUI.ListViewRowMove(opts);
  };

  ListView.prototype.getListViewRow = function(row_i) {
    return DOM.data(this.getRow(row_i)[0], "listViewRow");
  };

  ListView.prototype.getDisplayColIdx = function(col_i) {
    return this.colsOrder.indexOf(parseInt(col_i));
  };

  ListView.prototype.getDisplayRowIdx = function(row_i) {
    return this.rowsOrder.indexOf(parseInt(row_i));
  };

  ListView.prototype.getColIdx = function(display_col_i) {
    assert(CUI.isArray(this.colsOrder), "ListView[" + this.listViewCounter + "].getColIdx", "colsOrder Array is missing", {
      "this": this,
      display_col_i: display_col_i
    });
    return this.colsOrder[display_col_i];
  };

  ListView.prototype.getRowIdx = function(display_row_i) {
    return this.rowsOrder[display_row_i];
  };

  ListView.prototype.moveInOrderArray = function(from_i, to_i, array, after) {
    var display_from_i, display_to_i;
    display_from_i = array.indexOf(from_i);
    display_to_i = array.indexOf(to_i);
    moveInArray(display_from_i, display_to_i, array, after);
    return null;
  };

  ListView.prototype.moveRow = function(from_i, to_i, after, trigger_row_moved) {
    var display_from_i, display_to_i, func, idx, j, len1, ref, row;
    if (after == null) {
      after = false;
    }
    if (trigger_row_moved == null) {
      trigger_row_moved = true;
    }
    assert(from_i >= this.fixedRowsCount && to_i >= this.fixedRowsCount, "ListView.moveRow", "from_i and to_i must not be in flexible area of the list view", {
      from_i: from_i,
      to_i: to_i,
      fixed_i: this.fixedRowsCount
    });
    if (after) {
      func = "after";
    } else {
      func = "before";
    }
    ref = this.getRow(from_i);
    for (idx = j = 0, len1 = ref.length; j < len1; idx = ++j) {
      row = ref[idx];
      $(this.getRow(to_i)[idx])[func](row);
    }
    display_from_i = this.getDisplayRowIdx(from_i);
    display_to_i = this.getDisplayRowIdx(to_i);
    this.moveInOrderArray(from_i, to_i, this.rowsOrder, after);
    if (typeof this._onRowMove === "function") {
      this._onRowMove(display_from_i, display_to_i, after);
    }
    if (trigger_row_moved) {
      Events.trigger({
        type: "row_moved",
        node: this.grid,
        info: {
          from_i: from_i,
          to_i: to_i,
          display_from_i: display_from_i,
          display_to_i: display_to_i,
          after: after
        }
      });
    }
    return this;
  };

  ListView.prototype.rowAddClass = function(row_i, cls) {
    var j, len1, row, rows;
    rows = this.getRow(row_i);
    if (!rows) {
      return;
    }
    for (j = 0, len1 = rows.length; j < len1; j++) {
      row = rows[j];
      DOM.addClass(row, cls);
    }
    return this;
  };

  ListView.prototype.rowRemoveClass = function(row_i, cls) {
    var j, len1, row, rows;
    rows = this.getRow(row_i);
    if (!rows) {
      return;
    }
    for (j = 0, len1 = rows.length; j < len1; j++) {
      row = rows[j];
      DOM.removeClass(row, cls);
    }
    return this;
  };

  ListView.prototype.getColdef = function(col_i) {
    return this.__cols[col_i];
  };

  ListView.prototype.getColsCount = function() {
    return this.colsCount;
  };

  ListView.prototype.resetColWidth = function(col_i) {
    delete this.__manualColWidths[col_i];
    this.__resetColWidth(col_i);
    this.__doLayout({
      resetRows: true
    });
    return this;
  };

  ListView.prototype.setColWidth = function(col_i, width) {
    this.__manualColWidths[col_i] = Math.max(5, width);
    delete this.__colWidths[col_i];
    this.__doLayout({
      resetRows: true
    });
    return this;
  };

  ListView.prototype.getManualColWidth = function(col_i) {
    return this.__manualColWidths[col_i];
  };

  ListView.prototype.getRowHeight = function(row_i) {
    return this.__rows[row_i][0].offsetHeight;
  };

  ListView.prototype.getColWidth = function(col_i) {
    return this.__colWidths[col_i];
  };

  ListView.prototype.getCellGridRect = function(row_i, col_i) {
    var cell, dim, pos_grid, rect, ref;
    cell = (ref = this.__cells[row_i]) != null ? ref[col_i] : void 0;
    if (!cell) {
      return null;
    }
    pos_grid = this.grid.offset();
    dim = CUI.DOM.getDimensions(cell);
    rect = {
      left_abs: dim.clientBoundingRect.left,
      top_abs: dim.clientBoundingRect.top,
      left: dim.clientBoundingRect.left - pos_grid.left,
      top: dim.clientBoundingRect.top - pos_grid.top,
      width: dim.borderBoxWidth,
      height: dim.borderBoxHeight,
      contentWidthAdjust: dim.contentWidthAdjust,
      contentHeightAdjust: dim.contentHeightAdjust
    };
    return rect;
  };

  ListView.prototype.getRowGridRect = function(row_i) {
    var _pos_grid, _rect, dim, j, len1, rect, ref, row;
    _rect = {
      width: 0
    };
    ref = this.__rows[row_i];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row = ref[j];
      dim = CUI.DOM.getDimensions(row);
      _rect.width = _rect.width + dim.borderBoxWidth;
      if (!_rect.hasOwnProperty("height")) {
        _rect.height = dim.borderBoxHeight;
        _rect.top = dim.clientBoundingRect.top;
      }
      if (!_rect.hasOwnProperty("left")) {
        _rect.left = dim.clientBoundingRect.left;
      }
    }
    _pos_grid = this.grid.offset();
    rect = {
      left_abs: _rect.left,
      top_abs: _rect.top,
      left: _rect.left - _pos_grid.left,
      top: _rect.top - _pos_grid.top,
      height: _rect.height
    };
    rect.width = this.getGrid().width();
    return rect;
  };

  ListView.prototype.appendRow = function(row, _defer) {
    if (_defer == null) {
      _defer = !this.grid;
    }
    if (_defer) {
      return this.__deferRow(row);
    } else {
      return this.appendRows([row]);
    }
  };

  ListView.prototype.prependRow = function(row) {
    var row_i;
    assert(!this.isDestroyed(), "ListView.prependRow", "ListView " + this.listViewCounter + " is already destroyed.");
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(0, 0, row_i);
    return this.__addRow(row_i, row, "prepend");
  };

  ListView.prototype.replaceRow = function(row_i, row) {
    return this.__addRow(row_i, row, "replace");
  };

  ListView.prototype.insertRowAt = function(display_row_i, row) {
    assert(!this.isDestroyed(), "ListView.insertRowAfter", "ListView " + this.listViewCounter + " is already destroyed.");
    if (display_row_i === this.rowsCount || this.rowsCount === 0) {
      return this.appendRow(row);
    } else if (display_row_i === 0) {
      return this.prependRow(row);
    } else {
      return this.insertRowBefore(this.getRowIdx(display_row_i), row);
    }
  };

  ListView.prototype.insertRowAfter = function(sibling_row_i, row) {
    var row_i, sibling_display_row_i;
    assert(!this.isDestroyed(), "ListView.insertRowAfter", "ListView #" + this.listViewCounter + " is already destroyed.");
    sibling_display_row_i = this.getDisplayRowIdx(sibling_row_i);
    assert(sibling_display_row_i > -1, "ListView.insertRowAfter", "ListView #" + this.listViewCounter + ": Row " + sibling_row_i + " not found.", {
      row_i: sibling_row_i,
      row: row,
      rowsCount: this.rowsCount
    });
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(sibling_display_row_i + 1, 0, row_i);
    return this.__addRow(row_i, row, "after", sibling_row_i);
  };

  ListView.prototype.insertRowBefore = function(sibling_row_i, row) {
    var before_row_i, row_i, sibling_display_row_i;
    assert(!this.isDestroyed(), "ListView.insertRowBefore", "ListView #" + this.listViewCounter + " is already destroyed.");
    sibling_display_row_i = this.getDisplayRowIdx(sibling_row_i);
    if (sibling_display_row_i === 0) {
      return this.prependRow(row);
    }
    before_row_i = this.getRowIdx(sibling_display_row_i - 1);
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(sibling_display_row_i, 0, row_i);
    return this.__addRow(row_i, row, "after", before_row_i);
  };

  ListView.prototype.removeAllRows = function() {
    var j, len1, ref, row_i;
    ref = this.rowsOrder.slice(0);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row_i = ref[j];
      this.removeRow(row_i);
    }
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.removeDeferredRow = function(listViewRow) {
    var count;
    count = removeFromArray(listViewRow, this.__deferredRows);
    assert(count === 1, "ListView.removeListViewRow", "row not found", {
      listViewRow: listViewRow
    });
    return this;
  };

  ListView.prototype.removeRow = function(row_i) {
    var display_row_i, j, len1, ref, row;
    assert(row_i !== null && row_i >= 0, "ListView.removeRow", "row_i must be >= 0", {
      row_i: row_i
    });
    display_row_i = this.getDisplayRowIdx(row_i);
    assert(display_row_i > -1, "ListView.removeRow", "display_row_id not found for row_i", {
      row_i: row_i
    });
    this.rowsOrder.splice(display_row_i, 1);
    this.rowsCount--;
    delete this.__colspanRows[row_i];
    ref = this.getRow(row_i);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row = ref[j];
      DOM.remove(jQuery(row));
    }
    delete this.__rows[row_i];
    this.__resetRowDim(row_i);
    delete this.__cells[row_i];
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.appendDeferredRows = function() {
    if (this.__deferredRows.length) {
      this.appendRows(this.__deferredRows);
      this.__deferredRows = [];
    }
    return this;
  };

  ListView.prototype.getRow = function(row_i) {
    return this.__rows[row_i];
  };

  ListView.prototype.getBottom = function() {
    return this.__bottomQuadrants;
  };

  ListView.prototype.getTop = function() {
    return this.__topQuadrants;
  };

  ListView.prototype.__scheduleLayout = function() {
    if (!this.__isInDOM) {
      return;
    }
    if (this.layoutIsStopped()) {
      this.__layoutAfterStart = true;
      return;
    }
    CUI.scheduleCallback({
      ms: 10,
      call: this.__doLayoutBound
    });
    return this;
  };

  ListView.prototype.layoutIsStopped = function() {
    return this.__layoutIsStopped;
  };

  ListView.prototype.stopLayout = function() {
    if (this.__layoutIsStopped) {
      return false;
    } else {
      this.__layoutIsStopped = true;
      return true;
    }
  };

  ListView.prototype.startLayout = function() {
    if (this.__layoutAfterStart) {
      this.__layoutAfterStart = false;
      this.__doLayout();
    }
    this.__layoutIsStopped = null;
    return this;
  };

  ListView.prototype.__doLayout = function(opts) {
    var add_css, cell, col_i, colspan, css, dim, display_col_i, fc, has_manually_sized_column, has_max_cols, i, idx, j, k, l, len1, len2, len3, len4, len5, len6, m, manual_col_width, n, o, p, qi, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, row, row_i, row_i2, row_info, rows, sel, width;
    if (opts == null) {
      opts = {};
    }
    css = [];
    add_css = (function(_this) {
      return function(col_i, width) {
        return css.push("." + _this.__lvClass + "-cell[col=\"" + col_i + ("\"] { width: " + width + "px !important; flex: 0 0 auto !important;}"));
      };
    })(this);
    has_max_cols = false;
    has_manually_sized_column = false;
    this.__colWidths = [];
    ref = this.__fillCells;
    for (display_col_i = j = 0, len1 = ref.length; j < len1; display_col_i = ++j) {
      fc = ref[display_col_i];
      col_i = this.getColIdx(display_col_i);
      manual_col_width = this.__manualColWidths[col_i];
      if (manual_col_width > 0) {
        has_manually_sized_column = true;
        add_css(col_i, manual_col_width);
        fc.style.setProperty("width", manual_col_width + "px");
        fc.style.setProperty("flex", "0 0 auto");
      } else {
        if (indexOf.call(this.__maxCols, col_i) >= 0) {
          has_max_cols = true;
        }
        fc.style.removeProperty("width");
        fc.style.removeProperty("flex");
      }
    }
    ref1 = this.__fillCells;
    for (display_col_i = k = 0, len2 = ref1.length; k < len2; display_col_i = ++k) {
      fc = ref1[display_col_i];
      col_i = this.getColIdx(display_col_i);
      this.__colWidths[col_i] = fc.offsetWidth;
    }
    if (this.__maximize_horizontal) {
      if (!has_max_cols && has_manually_sized_column) {
        CUI.DOM.addClass(this.grid, "cui-lv--max-last-col");
      } else {
        CUI.DOM.removeClass(this.grid, "cui-lv--max-last-col");
      }
    }
    this.styleElement.innerHTML = css.join("\n");
    ref2 = this.__colspanRows;
    for (row_i in ref2) {
      row_info = ref2[row_i];
      for (col_i in row_info) {
        colspan = row_info[col_i];
        cell = DOM.matchSelector(this.grid[0], "." + this.__lvClass + "-cell[row=\"" + row_i + "\"][col=\"" + col_i + "\"]")[0];
        width = 0;
        for (i = l = 0, ref3 = colspan; l < ref3; i = l += 1) {
          width = width + this.__colWidths[parseInt(col_i) + i];
        }
        dim = CUI.DOM.getDimensions(cell);
        if (dim.computedStyle.boxSizing === "border-box") {
          cell.style.setProperty("width", width + "px", "important");
        } else {
          cell.style.setProperty("width", (width - dim.paddingHorizontal - dim.borderHorizontal) + "px", "important");
        }
      }
    }
    if (this.fixedColsCount > 0) {
      ref4 = [0, 2];
      for (m = 0, len3 = ref4.length; m < len3; m++) {
        qi = ref4[m];
        rows = [];
        if (opts.resetRows) {
          sel = ".cui-lv-tr-outer";
        } else {
          sel = "[cui-lv-tr-unmeasured=\"" + this.listViewCounter + "\"]";
        }
        ref5 = DOM.matchSelector(this.grid, "." + this.__lvClass + ("-quadrant[cui-lv-quadrant='" + qi + "'] > ") + sel);
        for (n = 0, len4 = ref5.length; n < len4; n++) {
          row = ref5[n];
          rows[parseInt(DOM.getAttribute(row, "row"))] = row;
          DOM.removeAttribute(row, "cui-lv-tr-unmeasured");
        }
        ref6 = DOM.matchSelector(this.grid, "." + this.__lvClass + ("-quadrant[cui-lv-quadrant='" + (qi + 1) + "'] > ") + sel);
        for (idx = o = 0, len5 = ref6.length; o < len5; idx = ++o) {
          row = ref6[idx];
          row_i2 = parseInt(DOM.getAttribute(row, "row"));
          DOM.prepareSetDimensions(rows[row_i2]);
          row.__offsetHeight = row.offsetHeight;
        }
        ref7 = DOM.matchSelector(this.grid, "." + this.__lvClass + ("-quadrant[cui-lv-quadrant='" + (qi + 1) + "'] > ") + sel);
        for (idx = p = 0, len6 = ref7.length; p < len6; idx = ++p) {
          row = ref7[idx];
          row_i2 = parseInt(DOM.getAttribute(row, "row"));
          DOM.setDimensions(rows[row_i2], {
            borderBoxHeight: row.__offsetHeight
          });
          delete row.__offsetHeight;
          DOM.removeAttribute(row, "cui-lv-tr-unmeasured");
        }
      }
    }
    this.__setMargins();
    this.__addRowsOddEvenClasses();
    if (!this.__maximize_horizontal || !this.__maximize_vertical) {
      Events.trigger({
        type: "content-resize",
        exclude_self: true,
        node: this.DOM
      });
    }
    this.__hasLayout = true;
    return this;
  };

  ListView.prototype.__addRowsOddEvenClasses = function() {
    if ((this.rowsCount - this.fixedRowsCount) % 2 === 0) {
      this.grid.addClass("cui-list-view-grid-rows-even");
      this.grid.removeClass("cui-list-view-grid-rows-odd");
    } else {
      this.grid.removeClass("cui-list-view-grid-rows-even");
      this.grid.addClass("cui-list-view-grid-rows-odd");
    }
    return this;
  };

  ListView.prototype.__getValue = function(px) {
    if (!isNaN(parseFloat(px))) {
      return px + "px";
    } else if (isNull(px)) {
      return "";
    } else {
      return px;
    }
  };

  ListView.prototype.hideWaitBlock = function() {
    if (this.__waitBlock) {
      this.__waitBlock.destroy();
      delete this.__waitBlock;
    }
    return this;
  };

  ListView.prototype.showWaitBlock = function() {
    if (this.__waitBlock) {
      return this;
    }
    this.__waitBlock = new WaitBlock({
      element: this.DOM
    });
    this.__waitBlock.show();
    return this;
  };

  ListView.prototype.__debugRect = function(func, ms) {
    var viewport;
    viewport = this.grid.rect();
    return this.grid.rect(true, 500, ("ListView[#" + this.listViewCounter + "]." + func + " " + ms + "ms ") + viewport.width + "x" + viewport.height);
  };

  ListView.prototype.appendRows = function(rows) {
    var idx, j, len1, row, row_i, start_row_i;
    assert(!this.isDestroyed(), "ListView.appendRow", "ListView " + this.listViewCounter + " is already destroyed.");
    for (idx = j = 0, len1 = rows.length; j < len1; idx = ++j) {
      row = rows[idx];
      row_i = ++this.__maxRowIdx;
      if (idx === 0) {
        start_row_i = row_i;
      }
      this.rowsCount++;
      this.rowsOrder.push(row_i);
    }
    this.__addRows(start_row_i, rows);
    return this;
  };

  ListView.prototype.__getColsFromAndTo = function(qi) {
    switch (qi) {
      case 0:
      case 2:
        return {
          from: 0,
          to: this.fixedColsCount - 1
        };
      case 1:
      case 3:
        return {
          from: this.fixedColsCount,
          to: this.colsCount - 1
        };
    }
  };

  ListView.prototype.__deferRow = function(row) {
    return this.__deferredRows.push(row);
  };

  ListView.prototype.__addRow = function(row_i, listViewRow, mode, sibling_row_i) {
    if (listViewRow == null) {
      listViewRow = null;
    }
    if (mode == null) {
      mode = "append";
    }
    if (sibling_row_i == null) {
      sibling_row_i = null;
    }
    return this.__addRows(row_i, [listViewRow], mode, sibling_row_i);
  };

  ListView.prototype.__getQuadrants = function(row_i) {
    if (this.getDisplayRowIdx(row_i) < this.fixedRowsCount) {
      return [0, 1];
    } else {
      return [2, 3];
    }
  };

  ListView.prototype.__addRows = function(_row_i, listViewRows, mode, sibling_row_i) {
    var _mode, _qi, _qi_s, anchor_row, anchor_row_idx, cls, col_i, display_col_i, find_cells_and_rows, fixedRows, ft, html, i, idx, j, k, l, len1, len2, len3, listViewRow, m, maxi, n, node, o, outer, p, qi, ref, ref1, ref2, ref3, ref4, ref5, ref6, row, row_i, txt, width;
    if (listViewRows == null) {
      listViewRows = [];
    }
    if (mode == null) {
      mode = "append";
    }
    if (sibling_row_i == null) {
      sibling_row_i = null;
    }
    assert(this.grid, "ListView.__addRows", "ListView.render has not been called yet.", {
      row_i: _row_i,
      listView: this
    });
    assert(mode === "append" || mode === "prepend" || mode === "after" || mode === "replace", "ListView.__addRows", "mode \"" + mode + "\" not supported", {
      row_i: _row_i
    });
    txt = ("ListView[" + this.listViewCounter + "].__addRows: Adding ") + listViewRows.length + (" rows, starting at " + _row_i + ".");
    html = [[], [], [], []];
    _mode = mode;
    if (_mode === "after" && this.getDisplayRowIdx(_row_i) === this.fixedRowsCount) {
      mode = "prepend";
    }
    if (mode === "replace" || mode === "after") {
      switch (mode) {
        case "replace":
          assert(listViewRows.length === 1, "ListView.__addRows", "Can only use mode \"" + mode + "\" on one row", {
            listViewRows: listViewRows
          });
          row_i = _row_i;
          this.__resetRowDim(row_i);
          break;
        case "after":
          row_i = sibling_row_i;
      }
      anchor_row = this.__rows[row_i];
      assert(anchor_row.length >= 1, "ListView.__addRows", "anchor row " + row_i + " for mode " + mode + " not found.", {
        rows: this.__rows,
        row_i: row_i,
        mode: _mode,
        mode_used: mode
      });
    }
    for (row_i = j = ref = _row_i, ref1 = row_i + listViewRows.length - 1; j <= ref1; row_i = j += 1) {
      this.__cells[row_i] = [];
      this.__rows[row_i] = [];
      ref2 = this.__getQuadrants(row_i);
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        qi = ref2[k];
        ft = this.__getColsFromAndTo(qi);
        if (ft.to < ft.from) {
          continue;
        }
        if (this.fixedColsCount > 0) {
          html[qi].push("<div class=\"cui-lv-tr-outer\" cui-lv-tr-unmeasured=\"" + this.listViewCounter + "\" row=\"" + row_i + "\"><div class=\"cui-lv-tr\">");
        } else {
          html[qi].push("<div class=\"cui-lv-tr-outer\" row=\"" + row_i + "\"><div class=\"cui-lv-tr\">");
        }
        for (display_col_i = l = ref3 = ft.from, ref4 = ft.to; l <= ref4; display_col_i = l += 1) {
          col_i = this.getColIdx(display_col_i);
          ref5 = this.__getColWidth(row_i, col_i), width = ref5[0], maxi = ref5[1];
          cls = this.__getColClass(col_i);
          html[qi].push("<div class=\"cui-lv-td " + cls + " " + this.__lvClass + "-cell\" col=\"" + col_i + "\" row=\"" + row_i + "\"></div>");
        }
        html[qi].push("</div></div>");
      }
    }
    find_cells_and_rows = (function(_this) {
      return function(top) {
        var _cells, _col, _row, _rows, cell, len2, len3, m, n, row;
        _cells = CUI.DOM.matchSelector(top, ".cui-lv-td");
        for (m = 0, len2 = _cells.length; m < len2; m++) {
          cell = _cells[m];
          _col = parseInt(cell.getAttribute("col"));
          _row = parseInt(cell.getAttribute("row"));
          _this.__cells[_row][_col] = $(cell);
        }
        _rows = CUI.DOM.matchSelector(top, ".cui-lv-tr-outer");
        for (n = 0, len3 = _rows.length; n < len3; n++) {
          row = _rows[n];
          row_i = parseInt(row.getAttribute("row"));
          _this.__rows[row_i].push(row);
        }
      };
    })(this);
    anchor_row_idx = 0;
    for (qi = m = 0; m <= 3; qi = ++m) {
      if (html[qi].length === 0) {
        continue;
      }
      outer = document.createElement("div");
      outer.innerHTML = html[qi].join("");
      find_cells_and_rows(outer);
      if (mode === "append") {
        if (qi === 2 || qi === 3) {
          while (node = outer.firstChild) {
            this.quadrant[qi].insertBefore(node, this.quadrant[qi].lastChild);
          }
        } else {
          while (node = outer.firstChild) {
            this.quadrant[qi].appendChild(node);
          }
        }
        continue;
      }
      if (mode === "prepend") {
        while (node = outer.lastChild) {
          this.quadrant[qi].insertBefore(node, this.quadrant[qi].firstChild);
        }
        continue;
      }
      row = $(anchor_row[anchor_row_idx]);
      anchor_row_idx++;
      if (mode === "after") {
        while (node = outer.lastChild) {
          row.after(node);
        }
        continue;
      }
      if (mode === "replace") {
        node = outer.firstChild;
        CUI.DOM.replaceWith(row, node);
      }
    }
    if (this.fixedRowsCount > 0) {
      fixedRows = this.quadrant[1].childNodes;
      if (this.fixedRowsCount < fixedRows.length) {
        if (this.fixedColsCount > 0) {
          _qi_s = [0, 1];
        } else {
          _qi_s = [1];
        }
        for (i = n = 0, ref6 = fixedRows.length - this.fixedRowsCount; n < ref6; i = n += 1) {
          for (o = 0, len2 = _qi_s.length; o < len2; o++) {
            _qi = _qi_s[o];
            if (this.quadrant[_qi + 2].firstChild) {
              this.quadrant[_qi + 2].insertBefore(this.quadrant[_qi].lastChild, this.quadrant[_qi + 2].firstChild);
            } else {
              this.quadrant[_qi + 2].appendChild(this.quadrant[_qi].lastChild);
            }
          }
        }
      }
    }
    for (idx = p = 0, len3 = listViewRows.length; p < len3; idx = ++p) {
      listViewRow = listViewRows[idx];
      if (isPromise(listViewRow)) {
        (function(_this) {
          return (function(idx) {
            return listViewRow.done(function(_listViewRow) {
              return _this.__appendCells(_listViewRow, _row_i + idx);
            });
          });
        })(this)(idx);
      } else {
        this.__appendCells(listViewRow, _row_i + idx);
      }
    }
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.__appendCells = function(listViewRow, row_i) {
    var _cols, cell, col, col_i, colspan, colspan_offset, i, j, k, l, len1, len2, node, ref, ref1, row;
    assert(listViewRow instanceof ListViewRow, "ListView.addRow", "listViewRow needs to be instance of ListViewRow or Deferred which returns a ListViewRow", {
      listViewRow: listViewRow
    });
    listViewRow.setRowIdx(row_i).setListView(this);
    ref = this.__rows[row_i];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      row = ref[j];
      DOM.data(row, "listViewRow", listViewRow);
    }
    listViewRow.addClass((listViewRow.getClass() || "") + " " + toDash(getObjectClass(listViewRow)));
    if (this._rowMove) {
      if (this.getDisplayRowIdx(row_i) >= this.fixedRowsCount + this._rowMoveFixedRows) {
        if (!(listViewRow.getColumns()[0] instanceof ListViewColumnRowMoveHandle)) {
          listViewRow.prependColumn(new ListViewColumnRowMoveHandle());
        }
      } else {
        if (!(listViewRow.getColumns()[0] instanceof ListViewColumnRowMoveHandlePlaceholder)) {
          listViewRow.prependColumn(new ListViewColumnRowMoveHandlePlaceholder());
        }
      }
    } else if (this._rowMovePlaceholder) {
      if (!(listViewRow.getColumns()[0] instanceof ListViewColumnRowMoveHandlePlaceholder)) {
        listViewRow.prependColumn(new ListViewColumnRowMoveHandlePlaceholder());
      }
    }
    _cols = listViewRow.getColumns();
    colspan_offset = 0;
    for (col_i = k = 0, len2 = _cols.length; k < len2; col_i = ++k) {
      col = _cols[col_i];
      node = col.render();
      cell = this.__cells[row_i][col_i + colspan_offset];
      assert(cell, "ListView.__appendCells", "Cell not found: row: " + row_i + " column: " + (col_i + colspan_offset + 1) + ". colsCount: " + this.colsCount, {
        row: listViewRow
      });
      if (!isNull(node)) {
        cell.append(node);
      }
      col.setColumnIdx(col_i);
      col.setElement(cell);
      colspan = col.getColspan();
      assert(col_i + colspan_offset + colspan - 1 < this.colsCount, "ListView.__appendCells", "Colspan " + colspan + " exceeds cols count " + this.colsCount + ", unable to append cell.", {
        row_i: row_i,
        col_i: col_i,
        colspan_offset: colspan_offset,
        colspan: colspan,
        column: col,
        row: listViewRow,
        ListView: this
      });
      if (colspan > 1) {
        cell.attr("colspan", colspan);
        if (!this.__colspanRows[row_i]) {
          this.__colspanRows[row_i] = {};
        }
        this.__colspanRows[row_i][col_i + colspan_offset] = colspan;
        for (i = l = 1, ref1 = colspan; 1 <= ref1 ? l < ref1 : l > ref1; i = 1 <= ref1 ? ++l : --l) {
          this.__cells[row_i][col_i + colspan_offset + 1].remove();
          delete this.__cells[row_i][col_i + colspan_offset + 1];
          colspan_offset++;
        }
      }
    }
    assert(_cols.length + colspan_offset <= this.colsCount, "ListView.addRow", "ListViewRow provided more columns (" + (_cols.length + colspan_offset) + ") than colsCount (" + this.colsCount + ") is set to", {
      colsCount: this.colsCount,
      cols: _cols
    });
    listViewRow.addedToListView(this.__rows[row_i]);
  };

  ListView.prototype.__getColClass = function(col_i) {
    var cls, col_cls, ref;
    col_cls = (ref = this.__colClasses) != null ? ref[col_i] : void 0;
    cls = [];
    if (CUI.isArray(col_cls)) {
      cls.push.apply(cls, col_cls);
    } else if (!isEmpty(col_cls)) {
      cls.push(col_cls);
    }
    if (indexOf.call(this.__maxCols, col_i) >= 0) {
      cls.push("cui-lv-td-max");
    }
    return cls.join(" ");
  };

  ListView.prototype.__resetRowDim = function(row_i) {
    var col_i, display_col_i, j, k, len1, ref, ref1, row;
    delete this.__cellDims[row_i];
    delete this.__rowHeights[row_i];
    if (this.fixedColsCount > 0 && this.__rows[row_i]) {
      ref = this.__rows[row_i];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        row = ref[j];
        DOM.setAttribute(row, "cui-lv-tr-unmeasured", this.listViewCounter);
      }
    }
    for (display_col_i = k = 0, ref1 = this.colsCount - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; display_col_i = 0 <= ref1 ? ++k : --k) {
      col_i = this.getColIdx(display_col_i);
      this.__resetCellStyle(row_i, col_i);
    }
    return this;
  };

  ListView.prototype.__resetCellStyle = function(row_i, col_i) {
    var cell, ref;
    cell = (ref = this.__cells[row_i]) != null ? ref[col_i] : void 0;
    if (cell) {
      cell[0].style.cssText = "";
    }
    return cell;
  };

  ListView.prototype.__resetColWidth = function(col_i) {
    var dim, display_row_i, j, k, len1, ref, ref1, row_i;
    ref = this.__cellDims;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      dim = ref[j];
      if (dim) {
        delete dim[col_i];
      }
    }
    for (display_row_i = k = 0, ref1 = this.rowsCount - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; display_row_i = 0 <= ref1 ? ++k : --k) {
      row_i = this.getRowIdx(display_row_i);
      this.__resetCellStyle(row_i, col_i);
    }
    this.__fillCells[col_i].style.cssText = "";
    return this;
  };

  ListView.prototype.__resetCellDims = function(col_i) {
    this.__cellDims = [];
    this.__colWidths = [];
    return this.__rowHeights = [];
  };

  ListView.prototype.__isMaximizedCol = function(col_i) {
    return indexOf.call(this.__maxCols, col_i) >= 0 && !this.__manualColWidths.hasOwnProperty(col_i);
  };

  ListView.counter = 0;

  ListView.prototype.__getColWidth = function(row_i, col_i) {
    var _col_i, accWidth, colspan, j, maxi, ref, ref1, ref2;
    colspan = (ref = this.__colspanRows[row_i]) != null ? ref[col_i] : void 0;
    if (colspan > 1) {
      accWidth = 0;
      maxi = false;
      for (_col_i = j = ref1 = col_i, ref2 = col_i + colspan - 1; j <= ref2; _col_i = j += 1) {
        if (this.__isMaximizedCol(_col_i)) {
          maxi = true;
        }
        accWidth += this.__colWidths[_col_i];
      }
      return [accWidth, maxi];
    } else {
      return [this.__colWidths[col_i], this.__isMaximizedCol(col_i)];
    }
  };

  ListView.prototype.__debugCall = function(name, func) {
    var end, start;
    if (!CUI.defaults.debug) {
      return func();
    }
    start = getMs();
    func();
    end = getMs();
    return this.__debugRect(name, end - start);
  };

  ListView.prototype.__addDebugControl = function() {
    Events.listen({
      type: "contextmenu",
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          var get_maximize_text, items;
          if (!(ev.altKey() && !(ev.ctrlKey() || ev.shiftKey() || ev.metaKey()))) {
            return;
          }
          ev.preventDefault();
          ev.stopPropagation();
          _this.grid.rect(true, 500);
          get_maximize_text = function(name, on_off) {
            return name + ": " + (on_off ? "ON" : "OFF");
          };
          items = [
            {
              label: "ListView[#" + _this.listViewCounter + "] Debug Menu"
            }, {
              text: "layout",
              onClick: function() {
                return _this.__debugCall("__doLayout", function() {
                  return _this.__doLayout({
                    resetRows: true
                  });
                });
              }
            }, {
              text: "flash",
              onClick: function() {
                return _this.grid.rect(true, 1000, "ListView[#" + _this.listViewCounter + "]");
              }
            }, {
              text: "debug",
              onClick: function() {
                return _this.__debugCall("debug", function() {
                  CUI.debug("ListView[#" + _this.listViewCounter + "]", _this);
                  CUI.debug("opts:", _this.opts);
                  CUI.debug("manualColWidths:", dump(_this.__manualColWidths));
                  return CUI.debug("colWidths:", dump(_this.__colWidths), "rowHeights:", _this.__rowHeights);
                });
              }
            }, {
              text: "appendRow",
              onClick: function() {
                var col, col_i, display_col_i, j, len1, lv, ref;
                lv = new ListViewRow();
                ref = _this._cols;
                for (display_col_i = j = 0, len1 = ref.length; j < len1; display_col_i = ++j) {
                  col = ref[display_col_i];
                  col_i = _this.getColIdx(display_col_i);
                  lv.addColumn(new ListViewColumn({
                    text: _this.getColdef(col_i) + " " + _this.rowsCount
                  }));
                }
                return _this.appendRow(lv);
              }
            }, {
              text: "removeRow",
              onClick: function() {
                return _this.removeRow(_this.getRowIdx(_this.rowsCount - 1));
              }
            }, {
              text: "close",
              onClick: function() {
                return _this.__control.destroy();
              }
            }
          ];
          (new Menu({
            auto_close_after_click: false,
            itemList: {
              items: items
            },
            show_at_position: {
              top: ev.pageY(),
              left: ev.pageX()
            }
          })).show();
          return false;
        };
      })(this)
    });
    return this;
  };

  return ListView;

})(CUI.SimplePane);

ListView = CUI.ListView;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewTree,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewTree = (function(superClass) {
  extend(ListViewTree, superClass);

  function ListViewTree(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    this.__actionOnNode = bind(this.__actionOnNode, this);
    ListViewTree.__super__.constructor.call(this, this.opts);
    assert(this.root instanceof ListViewTreeNode, "new ListViewTree", "opts.root must be instance of ListViewTreeNode", {
      opts: this.opts
    });
    this.root.setTree(this);
  }

  ListViewTree.prototype.initOpts = function() {
    ListViewTree.__super__.initOpts.call(this);
    return this.addOpts({
      rowMoveWithinNodesOnly: {
        check: Boolean
      },
      children: {
        check: Array
      },
      selectable: {
        deprecated: true,
        check: Boolean
      },
      no_hierarchy: {
        "default": false,
        check: Boolean
      },
      root: {
        check: function(v) {
          return v instanceof ListViewRow;
        }
      },
      onOpen: {
        check: Function
      },
      onClose: {
        check: Function
      }
    });
  };

  ListViewTree.prototype.readOpts = function() {
    ListViewTree.__super__.readOpts.call(this);
    if (this._selectable !== void 0) {
      assert(this._selectableRows === void 0, "new ListViewTree", "opts.selectable cannot be used with opts.selectableRows, use selectableRows only.", {
        opts: this.opts
      });
      this.__selectableRows = this._selectable;
    }
    return this;
  };

  ListViewTree.prototype.getRowMoveTool = function(opts) {
    if (opts == null) {
      opts = {};
    }
    opts.rowMoveWithinNodesOnly = this._rowMoveWithinNodesOnly;
    return new CUI.ListViewTreeRowMove(opts);
  };

  ListViewTree.prototype.initListView = function() {
    var lv_opts;
    ListViewTree.__super__.initListView.call(this);
    if (!this._root) {
      lv_opts = {};
      if (this._children) {
        lv_opts.children = this._children;
      } else if (this._getChildren) {
        lv_opts.getChildren = this._getChildren;
      } else {
        lv_opts.children = [];
      }
      this.root = new ListViewTreeNode(lv_opts);
    } else {
      this.root = this._root;
    }
    return this;
  };

  ListViewTree.prototype.isSelectable = function() {
    return !!this.__selectableRows;
  };

  ListViewTree.prototype.isNoHierarchy = function() {
    return this._no_hierarchy;
  };

  ListViewTree.prototype.triggerNodeDeselect = function(ev, node) {
    var info;
    info = {
      ev: ev,
      node: node,
      listView: this
    };
    if (typeof this._onDeselect === "function") {
      this._onDeselect(ev, info);
    }
    return Events.trigger({
      node: this,
      type: "row_deselected"
    });
  };

  ListViewTree.prototype.triggerNodeSelect = function(ev, node) {
    var info;
    info = {
      ev: ev,
      node: node,
      listView: this
    };
    if (typeof this._onSelect === "function") {
      this._onSelect(ev, info);
    }
    return Events.trigger({
      node: this,
      type: "row_selected"
    });
  };

  ListViewTree.prototype.render = function(do_open) {
    var handle_event;
    if (do_open !== false) {
      CUI.error("ListViewTree.render called with do_open == " + do_open + ", only \"false\" is supported. The automatic root.open() is deprecated and will be removed in a future version.");
      do_open = true;
    }
    handle_event = (function(_this) {
      return function(ev) {
        var node;
        node = DOM.data(DOM.closest(ev.getCurrentTarget(), ".cui-lv-tree-node"), "listViewRow");
        if (!(node instanceof ListViewTreeNode) || node.isLoading() || node.isLeaf()) {
          return;
        }
        ev.stopImmediatePropagation();
        if (ev instanceof CUI.DragoverScrollEvent) {
          if (ev.getCount() % 50 === 0) {
            _this.toggleNode(ev, node);
          }
        } else {
          _this.toggleNode(ev, node);
        }
      };
    })(this);
    ListViewTree.__super__.render.call(this);
    Events.listen({
      node: this.DOM,
      selector: ".cui-tree-node-handle",
      capture: true,
      type: ["click", "dragover-scroll"],
      call: (function(_this) {
        return function(ev) {
          return handle_event(ev);
        };
      })(this)
    });
    Events.listen({
      node: this.DOM,
      selector: ".cui-lv-tree-node",
      type: ["click"],
      call: (function(_this) {
        return function(ev) {
          return handle_event(ev);
        };
      })(this)
    });
    if (do_open) {
      this.root.open();
    }
    if (this._no_hierarchy) {
      this.grid.addClass("cui-list-view-tree-no-hierarchy");
    } else {
      this.grid.addClass("cui-list-view-tree-hierarchy");
    }
    return this.DOM;
  };

  ListViewTree.prototype.toggleNode = function(ev, node) {
    if (node.isOpen()) {
      this.__runTrigger(ev, "close", node);
    } else {
      this.__runTrigger(ev, "open", node);
    }
  };

  ListViewTree.prototype.__runTrigger = function(ev, action, node) {
    if (ev.ctrlKey()) {
      this.__actionOnNode(ev, action + "Recursively", node);
    } else {
      this.__actionOnNode(ev, action, node);
    }
  };

  ListViewTree.prototype.__actionOnNode = function(ev, action, node) {
    var hide_spinner, ret, spinner_timeout;
    hide_spinner = null;
    spinner_timeout = CUI.setTimeout({
      ms: 500,
      call: (function(_this) {
        return function() {
          node.showSpinner();
          spinner_timeout = null;
          return hide_spinner = true;
        };
      })(this)
    });
    this.stopLayout();
    ret = node[action]();
    ret.done((function(_this) {
      return function() {
        switch (action) {
          case "open":
            return typeof _this._onOpen === "function" ? _this._onOpen(ev, {
              node: node
            }) : void 0;
          case "close":
            return typeof _this._onClose === "function" ? _this._onClose(ev, {
              node: node
            }) : void 0;
        }
      };
    })(this));
    ret.always((function(_this) {
      return function() {
        if (spinner_timeout) {
          CUI.clearTimeout(spinner_timeout);
        }
        if (hide_spinner) {
          node.hideSpinner();
        }
        return _this.startLayout();
      };
    })(this));
    return ret;
  };

  ListViewTree.prototype.getNodesForMove = function(from_i, to_i, after) {
    var from_node, new_father, to_node;
    from_node = this.getListViewRow(from_i);
    to_node = this.getListViewRow(to_i);
    assert(from_node, "ListViewTree.moveRow", "from_i node not found", {
      from_i: from_i
    });
    assert(to_node, "ListViewTree.moveRow", "to_i node not found", {
      to_i: to_i
    });
    if (from_node.father === to_node.father && !(to_node.is_open && after)) {
      new_father = null;
    } else if (to_node.is_open && after) {
      new_father = to_node;
    } else {
      new_father = to_node.father;
    }
    if (new_father === from_node.father) {
      new_father = null;
    }
    return [from_node, to_node, new_father];
  };

  ListViewTree.prototype.moveRow = function(from_i, to_i, after) {
    var from_node, new_father, promise, ref, to_node;
    ref = this.getNodesForMove(from_i, to_i, after), from_node = ref[0], to_node = ref[1], new_father = ref[2];
    promise = from_node.moveNodeBefore(to_node, new_father, after);
    assert(isPromise(promise), "ListViewTree.moveRow", "moveNodeBefore needs to return a Promise", {
      promise: promise
    });
    promise.done((function(_this) {
      return function() {
        ListViewTree.__super__.moveRow.call(_this, from_i, to_i, after, false);
        if (from_node.father === to_node.father && !(to_node.is_open && after)) {
          moveInArray(from_node.getChildIdx(), to_node.getChildIdx(), from_node.father.children, after);
        } else {
          from_node.father.removeChild(from_node);
          if (to_node.is_open && after) {
            to_node.children.splice(0, 0, from_node);
            from_node.setFather(to_node);
          } else {
            if (!after) {
              to_node.father.children.splice(to_node.getChildIdx(), 0, from_node);
            } else {
              to_node.father.children.splice(to_node.getChildIdx() + 1, 0, from_node);
            }
            from_node.setFather(to_node.father);
          }
        }
        from_node.reload();
        if (new_father != null) {
          new_father.reload();
        }
        from_node.moveNodeAfter(to_node, new_father, after);
        return Events.trigger({
          node: _this.grid,
          type: "row_moved",
          info: {
            from_i: from_i,
            to_i: to_i,
            after: after
          }
        });
      };
    })(this));
    return promise;
  };

  ListViewTree.prototype.getRootChildren = function() {
    return this.root.children;
  };

  ListViewTree.prototype.getSelectedNode = function(key) {
    if (key == null) {
      key = "selectedNode";
    }
    return this.root[key];
  };

  ListViewTree.prototype.prependNode = function(node) {
    return this.addNode(node, false);
  };

  ListViewTree.prototype.addNode = function(node, append) {
    var promise;
    if (append == null) {
      append = true;
    }
    assert(node instanceof ListViewTreeNode, (getObjectClass(this)) + ".addNode", "Node must be instance of ListViewTreeNode", {
      node: node
    });
    promise = this.root.addNode(node, append);
    Events.trigger({
      node: this,
      type: "row_added",
      info: {
        node: node
      }
    });
    return promise;
  };

  ListViewTree.prototype.openTreeNodeByRowDisplayIndex = function(index) {
    var row, row_index;
    row_index = this.getRowIdx(index);
    row = this.getRow(row_index);
    return DOM.data(row[0], "listViewRow").open();
  };

  return ListViewTree;

})(CUI.ListView);

CUI.Events.registerEvent({
  bubble: true,
  type: ["row_removed", "row_added", "row_moved", "row_selected", "row_deselected"]
});

ListViewTree = CUI.ListViewTree;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewRow,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewRow = (function(superClass) {
  extend(ListViewRow, superClass);

  function ListViewRow() {
    return ListViewRow.__super__.constructor.apply(this, arguments);
  }

  ListViewRow.prototype.initOpts = function() {
    ListViewRow.__super__.initOpts.call(this);
    return this.addOpts({
      columns: {
        check: Array
      },
      selectable: {
        check: Boolean
      },
      "class": {
        check: String
      }
    });
  };

  ListViewRow.prototype.readOpts = function() {
    var col, i, idx, len, ref;
    ListViewRow.__super__.readOpts.call(this);
    if (this._columns) {
      this.columns = this._columns;
      ref = this.columns;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        col = ref[idx];
        if (col) {
          this.setColumn(idx, col);
        }
      }
    } else {
      this.columns = [];
    }
    if (this._selectable === false) {
      this.setSelectable(false);
    } else {
      this.setSelectable(true);
    }
    if (this._class) {
      this.__class = this._class;
    } else {
      this.__class = "";
    }
    this.row_i = null;
    this.__addedToListView = false;
    return this.listView = null;
  };

  ListViewRow.prototype.addColumn = function(column) {
    assert(column instanceof ListViewColumn, "ListViewRow.addColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns.push(column);
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.setColumn = function(idx, column) {
    assert(column instanceof ListViewColumn, "ListViewRow.addColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns[idx] = column;
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.prependColumn = function(column) {
    assert(column instanceof ListViewColumn, "ListViewRow.prependColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns.splice(0, 0, column);
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.setSelectable = function(on_off) {
    return this.__selectable = on_off;
  };

  ListViewRow.prototype.isSelectable = function() {
    if (this.listView) {
      if (!this.listView.hasSelectableRows()) {
        return false;
      }
      if (this.getDisplayRowIdx() < this.listView.fixedRowsCount) {
        return false;
      }
    }
    return this.__selectable;
  };

  ListViewRow.prototype.isMovable = function(ev) {
    return this.listView.hasMovableRows();
  };

  ListViewRow.prototype.moveRow = null;

  ListViewRow.prototype.removeColumns = function() {
    var c, i, len, ref;
    ref = this.columns;
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      c.setRow();
    }
    return this.columns.splice(0);
  };

  ListViewRow.prototype.getColumns = function() {
    return this.columns;
  };

  ListViewRow.prototype.setRowIdx = function(row_i) {
    this.row_i = row_i;
    return this;
  };

  ListViewRow.prototype.getDOMNodes = function() {
    var ref;
    return CUI.jQueryCompat((ref = this.listView) != null ? ref.getRow(this.row_i) : void 0);
  };

  ListViewRow.prototype.getRowIdx = function() {
    return this.row_i;
  };

  ListViewRow.prototype.scrollIntoView = function() {
    var ref;
    if ((ref = this.getDOMNodes()[0]) != null) {
      ref.scrollIntoView();
    }
    return this;
  };

  ListViewRow.prototype.getDisplayRowIdx = function() {
    var ref;
    return (ref = this.listView) != null ? ref.getDisplayRowIdx(this.row_i) : void 0;
  };

  ListViewRow.prototype.addedToListView = function(DOMNodes) {
    return this.__addedToListView = true;
  };

  ListViewRow.prototype.isAddedToListView = function() {
    return this.__addedToListView;
  };

  ListViewRow.prototype.setListView = function(listView) {
    this.listView = listView;
  };

  ListViewRow.prototype.getListView = function() {
    return this.listView;
  };

  ListViewRow.prototype.__selectableClass = "cui-list-view-row-selectable";

  ListViewRow.prototype.__movableClass = "cui-list-view-row-movable";

  ListViewRow.prototype.getClass = function() {
    var cls;
    cls = this.__class;
    if (this.isSelectable()) {
      cls = this.__selectableClass + " " + cls;
    }
    if (this.isMovable()) {
      cls = this.__movableClass + " " + cls;
    }
    return cls;
  };

  ListViewRow.prototype.setClass = function(__class) {
    this.__class = __class;
  };

  ListViewRow.prototype.addClass = function(cls) {
    var ref;
    return (ref = this.listView) != null ? ref.rowAddClass(this.row_i, cls) : void 0;
  };

  ListViewRow.prototype.removeClass = function(cls) {
    var ref;
    return (ref = this.listView) != null ? ref.rowRemoveClass(this.row_i, cls) : void 0;
  };

  ListViewRow.prototype.select = function(ev) {
    var base;
    if (this.selected) {
      CUI.debug("already selected", this);
      return;
    }
    if (!this.isSelectable()) {
      CUI.debug("not selectable", this);
      return;
    }
    this.selected = true;
    if (!this.listView) {
      return;
    }
    this.listView.rowAddClass(this.row_i, ListViewRow.defaults.selected_class);
    if (typeof (base = this.listView)._onSelect === "function") {
      base._onSelect(ev, {
        originalEvent: ev,
        listView: this.listView,
        row: this
      });
    }
    return CUI.resolvedPromise();
  };

  ListViewRow.prototype.deselect = function(ev) {
    var ref, ref1;
    if (!this.listView.hasSelectableRows()) {
      return CUI.rejectedPromise();
    }
    if (!this.selected) {
      return CUI.rejectedPromise();
    }
    if ((ref = this.listView) != null) {
      ref.rowRemoveClass(this.row_i, ListViewRow.defaults.selected_class);
    }
    this.selected = false;
    if ((ref1 = this.listView) != null) {
      if (typeof ref1._onDeselect === "function") {
        ref1._onDeselect(ev, {
          originalEvent: ev,
          listView: this.listView,
          row: this
        });
      }
    }
    return CUI.resolvedPromise();
  };

  ListViewRow.prototype.isSelected = function() {
    return !!this.selected;
  };

  ListViewRow.prototype.remove = function() {
    return this.listView.removeRow(this.row_i);
  };

  ListViewRow.defaults = {
    selected_class: "cui-selected"
  };

  return ListViewRow;

})(CUI.Element);

ListViewRow = CUI.ListViewRow;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewHeaderRow,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewHeaderRow = (function(superClass) {
  extend(ListViewHeaderRow, superClass);

  function ListViewHeaderRow() {
    return ListViewHeaderRow.__super__.constructor.apply(this, arguments);
  }

  ListViewHeaderRow.prototype.isSelectable = function() {
    return false;
  };

  return ListViewHeaderRow;

})(ListViewRow);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewTreeNode,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.ListViewTreeNode = (function(superClass) {
  extend(ListViewTreeNode, superClass);

  function ListViewTreeNode() {
    this.update = bind(this.update, this);
    return ListViewTreeNode.__super__.constructor.apply(this, arguments);
  }

  ListViewTreeNode.prototype.initOpts = function() {
    ListViewTreeNode.__super__.initOpts.call(this);
    return this.addOpts({
      children: {
        check: Array
      },
      open: {
        check: Boolean
      },
      html: {},
      colspan: {
        check: function(v) {
          return v > 0;
        }
      },
      getChildren: {
        check: Function
      }
    });
  };

  ListViewTreeNode.prototype.readOpts = function() {
    ListViewTreeNode.__super__.readOpts.call(this);
    this.colspan = this._colspan;
    if (this._children) {
      this.children = this.opts.children;
      this.initChildren();
    }
    if (this._open) {
      this.do_open = true;
    } else {
      this.do_open = false;
    }
    this.is_open = false;
    this.html = this._html;
    return this.__loadingDeferred = null;
  };

  ListViewTreeNode.prototype.isLeaf = function() {
    var leaf;
    leaf = (this.children ? false : this.opts.getChildren ? false : this.getChildren ? this.opts.leaf || (this.hasChildren && !this.hasChildren()) ? true : false : true);
    return leaf;
  };

  ListViewTreeNode.prototype.getClass = function() {
    var cls;
    cls = ListViewTreeNode.__super__.getClass.call(this);
    cls = cls + " cui-lv-tree-node";
    return cls;
  };

  ListViewTreeNode.prototype.isSelectable = function() {
    return (typeof this.getTree === "function" ? this.getTree().isSelectable() : void 0) && this.__selectable && !this.isRoot();
  };

  ListViewTreeNode.prototype.getFather = function() {
    return this.father;
  };

  ListViewTreeNode.prototype.setFather = function(new_father) {
    var c, j, len, ref, tree;
    assert(new_father === null || new_father instanceof ListViewTreeNode, (getObjectClass(this)) + ".setFather", "father can only be null or instanceof ListViewTreeNode", {
      father: new_father
    });
    assert(new_father !== this, (getObjectClass(this)) + ".setFather", "father cannot be self", {
      node: this,
      father: new_father
    });
    if (new_father) {
      assert(indexOf.call(new_father.getPath(true), this) < 0, (getObjectClass(this)) + ".setFather", "father cannot any of the node's children", {
        node: this,
        father: new_father
      });
    }
    if (!new_father && this.selected) {
      this.setSelectedNode(null);
      this.selected = false;
    }
    if (this.father && !new_father) {
      tree = this.getTree();
      this.father = new_father;
      if (tree) {
        this.setTree(tree);
      }
    } else {
      this.father = new_father;
    }
    if (this.children) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        c.setFather(this);
      }
    }
    return this;
  };

  ListViewTreeNode.prototype.isRoot = function() {
    return !this.father;
  };

  ListViewTreeNode.prototype.setTree = function(tree1) {
    this.tree = tree1;
    assert(this.isRoot(), (getObjectClass(this)) + ".setTree", "node must be root node to set tree", {
      tree: this.tree,
      opts: this.opts
    });
    return assert(this.tree instanceof ListViewTree, (getObjectClass(this)) + ".setTree", "tree must be instance of ListViewTree", {
      tree: this.tree,
      opts: this.opts
    });
  };

  ListViewTreeNode.prototype.getRoot = function(call) {
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getRoot", "Recursion detected.");
    if (this.father) {
      return this.father.getRoot(call + 1);
    } else {
      return this;
    }
  };

  ListViewTreeNode.prototype.dump = function(lines, depth) {
    var c, j, k, len, pad, padding, ref, ref1;
    if (lines == null) {
      lines = [];
    }
    if (depth == null) {
      depth = 0;
    }
    padding = [];
    for (pad = j = 0, ref = depth; 0 <= ref ? j < ref : j > ref; pad = 0 <= ref ? ++j : --j) {
      padding.push("  ");
    }
    lines.push(padding.join("") + this.dumpString());
    if (this.children) {
      ref1 = this.children;
      for (k = 0, len = ref1.length; k < len; k++) {
        c = ref1[k];
        c.dump(lines, depth + 1);
      }
    }
    if (depth === 0) {
      return "\n" + lines.join("\n") + "\n";
    }
  };

  ListViewTreeNode.prototype.dumpString = function() {
    return this.getNodeId();
  };

  ListViewTreeNode.prototype.getTree = function(call) {
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getTree", "Recursion detected.");
    if (this.isRoot()) {
      return this.tree;
    } else {
      return this.getRoot().getTree(call + 1);
    }
  };

  ListViewTreeNode.prototype.find = function(eq_func, nodes) {
    var c, j, len, ref;
    if (eq_func == null) {
      eq_func = null;
    }
    if (nodes == null) {
      nodes = [];
    }
    if (!eq_func || eq_func.call(this, this)) {
      nodes.push(this);
    }
    if (this.children) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        c.find(eq_func, nodes);
      }
    }
    return nodes;
  };

  ListViewTreeNode.prototype.filter = function(filter_func, filtered_nodes) {
    var c, father, idx, j, k, len, len1, our_idx, ref, save_children;
    if (filtered_nodes == null) {
      filtered_nodes = [];
    }
    save_children = (ref = this.children) != null ? ref.slice(0) : void 0;
    if (this.father && filter_func.call(this, this)) {
      our_idx = this.getChildIdx();
      filtered_nodes.push(this);
      father = this.getFather();
      ListViewTreeNode.prototype.remove.call(this, true, false);
      for (idx = j = 0, len = save_children.length; j < len; idx = ++j) {
        c = save_children[idx];
        father.children.splice(our_idx + idx, 0, c);
        c.setFather(father);
      }
    }
    if (save_children) {
      for (k = 0, len1 = save_children.length; k < len1; k++) {
        c = save_children[k];
        c.filter(filter_func, filtered_nodes);
      }
    }
    return filtered_nodes;
  };

  ListViewTreeNode.prototype.getPath = function(include_self, path, call) {
    if (include_self == null) {
      include_self = false;
    }
    if (path == null) {
      path = [];
    }
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getPath", "Recursion detected.");
    if (this.father) {
      this.father.getPath(true, path, call + 1);
    }
    if (include_self) {
      path.push(this);
    }
    return path;
  };

  ListViewTreeNode.prototype.getChildIdx = function() {
    var ci;
    if (this.isRoot()) {
      return "root";
    } else {
      ci = this.father.children.indexOf(this);
      assert(ci > -1, (getObjectClass(this)) + ".getChildIdx()", "Node not found in fathers children Array", {
        node: this,
        father: this.father,
        "father.children": this.father.children
      });
      return ci;
    }
  };

  ListViewTreeNode.prototype.getNodeId = function(include_self) {
    var p, path;
    if (include_self == null) {
      include_self = true;
    }
    path = this.getPath(include_self);
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = path.length; j < len; j++) {
        p = path[j];
        results.push(p.getChildIdx());
      }
      return results;
    })()).join(".");
  };

  ListViewTreeNode.prototype.getOpenChildNodes = function(nodes) {
    var j, len, node, ref;
    if (nodes == null) {
      nodes = [];
    }
    if (this.children && this.is_open) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        nodes.push(node);
        node.getOpenChildNodes(nodes);
      }
    }
    return nodes;
  };

  ListViewTreeNode.prototype.getRowsToMove = function() {
    return this.getOpenChildNodes();
  };

  ListViewTreeNode.prototype.isRendered = function() {
    var ref;
    if ((this.isRoot() && ((ref = this.getTree()) != null ? ref.getGrid() : void 0)) || this.__is_rendered) {
      return true;
    } else {
      return false;
    }
  };

  ListViewTreeNode.prototype.sort = function(func, level) {
    var j, len, node, ref, ref1;
    if (level == null) {
      level = 0;
    }
    if (!((ref = this.children) != null ? ref.length : void 0)) {
      return;
    }
    this.children.sort(func);
    ref1 = this.children;
    for (j = 0, len = ref1.length; j < len; j++) {
      node = ref1[j];
      node.sort(func, level + 1);
    }
    if (level === 0 && this.isRendered()) {
      this.reload();
    }
    return this;
  };

  ListViewTreeNode.prototype.close = function() {
    assert(this.father, "ListViewTreeNode.close()", "Cannot close root node", {
      node: this
    });
    assert(!this.isLoading(), "ListViewTreeNode.close", "Cannot close node, during opening...", {
      node: this,
      tree: this.getTree()
    });
    this.do_open = false;
    if (this.father.is_open) {
      this.removeFromDOM(false);
      this.replaceSelf();
    }
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.removeFromDOM = function(remove_self) {
    var c, j, len, ref, tree;
    if (remove_self == null) {
      remove_self = true;
    }
    this.abortLoading();
    if (this.is_open) {
      this.do_open = true;
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        c.removeFromDOM();
      }
    } else {
      this.do_open = false;
    }
    if (remove_self) {
      if (this.__is_rendered) {
        tree = this.getTree();
        if (tree && !tree.isDestroyed()) {
          if (this.getRowIdx() === null) {
            if (!this.isRoot()) {
              tree.removeDeferredRow(this);
            }
          } else {
            tree.removeRow(this.getRowIdx());
          }
        }
        this.__is_rendered = false;
      }
    }
    this.is_open = false;
    return this;
  };

  ListViewTreeNode.prototype.replaceSelf = function() {
    var tree;
    if (this.father) {
      if (tree = this.getTree()) {
        tree.replaceRow(this.getRowIdx(), this.render());
        if (this.selected) {
          tree.rowAddClass(this.getRowIdx(), ListViewRow.defaults.selected_class);
        }
      }
      return CUI.resolvedPromise();
    } else if (this.is_open) {
      this.removeFromDOM(false);
      return this.open();
    } else {
      return CUI.resolvedPromise();
    }
  };

  ListViewTreeNode.prototype.openRecursively = function() {
    return this.__actionRecursively("open");
  };

  ListViewTreeNode.prototype.closeRecursively = function() {
    return this.__actionRecursively("close");
  };

  ListViewTreeNode.prototype.__actionRecursively = function(action) {
    var dfr, ret;
    dfr = new CUI.Deferred();
    if (this.isLeaf()) {
      return dfr.resolve().promise();
    }
    if (action === "open") {
      ret = this.getLoading();
      if (!ret) {
        ret = this.open();
      }
    } else {
      ret = this.close();
    }
    ret.done((function(_this) {
      return function() {
        var child, j, len, promises, ref;
        promises = [];
        ref = _this.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          promises.push(child[action + "Recursively"]());
        }
        return CUI.when(promises).done(dfr.resolve).fail(dfr.reject);
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  ListViewTreeNode.prototype.isOpen = function() {
    return !!this.is_open;
  };

  ListViewTreeNode.prototype.isLoading = function() {
    return !!this.__loadingDeferred;
  };

  ListViewTreeNode.prototype.getLoading = function() {
    return this.__loadingDeferred;
  };

  ListViewTreeNode.prototype.abortLoading = function() {
    if (!this.__loadingDeferred) {
      return;
    }
    console.error("ListViewTreeNode.abortLoading: Aborting chunk loading.");
    if (this.__loadingDeferred.state === 'pending') {
      this.__loadingDeferred.reject();
    }
    this.__loadingDeferred = null;
  };

  ListViewTreeNode.prototype.__open_counter = 0;

  ListViewTreeNode.prototype.open = function() {
    var dfr, do_reject, do_resolve, func, load_children, open_counter, ret;
    assert(!this.isLoading(), "ListViewTreeNode.open", "Cannot open node " + (this.getUniqueId()) + ", during opening. This can happen if the same node exists multiple times in the same tree.", {
      node: this
    });
    this.__open_counter++;
    open_counter = this.__open_counter;
    if (this.is_open) {
      return CUI.resolvedPromise();
    }
    this.is_open = true;
    this.do_open = false;
    dfr = this.__loadingDeferred = new CUI.Deferred();
    do_resolve = (function(_this) {
      return function() {
        if (_this.__loadingDeferred.state() === "pending") {
          _this.__loadingDeferred.resolve(_this);
        }
        return _this.__loadingDeferred = null;
      };
    })(this);
    do_reject = (function(_this) {
      return function() {
        if (_this.__loadingDeferred.state() === "pending") {
          _this.__loadingDeferred.reject(_this);
        }
        return _this.__loadingDeferred = null;
      };
    })(this);
    load_children = (function(_this) {
      return function() {
        assert(CUI.isArray(_this.children), "ListViewTreeNode.open", "children to be loaded must be an Array", {
          children: _this.children,
          listViewTreeNode: _this
        });
        if (_this.children.length === 0) {
          if (!_this.isRoot()) {
            _this.replaceSelf();
          }
          do_resolve();
          return;
        }
        _this.initChildren();
        CUI.chunkWork.call(_this, {
          items: _this.children,
          chunk_size: 5,
          timeout: 1,
          call: function(items) {
            return CUI.chunkWork.call(_this, {
              items: items,
              chunk_size: 1,
              timeout: -1,
              call: function(_items) {
                if (open_counter < _this.__open_counter) {
                  return false;
                }
                return _this.__appendNode(_items[0], true);
              }
            });
          }
        }).done(function() {
          if (open_counter < _this.__open_counter) {
            return;
          }
          if (!_this.isRoot()) {
            _this.replaceSelf();
          }
          return do_resolve();
        }).fail(function() {
          var c, j, len, ref;
          if (open_counter < _this.__open_counter) {
            return;
          }
          ref = _this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            c.removeFromDOM();
          }
          return do_reject();
        });
      };
    })(this);
    if (this.children) {
      load_children();
    } else {
      func = this.opts.getChildren || this.getChildren;
      if (func) {
        ret = func.call(this);
        if (CUI.isArray(ret)) {
          this.children = ret;
          load_children();
        } else {
          assert(isPromise(ret), (getObjectClass(this)) + ".open", "returned children are not of type Promise or Array", {
            children: ret
          });
          ret.done((function(_this) {
            return function(children1) {
              _this.children = children1;
              if (open_counter < _this.__open_counter) {
                return;
              }
              load_children();
            };
          })(this)).fail(do_reject);
        }
      } else {
        if (!this.isRoot()) {
          this.replaceSelf();
        }
        do_resolve();
      }
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.prependChild = function(node) {
    return this.addNode(node, false);
  };

  ListViewTreeNode.prototype.addChild = function(node) {
    return this.addNode(node, true);
  };

  ListViewTreeNode.prototype.prependSibling = function(node) {
    var idx;
    idx = this.getChildIdx();
    return this.father.addNode(node, idx);
  };

  ListViewTreeNode.prototype.appendSibling = function(node) {
    var idx;
    idx = this.getChildIdx() + 1;
    if (idx > this.father.children.length - 1) {
      return this.father.addNode(node);
    } else {
      return this.father.addNode(node, idx);
    }
  };

  ListViewTreeNode.prototype.initChildren = function() {
    var idx, j, len, node, ref;
    ref = this.children;
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      node = ref[idx];
      node.setFather(this);
    }
  };

  ListViewTreeNode.prototype.addNode = function(node, append) {
    var dfr, promise;
    if (append == null) {
      append = true;
    }
    assert(!this.isLoading(), "ListViewTreeNode.addNode", "Cannot add node, during loading.", {
      node: this
    });
    if (!this.children) {
      this.children = [];
    }
    assert(CUI.isArray(this.children), "Tree.addNode", "Cannot add node, children needs to be an Array in node", {
      node: this,
      new_node: node
    });
    if (append === true) {
      this.children.push(node);
    } else {
      this.children.splice(append, 0, node);
    }
    node.setFather(this);
    if (!this.is_open) {
      if (this.isRoot() || !this.isRendered()) {
        return CUI.resolvedPromise(node);
      }
      dfr = new CUI.Deferred();
      this.open().done((function(_this) {
        return function() {
          return dfr.resolve(node);
        };
      })(this)).fail((function(_this) {
        return function() {
          return dfr.reject(node);
        };
      })(this));
      promise = dfr.promise();
    } else {
      promise = this.__appendNode(node, append);
    }
    return promise;
  };

  ListViewTreeNode.prototype.__appendNode = function(node, append) {
    var child_idx, child_nodes, last_node, tree;
    if (append == null) {
      append = true;
    }
    assert(node instanceof ListViewTreeNode, "ListViewTreeNode.__appendNode", "node must be instance of ListViewTreeNode", {
      node: this,
      new_node: node
    });
    assert(node.getFather() === this, "ListViewTreeNode.__appendNode", "node added must be child of current node", {
      node: this,
      new_node: node
    });
    if (append === false) {
      append = 0;
    }
    tree = this.getTree();
    if (tree != null ? tree.isDestroyed() : void 0) {
      return CUI.rejectedPromise(node);
    }
    if (!this.isRendered()) {
      return CUI.resolvedPromise(node);
    }
    child_idx = node.getChildIdx();
    if (this.isRoot()) {
      if (append === true || this.children.length === 1 || append + 1 === this.children.length) {
        tree.appendRow(node.render());
      } else {
        assert(this.children[append + 1], this.__cls + ".__addNode", "Node not found", {
          children: this.children,
          node: this,
          append: append
        });
        tree.insertRowBefore(this.children[append + 1].getRowIdx(), node.render());
      }
    } else if (child_idx === 0) {
      tree.insertRowAfter(this.getRowIdx(), node.render());
    } else if (append !== true) {
      tree.insertRowBefore(this.children[append + 1].getRowIdx(), node.render());
    } else {
      last_node = this.children[child_idx - 1];
      child_nodes = last_node.getOpenChildNodes();
      if (child_nodes.length) {
        last_node = child_nodes[child_nodes.length - 1];
      }
      tree.insertRowAfter(last_node.getRowIdx(), node.render());
    }
    if (node.selected) {
      tree.rowAddClass(node.getRowIdx(), ListViewRow.defaults.selected_class);
    }
    if (node.do_open) {
      return node.open();
    } else {
      return CUI.resolvedPromise(node);
    }
  };

  ListViewTreeNode.prototype.remove = function(keep_children_array, select_after) {
    var child_idx, children, dfr, remove_node, select_after_node;
    if (keep_children_array == null) {
      keep_children_array = false;
    }
    if (select_after == null) {
      select_after = true;
    }
    dfr = new CUI.Deferred();
    select_after_node = null;
    remove_node = (function(_this) {
      return function() {
        var ref, tree;
        _this.removeFromDOM();
        if ((ref = _this.father) != null) {
          ref.removeChild(_this, keep_children_array);
        }
        if (tree = _this.getTree()) {
          Events.trigger({
            node: tree,
            type: "row_removed"
          });
          if (select_after_node) {
            select_after_node.select().done(dfr.resolve).fail(dfr.reject);
          } else {
            dfr.resolve();
          }
        } else {
          dfr.resolve();
        }
      };
    })(this);
    if (select_after && !this.isRoot()) {
      children = this.getFather().children;
      if (children.length > 1) {
        child_idx = this.getChildIdx();
        if (child_idx === 0) {
          select_after = 1;
        } else {
          select_after = Math.min(children.length - 2, child_idx - 1);
        }
      }
      if (select_after !== null) {
        select_after_node = children[select_after];
      }
    }
    if (this.isSelected()) {
      this.deselect().fail(dfr.reject).done(remove_node);
    } else {
      remove_node();
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.removeChild = function(child, keep_children_array) {
    if (keep_children_array == null) {
      keep_children_array = false;
    }
    removeFromArray(child, this.children);
    if (this.children.length === 0 && !this.isRoot()) {
      this.is_open = false;
      if (!keep_children_array) {
        this.children = null;
      }
    }
    this.update();
    return child.setFather(null);
  };

  ListViewTreeNode.prototype.deselect = function(ev, new_node) {
    if (!this.getTree().isSelectable()) {
      return CUI.resolvedPromise();
    }
    return this.check_deselect(ev, new_node).done((function(_this) {
      return function() {
        _this.setSelectedNode();
        _this.removeSelectedClass();
        _this.selected = false;
        return _this.getTree().triggerNodeDeselect(ev, _this);
      };
    })(this));
  };

  ListViewTreeNode.prototype.allowRowMove = function() {
    return true;
  };

  ListViewTreeNode.prototype.check_deselect = function(ev, new_node) {
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.isSelected = function() {
    return !!this.selected;
  };

  ListViewTreeNode.prototype.addSelectedClass = function() {
    return this.getTree().rowAddClass(this.getRowIdx(), ListViewRow.defaults.selected_class);
  };

  ListViewTreeNode.prototype.removeSelectedClass = function() {
    return this.getTree().rowRemoveClass(this.getRowIdx(), ListViewRow.defaults.selected_class);
  };

  ListViewTreeNode.prototype.setSelectedNode = function(node, key) {
    if (node == null) {
      node = null;
    }
    if (key == null) {
      key = this.getSelectedNodeKey();
    }
    return this.getRoot()[this.getSelectedNodeKey()] = node;
  };

  ListViewTreeNode.prototype.getSelectedNode = function(key) {
    var ref;
    if (key == null) {
      key = this.getSelectedNodeKey();
    }
    return ((ref = this.getRoot()) != null ? ref[key] : void 0) || null;
  };

  ListViewTreeNode.prototype.getSelectedNodeKey = function() {
    return "selectedNode";
  };

  ListViewTreeNode.prototype.select = function(ev) {
    var dfr, do_select, sel_node;
    dfr = new CUI.Deferred();
    if (ev && (typeof this.getTree === "function" ? this.getTree().isSelectable() : void 0)) {
      if (typeof ev.stopPropagation === "function") {
        ev.stopPropagation();
      }
    }
    dfr.done((function(_this) {
      return function() {
        return _this.getTree().triggerNodeSelect(ev, _this);
      };
    })(this));
    if (!this.isSelectable()) {
      return dfr.reject().promise();
    }
    if (this.isSelected()) {
      return dfr.resolve().promise();
    }
    do_select = (function(_this) {
      return function() {
        _this.setSelectedNode(_this);
        return _this.openUpwards().done(function() {
          _this.addSelectedClass();
          _this.selected = true;
          return dfr.resolve();
        }).fail(dfr.reject);
      };
    })(this);
    sel_node = this.getSelectedNode();
    if (sel_node) {
      sel_node.check_deselect(ev, this).done((function(_this) {
        return function() {
          return sel_node.deselect(null, _this).done(function() {
            return do_select();
          }).fail(dfr.reject);
        };
      })(this)).fail(dfr.reject);
    } else {
      do_select();
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.openUpwards = function(level) {
    var dfr, promise;
    if (level == null) {
      level = 0;
    }
    dfr = new CUI.Deferred();
    if (this.isRoot()) {
      if (this.isLoading()) {
        this.getLoading().done((function(_this) {
          return function() {
            return dfr.resolve(_this);
          };
        })(this)).fail((function(_this) {
          return function() {
            return dfr.reject(_this);
          };
        })(this));
      } else if (this.is_open) {
        dfr.resolve(this);
      } else {
        dfr.reject(this);
      }
    } else {
      promise = this.father.openUpwards(level + 1);
      promise.done((function(_this) {
        return function() {
          var _promise;
          if (!_this.is_open && level > 0) {
            if (_this.isLoading()) {
              _promise = _this.getLoading();
            } else {
              _promise = _this.open();
            }
            return _promise.done(function() {
              return dfr.resolve(_this);
            }).fail(function() {
              return dfr.reject(_this);
            });
          } else {
            return dfr.resolve(_this);
          }
        };
      })(this));
      promise.fail((function(_this) {
        return function() {
          _this.do_open = true;
          if (level === 0) {
            return dfr.resolve(_this);
          } else {
            return dfr.reject(_this);
          }
        };
      })(this));
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.level = function() {
    if (this.isRoot()) {
      return 0;
    } else {
      return this.father.level() + 1;
    }
  };

  ListViewTreeNode.prototype.renderContent = function() {
    if (CUI.isFunction(this.html)) {
      return this.html.call(this.opts, this);
    } else if (this.html) {
      return this.html;
    } else {
      return new EmptyLabel({
        text: "<empty>"
      }).DOM;
    }
  };

  ListViewTreeNode.prototype.update = function(update_root) {
    var layout_stopped, tree;
    if (update_root == null) {
      update_root = false;
    }
    if (!update_root && (!this.__is_rendered || this.isRoot())) {
      return CUI.resolvedPromise();
    }
    tree = this.getTree();
    layout_stopped = tree != null ? tree.stopLayout() : void 0;
    return this.replaceSelf().done((function(_this) {
      return function() {
        if (layout_stopped) {
          return tree.startLayout();
        }
      };
    })(this));
  };

  ListViewTreeNode.prototype.reload = function() {
    assert(!this.isLoading(), "ListViewTreeNode.reload", "Cannot reload node, during opening...", {
      node: this,
      tree: this.getTree()
    });
    if (this.isRoot()) {
      return this.replaceSelf();
    } else if (this.is_open) {
      this.close();
      this.do_open = true;
      return this.open();
    } else {
      if (this.opts.children) {
        this.children = null;
      }
      return this.update();
    }
  };

  ListViewTreeNode.prototype.showSpinner = function() {
    if (this.__is_rendered) {
      this.__handleDiv.empty();
      this.__handleDiv.append(new Icon({
        icon: "spinner"
      }).DOM);
    }
    return this;
  };

  ListViewTreeNode.prototype.hideSpinner = function() {
    if (this.__is_rendered) {
      this.__handleDiv.empty();
      if (this.__handleIcon) {
        this.__handleDiv.append(new Icon({
          icon: this.__handleIcon
        }).DOM);
      } else {

      }
    }
    return this;
  };

  ListViewTreeNode.prototype.render = function() {
    var cls, con, content, contentDiv, element, i, j, k, len, ref, ref1;
    assert(!this.isRoot(), "ListViewTreeNode.render", "Unable to render root node.");
    this.removeColumns();
    element = $div("cui-tree-node level-" + (this.level()));
    this.__is_rendered = true;
    for (i = j = 1, ref = this.level(); j < ref; i = j += 1) {
      element.append($div("cui-tree-node-spacer"));
    }
    cls = ["cui-tree-node-handle"];
    if (this.is_open) {
      this.__handleIcon = "tree_close";
      cls.push("cui-tree-node-is-open");
    } else if (this.isLeaf()) {
      this.__handleIcon = null;
      cls.push("cui-tree-node-is-leaf");
    } else {
      this.__handleIcon = "tree_open";
      cls.push("cui-tree-node-is-closed");
    }
    if (((ref1 = this.children) != null ? ref1.length : void 0) === 0) {
      cls.push("cui-tree-node-no-children");
    }
    this.__handleDiv = $div(cls.join(" "));
    if (this.__handleIcon) {
      this.__handleDiv.append(new Icon({
        icon: this.__handleIcon
      }).DOM);
    }
    element.append(this.__handleDiv);
    this.prependColumn(new ListViewColumn({
      element: element,
      "class": "cui-tree-node-column cui-tree-node-level-" + (this.level()),
      colspan: this.colspan
    }));
    contentDiv = $div("cui-tree-node-content");
    content = this.renderContent();
    if (CUI.isArray(content)) {
      for (k = 0, len = content.length; k < len; k++) {
        con = content[k];
        contentDiv.append((con != null ? con.DOM : void 0) || content);
      }
    } else {
      contentDiv.append((content != null ? content.DOM : void 0) || content);
    }
    element.append(contentDiv);
    return this;
  };

  ListViewTreeNode.prototype.moveToNewFather = function(new_father, new_child_idx) {
    var old_father;
    old_father = this.father;
    old_father.removeChild(this);
    new_father.children.splice(new_child_idx, 0, this);
    this.setFather(new_father);
    old_father.reload();
    return new_father.reload();
  };

  ListViewTreeNode.prototype.moveNodeBefore = function(to_node, new_father, after) {
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.moveNodeAfter = function(to_node, new_father, after) {};

  return ListViewTreeNode;

})(CUI.ListViewRow);

ListViewTreeNode = CUI.ListViewTreeNode;
// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewTreeHeaderNode = (function(superClass) {
  extend(ListViewTreeHeaderNode, superClass);

  function ListViewTreeHeaderNode() {
    return ListViewTreeHeaderNode.__super__.constructor.apply(this, arguments);
  }

  ListViewTreeHeaderNode.prototype.initOpts = function() {
    ListViewTreeHeaderNode.__super__.initOpts.call(this);
    return this.addOpts({
      headers: {
        check: function(v) {
          return v.length > 0;
        }
      }
    });
  };

  ListViewTreeHeaderNode.prototype.render = function() {
    var header, i, idx, len, ref;
    this.__is_rendered = true;
    ref = this._headers;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      header = ref[idx];
      this.addColumn(new ListViewHeaderColumn(header));
    }
    return this;
  };

  return ListViewTreeHeaderNode;

})(CUI.ListViewTreeNode);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewColumn,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewColumn = (function(superClass) {
  extend(ListViewColumn, superClass);

  function ListViewColumn() {
    this.getColspan = bind(this.getColspan, this);
    this.setColspan = bind(this.setColspan, this);
    return ListViewColumn.__super__.constructor.apply(this, arguments);
  }

  ListViewColumn.prototype.readOpts = function() {
    ListViewColumn.__super__.readOpts.call(this);
    this.__cl = this._class || "";
    return this.__attrs = this._attrs || null;
  };

  ListViewColumn.prototype.initOpts = function() {
    ListViewColumn.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        "default": "",
        check: String
      },
      attrs: {
        "default": null,
        check: "PlainObject"
      },
      text: {
        check: String
      },
      colspan: {
        check: "Integer"
      },
      element: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      onSetElement: {
        check: Function
      }
    });
  };

  ListViewColumn.prototype.setRow = function(listViewRow) {
    this.listViewRow = listViewRow;
  };

  ListViewColumn.prototype.getRow = function() {
    return this.listViewRow;
  };

  ListViewColumn.prototype.setColumnIdx = function(col_i) {
    this.col_i = col_i;
    return this;
  };

  ListViewColumn.prototype.getColumnIdx = function() {
    return this.col_i;
  };

  ListViewColumn.prototype.render = function() {
    if (!isUndef(this._element)) {
      if (this._element.DOM) {
        return this._element.DOM;
      } else {
        return this._element;
      }
    } else if (!isEmpty(this._text)) {
      return new Label({
        text: this._text
      }).DOM;
    } else {
      return null;
    }
  };

  ListViewColumn.prototype.getAttrs = function() {
    return this.__attrs || {};
  };

  ListViewColumn.prototype.setElement = function(__element) {
    this.__element = __element;
    this.addClass(this.getClass());
    if (this.__attrs) {
      CUI.DOM.setAttributeMap(this.__element, this.__attrs);
    }
    if (typeof this._onSetElement === "function") {
      this._onSetElement(this);
    }
    return this.__element;
  };

  ListViewColumn.prototype.getElement = function() {
    return this.__element;
  };

  ListViewColumn.prototype.getClass = function() {
    return this.__cl;
  };

  ListViewColumn.prototype.addClass = function(cls) {
    if (!this.__element) {
      this.__cl += " " + cls;
    } else if (this.__element instanceof HTMLElement) {
      CUI.DOM.addClass(this.__element, cls);
    }
    return this;
  };

  ListViewColumn.prototype.removeClass = function(cls) {
    if (this.__element instanceof HTMLElement) {
      CUI.DOM.removeClass(this.__element, cls);
    }
    return this;
  };

  ListViewColumn.prototype.setColspan = function(colspan) {
    return this._colspan = colspan;
  };

  ListViewColumn.prototype.getColspan = function() {
    var cp;
    if (CUI.isFunction(this._colspan)) {
      cp = parseInt(this._colspan());
    } else {
      cp = parseInt(this._colspan);
    }
    if (cp > 1) {
      return cp;
    } else {
      return 1;
    }
  };

  return ListViewColumn;

})(CUI.Element);

ListViewColumn = CUI.ListViewColumn;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewColumnEmpty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnEmpty = (function(superClass) {
  extend(ListViewColumnEmpty, superClass);

  function ListViewColumnEmpty() {
    return ListViewColumnEmpty.__super__.constructor.apply(this, arguments);
  }

  ListViewColumnEmpty.prototype.render = function() {};

  return ListViewColumnEmpty;

})(ListViewColumn);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewHeaderColumn,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewHeaderColumn = (function(superClass) {
  extend(ListViewHeaderColumn, superClass);

  function ListViewHeaderColumn() {
    return ListViewHeaderColumn.__super__.constructor.apply(this, arguments);
  }

  ListViewHeaderColumn.prototype.initOpts = function() {
    ListViewHeaderColumn.__super__.initOpts.call(this);
    this.removeOpt("text");
    this.addOpts({
      spacer: {
        check: Boolean
      },
      rotate_90: {
        check: Boolean
      },
      label: {
        check: function(v) {
          if (CUI.isPlainObject(v) || v instanceof Label) {
            return true;
          } else {
            return false;
          }
        }
      }
    });
  };

  ListViewHeaderColumn.prototype.readOpts = function() {
    ListViewHeaderColumn.__super__.readOpts.call(this);
    if (this._label instanceof Label) {
      return this.__label = this._label;
    } else if (this._label) {
      this._label.rotate_90 = this._rotate_90;
      return this.__label = new CUI.defaults["class"].Label(this._label);
    }
  };

  ListViewHeaderColumn.prototype.setElement = function(__element) {
    var coldef, listView, move_handle;
    this.__element = __element;
    ListViewHeaderColumn.__super__.setElement.call(this, this.__element);
    if (this._rotate_90) {
      this.addClass("cui-lv-td-rotate-90");
    }
    this.addClass("cui-lv-th");
    listView = this.getRow().getListView();
    if (!listView.hasResizableColumns()) {
      return this.__element;
    }
    coldef = listView.getColdef(this.getColumnIdx());
    if (coldef === "fixed") {
      return this.__element;
    }
    move_handle = CUI.DOM.element("DIV", {
      "class": "cui-lv-col-resize-handle"
    });
    new CUI.ListViewColResize({
      element: move_handle,
      row: this.getRow(),
      column: this
    });
    CUI.DOM.append(this.__element, move_handle);
    return this.__element;
  };

  ListViewHeaderColumn.prototype.render = function() {
    var arr;
    if (this._spacer) {
      arr = [$div("cui-tree-node-spacer")];
    } else {
      arr = [];
    }
    if (this._element) {
      arr.push(this._element);
    } else if (this.__label) {
      arr.push(this.__label);
    }
    return arr;
  };

  return ListViewHeaderColumn;

})(ListViewColumn);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewColumnRowMoveHandle,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnRowMoveHandle = (function(superClass) {
  extend(ListViewColumnRowMoveHandle, superClass);

  function ListViewColumnRowMoveHandle() {
    return ListViewColumnRowMoveHandle.__super__.constructor.apply(this, arguments);
  }

  ListViewColumnRowMoveHandle.prototype.setElement = function(cell) {
    var row;
    ListViewColumnRowMoveHandle.__super__.setElement.call(this, cell);
    row = this.getRow();
    if (!row.isMovable()) {
      return;
    }
    if (CUI.ListView.defaults.row_move_handle_tooltip) {
      new Tooltip({
        text: CUI.ListView.defaults.row_move_handle_tooltip,
        element: cell
      });
    }
    row.getListView().getRowMoveTool({
      row: row,
      element: cell
    });
  };

  ListViewColumnRowMoveHandle.prototype.render = function() {
    return CUI.DOM.element("DIV", {
      "class": "cui-drag-handle-row"
    });
  };

  return ListViewColumnRowMoveHandle;

})(ListViewColumn);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ListViewColumnRowMoveHandlePlaceholder,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnRowMoveHandlePlaceholder = (function(superClass) {
  extend(ListViewColumnRowMoveHandlePlaceholder, superClass);

  function ListViewColumnRowMoveHandlePlaceholder() {
    return ListViewColumnRowMoveHandlePlaceholder.__super__.constructor.apply(this, arguments);
  }

  return ListViewColumnRowMoveHandlePlaceholder;

})(ListViewColumnEmpty);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewDraggable = (function(superClass) {
  extend(ListViewDraggable, superClass);

  function ListViewDraggable() {
    return ListViewDraggable.__super__.constructor.apply(this, arguments);
  }

  ListViewDraggable.prototype.initOpts = function() {
    ListViewDraggable.__super__.initOpts.call(this);
    this.removeOpt("helper");
    return this.addOpts({
      row: {
        mandatory: true,
        check: ListViewRow
      }
    });
  };

  ListViewDraggable.prototype.readOpts = function() {
    ListViewDraggable.__super__.readOpts.call(this);
    return this.__row_i = this._row.getRowIdx();
  };

  ListViewDraggable.prototype.get_marker = function(cls) {
    if (cls == null) {
      cls = "";
    }
    return CUI.DOM.element("DIV", {
      "class": "cui-lv-draggable " + cls
    });
  };

  return ListViewDraggable;

})(CUI.Draggable);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewRowMove = (function(superClass) {
  extend(ListViewRowMove, superClass);

  function ListViewRowMove() {
    return ListViewRowMove.__super__.constructor.apply(this, arguments);
  }

  ListViewRowMove.prototype.initOpts = function() {
    ListViewRowMove.__super__.initOpts.call(this);
    this.removeOpt("helper");
    return this.addOpts({
      row: {
        mandatory: true,
        check: ListViewRow
      }
    });
  };

  ListViewRowMove.prototype.readOpts = function() {
    ListViewRowMove.__super__.readOpts.call(this);
    this.__row_i = this._row.getRowIdx();
    this.__display_row_i = this._row.getDisplayRowIdx();
    return this.__listView = this._row.getListView();
  };

  ListViewRowMove.prototype.get_helper = function(ev, gd, diff) {
    return this.get_marker("cui-lv-row-move");
  };

  ListViewRowMove.prototype.get_helper_contain_element = function() {
    return this.__listView.getBottom();
  };

  ListViewRowMove.prototype.get_axis = function() {
    return "y";
  };

  ListViewRowMove.prototype.get_init_helper_pos = function(node, gd) {
    var rect;
    rect = this.__listView.getRowGridRect(this.__row_i);
    return {
      top: rect.top_abs,
      left: rect.left_abs,
      width: rect.width,
      height: rect.height
    };
  };

  ListViewRowMove.prototype.init_helper = function() {
    this.movableTargetDiv = this.get_marker("cui-lv-row-move-target");
    CUI.DOM.append(this.__listView.getGrid(), this.movableTargetDiv);
    return ListViewRowMove.__super__.init_helper.call(this);
  };

  ListViewRowMove.prototype.do_drag = function(ev, $target, diff) {
    var cell;
    ListViewRowMove.__super__.do_drag.call(this, ev, $target, diff);
    cell = this.__listView.getCellByTarget($target);
    if (cell) {
      cell.clientX = ev.clientX();
      cell.clientY = ev.clientY();
      if (cell.display_row_i >= this.__listView.fixedRowsCount) {
        this.showHorizontalTargetMarker(cell);
      }
    }
  };

  ListViewRowMove.prototype.cleanup_drag = function(ev) {
    ListViewRowMove.__super__.cleanup_drag.call(this, ev);
    CUI.DOM.remove(this.movableTargetDiv);
    return this.movableTargetDiv = null;
  };

  ListViewRowMove.prototype.end_drag = function(ev) {
    var source_node, target_node;
    ListViewRowMove.__super__.end_drag.call(this, ev);
    if (!this.target) {
      return;
    }
    source_node = this._row;
    target_node = this.__listView.getListViewRow(this.target.row_i);
    globalDrag.noClickKill = true;
    if (source_node.moveRow) {
      return source_node.moveRow(this.__listView, target_node, this.target.after);
    } else {
      return this.__listView.moveRow(this.__row_i, this.target.row_i, this.target.after);
    }
  };

  ListViewRowMove.prototype.showHorizontalTargetMarker = function(cell) {
    this.showHorizontalTargetMarkerSetTarget(cell);
    if (this.target.row_i === this.__row_i || (this.target.before_row_i === this.__row_i && this.target.after === false) || (this.target.after_row_i === this.__row_i && this.target.before === false)) {
      this.target = null;
      return CUI.DOM.hideElement(this.movableTargetDiv);
    } else {
      CUI.DOM.showElement(this.movableTargetDiv);
      return CUI.DOM.setStyle(this.movableTargetDiv, {
        left: this.target.left,
        top: this.target.top,
        width: this.target.width
      });
    }
  };

  ListViewRowMove.prototype.showHorizontalTargetMarkerSetTarget = function(cell) {
    var diff, row_rect;
    this.target = {
      row_i: cell.row_i
    };
    row_rect = this.__listView.getRowGridRect(cell.row_i);
    if (this.__display_row_i > 0) {
      this.target.before_row_i = this.__listView.getRowIdx(this.__display_row_i - 1);
    }
    if (this.__display_row_i < this.__listView.rowsCount - 1) {
      this.target.after_row_i = this.__listView.getRowIdx(this.__display_row_i + 1);
    }
    diff = cell.clientY - row_rect.top_abs;
    if (diff < row_rect.height / 2) {
      this.target.after = false;
      this.target.top = row_rect.top;
    } else {
      this.target.after = true;
      this.target.top = row_rect.top + row_rect.height;
    }
    this.target.width = row_rect.width;
    this.target.left = row_rect.left;
  };

  return ListViewRowMove;

})(CUI.ListViewDraggable);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewColResize = (function(superClass) {
  extend(ListViewColResize, superClass);

  function ListViewColResize() {
    return ListViewColResize.__super__.constructor.apply(this, arguments);
  }

  ListViewColResize.prototype.initOpts = function() {
    ListViewColResize.__super__.initOpts.call(this);
    this.removeOpt("helper");
    return this.addOpts({
      row: {
        mandatory: true,
        check: ListViewRow
      },
      column: {
        mandatory: true,
        check: ListViewColumn
      }
    });
  };

  ListViewColResize.prototype.readOpts = function() {
    ListViewColResize.__super__.readOpts.call(this);
    this.__row_i = this._row.getRowIdx();
    this.__display_row_i = this._row.getDisplayRowIdx();
    this.__listView = this._row.getListView();
    this.__col_i = this._column.getColumnIdx();
    Events.listen({
      type: "dblclick",
      node: this._element,
      instance: this,
      call: (function(_this) {
        return function(ev) {
          console.debug("list view", _this.__listView, _this.__col_i, _this.__row_i);
          return _this.__listView.resetColWidth(_this.__col_i);
        };
      })(this)
    });
  };

  ListViewColResize.prototype.get_axis = function() {
    return "x";
  };

  ListViewColResize.prototype.get_cursor = function(gd) {
    return "ew-resize";
  };

  ListViewColResize.prototype.get_helper = function(ev, gd, diff) {
    return this.get_marker("cui-lv-col-resize");
  };

  ListViewColResize.prototype.get_init_helper_pos = function() {
    var rect;
    rect = this.__listView.getCellGridRect(this.__row_i, this.__col_i);
    this.__contentWidthAdjust = rect.contentWidthAdjust;
    return {
      left: rect.left_abs,
      top: rect.top_abs,
      width: rect.width,
      height: this.__listView.getGrid().offsetHeight
    };
  };

  ListViewColResize.prototype.get_helper_pos = function(ev, $target, diff) {
    var helper_pos;
    helper_pos = ListViewColResize.__super__.get_helper_pos.call(this, ev, $target, diff);
    helper_pos.left = globalDrag.helperNodeStart.left;
    this.__new_width = globalDrag.helperNodeStart.width + diff.x;
    helper_pos.width = this.__new_width;
    return helper_pos;
  };

  ListViewColResize.prototype.start_drag = function(ev, $target, diff) {
    ListViewColResize.__super__.start_drag.call(this, ev, $target, diff);
    this.__inital_width = this.__listView.getManualColWidth(this.__col_i);
    return this;
  };

  ListViewColResize.prototype.do_drag = function(ev, $target, diff) {
    ListViewColResize.__super__.do_drag.call(this, ev, $target, diff);
    if (CUI.browser.ie) {
      return;
    }
    return this.__setColWidth(this.__new_width);
  };

  ListViewColResize.prototype.stop_drag = function(ev) {
    ListViewColResize.__super__.stop_drag.call(this, ev);
    if (this.__inital_width) {
      return this.__listView.setColWidth(this.__col_i, this.__initial_width);
    } else {
      return this.__listView.resetColWidth(this.__col_i);
    }
  };

  ListViewColResize.prototype.__setColWidth = function(width) {
    return this.__listView.setColWidth(this.__col_i, width - this.__contentWidthAdjust);
  };

  ListViewColResize.prototype.end_drag = function(ev) {
    ListViewColResize.__super__.end_drag.call(this, ev);
    return this.__setColWidth(this.__new_width);
  };

  ListViewColResize.prototype.destroy = function() {
    Events.ignore({
      instance: this
    });
    return ListViewColResize.__super__.destroy.call(this);
  };

  return ListViewColResize;

})(CUI.ListViewDraggable);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.ListViewTreeRowMove = (function(superClass) {
  extend(ListViewTreeRowMove, superClass);

  function ListViewTreeRowMove() {
    return ListViewTreeRowMove.__super__.constructor.apply(this, arguments);
  }

  ListViewTreeRowMove.prototype.initOpts = function() {
    ListViewTreeRowMove.__super__.initOpts.call(this);
    return this.addOpts({
      rowMoveWithinNodesOnly: {
        check: Boolean
      }
    });
  };

  ListViewTreeRowMove.prototype.get_init_helper_pos = function(node, gd) {
    var height, i, idx, len, pos, ref, row, row_i;
    pos = ListViewTreeRowMove.__super__.get_init_helper_pos.call(this, node, gd);
    this.blockedRows = [this.__row_i];
    height = this.__listView.getRowHeight(this.__row_i);
    ref = this._row.getRowsToMove();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      row = ref[idx];
      row_i = row.getRowIdx();
      this.blockedRows.push(row_i);
      height += this.__listView.getRowHeight(row_i);
    }
    pos.height = height;
    return pos;
  };

  ListViewTreeRowMove.prototype.showHorizontalTargetMarker = function(cell) {
    var ci, node;
    this.showHorizontalTargetMarkerSetTarget(cell);
    this.blockedAfterRows = [this.target.before_row_i];
    this.blockedBeforeRows = [this.target.after_row_i];
    node = this._row;
    if ((ci = node.getChildIdx()) < node.father.children.length - 1) {
      this.blockedBeforeRows.push(node.father.children[ci + 1].getRowIdx());
    }
    if (!this.allowRowMove()) {
      this.target = null;
      return CUI.DOM.hideElement(this.movableTargetDiv);
    } else {
      CUI.DOM.showElement(this.movableTargetDiv);
      return CUI.DOM.setStyle(this.movableTargetDiv, {
        left: this.target.left,
        top: this.target.top,
        width: this.target.width,
        height: this.target.height
      });
    }
  };

  ListViewTreeRowMove.prototype.allowRowMove = function() {
    var allow, from_node, new_father, ref, ref1, ref2, ref3, to_node;
    allow = true;
    if ((ref = this.target.row_i, indexOf.call(this.blockedRows, ref) >= 0) || ((ref1 = this.target.row_i, indexOf.call(this.blockedAfterRows, ref1) >= 0) && this.target.after) || ((ref2 = this.target.row_i, indexOf.call(this.blockedBeforeRows, ref2) >= 0) && !this.target.after)) {
      return false;
    }
    ref3 = this.__listView.getNodesForMove(this.__row_i, this.target.row_i, this.target.after), from_node = ref3[0], to_node = ref3[1], new_father = ref3[2];
    if (this._rowMoveWithinNodesOnly && new_father) {
      return false;
    }
    if (!from_node.allowRowMove(to_node, new_father, this.target.after)) {
      return false;
    }
    return true;
  };

  return ListViewTreeRowMove;

})(CUI.ListViewRowMove);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var ItemList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ItemList = (function(superClass) {
  extend(ItemList, superClass);

  function ItemList() {
    return ItemList.__super__.constructor.apply(this, arguments);
  }

  ItemList.prototype.init = function() {
    ItemList.__super__.init.call(this);
    this.addClass("cui-item-list");
    this.__body = new Template({
      name: "item-list-body"
    });
    return this.append(this.__body, "center");
  };

  ItemList.prototype.initOpts = function() {
    ItemList.__super__.initOpts.call(this);
    this.addOpts({
      items: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v) || CUI.isArray(v);
        }
      },
      active_item_idx: {
        check: "Integer"
      },
      has_items: {
        "default": false,
        check: Boolean
      },
      allow_null: {
        check: Boolean
      },
      onClick: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      orientation: {
        "default": "vertical",
        check: ["horizontal", "vertical"]
      }
    });
    return this;
  };

  ItemList.prototype.readOpts = function() {
    ItemList.__super__.readOpts.call(this);
    if (this._orientation === "horizontal") {
      CUI.error("new CUI.ItemList, orientation == horizontal needs implementation!");
    }
    return this;
  };

  ItemList.prototype.setActiveIdx = function(__active_idx) {
    this.__active_idx = __active_idx;
  };

  ItemList.prototype.getActiveIdx = function() {
    return this.__active_idx;
  };

  ItemList.prototype.getBody = function() {
    return this.__body;
  };

  ItemList.prototype.getItemByValue = function(value) {
    var btn, el, i, len, ref;
    ref = this.__body.DOM.children;
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      btn = DOM.data(el, "element");
      if (!(btn instanceof Button)) {
        continue;
      }
      if (btn.getValue() === value) {
        return btn;
      }
    }
    return null;
  };

  ItemList.prototype.hasItems = function(event) {
    var items;
    if (this._has_items) {
      return true;
    }
    items = this.__getItems(event);
    if (isPromise(items)) {
      CUI.warn("ItemList.hasItems: opts.items Function returned a Promise. Set opts.has_items to true, in order to avoid the call of that Function.");
      return true;
    } else {
      return items.length > 0;
    }
  };

  ItemList.prototype.__getItems = function(event) {
    if (CUI.isFunction(this._items)) {
      return this._items(event, this) || [];
    } else {
      return this._items;
    }
  };

  ItemList.prototype.getItems = function(event) {
    var items;
    items = this.__getItems(event);
    if (isPromise(items)) {
      return items;
    } else {
      return new CUI.Deferred().resolve(items);
    }
  };

  ItemList.prototype.__initActiveIdx = function() {
    var active_idx, i, idx, item, items, len;
    active_idx = this._active_item_idx;
    if (isUndef(active_idx)) {
      items = this.__getItems();
      if (isPromise(items)) {
        active_idx = null;
      } else {
        for (idx = i = 0, len = items.length; i < len; idx = ++i) {
          item = items[idx];
          if (!item) {
            continue;
          }
          if (isUndef(item.active)) {
            continue;
          }
          if (item.active) {
            active_idx = idx;
            break;
          }
          if (isUndef(active_idx)) {
            active_idx = null;
          }
        }
      }
    }
    if (!isUndef(active_idx)) {
      this.__active_idx = active_idx;
      this.__radio = "item-list--" + this.getUniqueId();
    }
    return this.__isInitActiveIdx = true;
  };

  ItemList.prototype.render = function(menu, event) {
    var promise;
    if (!this.__isInitActiveIdx) {
      this.__initActiveIdx();
    }
    this.__body.empty();
    promise = this.getItems(event);
    promise.done((function(_this) {
      return function(items) {
        var _item, fn, i, idx, item, len, list_has_button_left, opt_keys;
        opt_keys = CUI.defaults["class"].Button.getOptKeys();
        list_has_button_left = false;
        fn = function(item, idx) {
          var btn, divider, j, k, label, len1, listenButtonClick, opts;
          if (!item || item.hidden === true || (typeof item.hidden === "function" ? item.hidden() : void 0)) {
            return;
          }
          if (item.divider) {
            divider = $div("cui-menu-divider cui-item-list-divider", {
              role: "menu-item"
            });
            _this.__body.append(divider);
            return;
          }
          if (item.label) {
            if (item.label instanceof Label) {
              label = item.label;
            } else if (CUI.isPlainObject(item.label)) {
              label = new CUI.defaults["class"].Label(item.label);
            } else {
              label = new CUI.defaults["class"].Label({
                text: item.label
              });
            }
            label.addClass("cui-menu-item");
            _this.__body.append(label.DOM);
            return;
          }
          if (item.content) {
            _this.__body.DOM.append(item.content.DOM || item.content);
            return;
          }
          listenButtonClick = function(btn) {
            Events.listen({
              type: "cui-button-click",
              node: btn,
              call: function(ev, info) {
                var dim, el, hide;
                if (typeof _this._onClick === "function") {
                  _this._onClick(info.event, btn, item, idx);
                }
                if (!(menu != null ? menu.isAutoCloseAfterClick() : void 0) || btn.hasMenu()) {
                  return;
                }
                hide = function() {
                  return menu.hideAll(info.event);
                };
                el = menu.getElement();
                if (el) {
                  dim = DOM.getDimensions(menu.getElement()[0]);
                  if (dim.clientWidth === 0 && dim.clientHeight === 0) {
                    hide();
                    return;
                  }
                }
                return CUI.setTimeout({
                  call: hide
                });
              }
            });
          };
          if (item instanceof Button) {
            listenButtonClick(item);
            if (item.hasLeft()) {
              list_has_button_left = true;
            }
          }
          if (item instanceof Button || item instanceof DataField || item instanceof Label) {
            _this.__body.append(item.DOM);
            return;
          }
          opts = {
            role: "menu-item",
            radio: _this.__radio,
            radio_allow_null: _this._allow_null,
            onActivate: function(btn, flags) {
              if (_this.__radio) {
                _this.__active_idx = idx;
              }
              return typeof _this._onActivate === "function" ? _this._onActivate(btn, item, idx, flags) : void 0;
            },
            onDeactivate: function(btn, flags) {
              if (_this.__radio) {
                _this.__active_idx = null;
              }
              return typeof _this._onDeactivate === "function" ? _this._onDeactivate(btn, item, idx, flags) : void 0;
            }
          };
          for (j = 0, len1 = opt_keys.length; j < len1; j++) {
            k = opt_keys[j];
            if (item.hasOwnProperty(k) && !opts.hasOwnProperty(k)) {
              opts[k] = item[k];
            }
          }
          if (_this.__radio) {
            if (_this.__active_idx === idx) {
              opts.active = true;
            }
          }
          if (menu) {
            opts.menu_parent = menu;
          }
          btn = new CUI.defaults["class"].Button(opts);
          listenButtonClick(btn);
          if (btn.hasLeft()) {
            list_has_button_left = true;
          }
          _this.__body.append(btn);
        };
        for (idx = i = 0, len = items.length; i < len; idx = ++i) {
          _item = items[idx];
          if (CUI.isFunction(_item)) {
            item = _item(_this, menu, event);
          } else {
            item = _item;
          }
          fn(item, idx);
          if (list_has_button_left) {
            _this.__body.addClass("cui-item-list--has-button-left");
          } else {
            _this.__body.removeClass("cui-item-list--has-button-left");
          }
        }
      };
    })(this));
    return promise;
  };

  ItemList.prototype.destroy = function() {
    var ref;
    ItemList.__super__.destroy.call(this);
    return (ref = this.__body) != null ? ref.destroy() : void 0;
  };

  return ItemList;

})(CUI.VerticalLayout);

ItemList = CUI.ItemList;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Menu,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Menu = (function(superClass) {
  extend(Menu, superClass);

  function Menu(opts) {
    this.opts = opts != null ? opts : {};
    Menu.__super__.constructor.call(this, this.opts);
    if (this._itemList) {
      this.setItemList(this._itemList);
    }
  }

  Menu.prototype.initOpts = function() {
    Menu.__super__.initOpts.call(this);
    this.addOpts({
      itemList: {
        check: function(v) {
          return v instanceof CUI.ItemList || CUI.isPlainObject(v);
        }
      },
      auto_close_after_click: {
        "default": true,
        check: Boolean
      },
      parent_menu: {
        check: Menu
      },
      onBeforeItemListInit: {
        check: Function
      }
    });
    return this;
  };

  Menu.prototype.readOpts = function() {
    Menu.__super__.readOpts.call(this);
    if (!this.opts.placements) {
      if (this._parent_menu) {
        this._placements = ["es", "en", "ws", "wn"];
      } else if (this._show_at_position) {
        this._placements = ["es", "en", "ws", "wn"];
      } else {
        this._placements = ["se", "sw", "ne", "nw"];
      }
    }
    if (!this.opts.placement) {
      this._placement = this._placements[0];
    }
  };

  Menu.prototype.show = function(__event) {
    this.__event = __event;
    assert(!this.isDestroyed(), (getObjectClass(this)) + ".show", "Element is already destroyed.");
    if (this.__itemList) {
      this.__itemList.render(this, this.__event).done((function(_this) {
        return function() {
          return Menu.__super__.show.call(_this, _this.__event);
        };
      })(this));
    } else {
      Menu.__super__.show.call(this, this.__event);
    }
    Events.listen({
      type: "keydown",
      instance: this,
      node: this.DOM,
      capture: true,
      call: (function(_this) {
        return function(ev) {
          if (ev.hasModifierKey()) {
            return;
          }
          if (ev.keyCode() === 27) {
            _this.hide();
            return ev.stop();
          }
        };
      })(this)
    });
    return this;
  };

  Menu.prototype.hasItems = function(event) {
    var ref;
    return (ref = this.__itemList) != null ? ref.hasItems(event) : void 0;
  };

  Menu.prototype.getItemList = function() {
    return this.__itemList;
  };

  Menu.prototype.setItemList = function(itemList) {
    if (itemList instanceof CUI.ItemList) {
      this.__itemList = itemList;
    } else {
      delete itemList.maximize;
      itemList.maximize_vertical = false;
      itemList.maximize_horizontal = true;
      this.__itemList = new CUI.ItemList(itemList);
    }
    this.replace(this.__itemList);
    this.proxy(this.__itemList, ["setActiveIdx"]);
    if (this.isShown()) {
      this.__itemList.render(this, this.__event).done((function(_this) {
        return function() {
          return _this.position();
        };
      })(this));
    }
    return this;
  };

  Menu.prototype.isAutoCloseAfterClick = function() {
    return this._auto_close_after_click;
  };

  Menu.prototype.destroy = function() {
    var ref;
    if ((ref = this.__itemList) != null) {
      ref.destroy();
    }
    return Menu.__super__.destroy.call(this);
  };

  Menu.prototype.hide = function(ev) {
    Menu.__super__.hide.call(this, ev);
    return this;
  };

  Menu.prototype.hideAll = function(ev) {
    var ref;
    this.hide(ev);
    if ((ref = this._parent_menu) != null) {
      ref.hideAll(ev);
    }
    return this;
  };

  Menu.prototype.getButton = function() {
    var button, element;
    element = this.getOpt("element");
    if (!element || element instanceof CUI.Button) {
      return element;
    }
    button = DOM.data(element.DOM || element, "element");
    if (button instanceof CUI.Button) {
      return button;
    }
    return null;
  };

  return Menu;

})(CUI.Layer);

Menu = CUI.Menu;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Panel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Panel = (function(superClass) {
  extend(Panel, superClass);

  function Panel(opts) {
    this.opts = opts != null ? opts : {};
    Panel.__super__.constructor.call(this, this.opts);
    this.panel = new Template({
      name: "panel",
      map: {
        header: true,
        content: true
      }
    });
    this.registerTemplate(this.panel);
    if (this._content_placeholder) {
      this.append(this._content_placeholder, "content");
      this.__has_placeholder = true;
    }
    if (CUI.isFunction(this._content)) {
      if (!this._load_on_open) {
        this.loadContent();
      }
    } else if (this._content) {
      this.append(this._content, "content");
    }
    this.button = new Button({
      text: this._text,
      "class": "cui-panel-header-button",
      radio: this._radio,
      radio_allow_null: this._radio_allow_null,
      icon_active: this._icon_opened,
      icon_inactive: this._icon_closed,
      onActivate: (function(_this) {
        return function(btn, flags, event) {
          _this.open(!flags.initial_activate);
          return typeof _this._onActivate === "function" ? _this._onActivate(btn, flags, event) : void 0;
        };
      })(this),
      onDeactivate: (function(_this) {
        return function(btn, flags, event) {
          _this.close(!flags.initial_activate);
          return typeof _this._onDeactivate === "function" ? _this._onDeactivate(btn, flags, event) : void 0;
        };
      })(this)
    });
    this.append(this.button, "header");
    if (this._closed) {
      this.button.deactivate();
    } else {
      this.button.activate();
    }
  }

  Panel.prototype.initOpts = function() {
    Panel.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        mandatory: true,
        check: String
      },
      content: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      content_placeholder: {
        check: function(v) {
          return isContent(v);
        }
      },
      load_on_open: {
        check: Boolean
      },
      radio: {
        "default": "panel-switcher",
        check: function(v) {
          return isString(v) || v === true;
        }
      },
      radio_allow_null: {
        "default": true,
        mandatory: true,
        check: Boolean
      },
      closed: {
        "default": true,
        check: Boolean
      },
      icon_opened: {
        "default": "fa-angle-down",
        check: String
      },
      icon_closed: {
        "default": "fa-angle-right",
        check: String
      },
      footer_right: {},
      footer_left: {},
      onFirstActivate: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      }
    });
  };

  Panel.prototype.readOpts = function() {
    Panel.__super__.readOpts.call(this);
    return this;
  };

  Panel.prototype.isClosed = function() {
    return this.DOM.hasClass("cui-panel-closed");
  };

  Panel.prototype.isOpen = function() {
    return !this.isClosed();
  };

  Panel.prototype.close = function(trigger) {
    if (trigger == null) {
      trigger = true;
    }
    this.DOM.addClass("cui-panel-closed");
    if (trigger) {
      Events.trigger({
        type: "content-resize",
        node: this.DOM
      });
    }
    return this;
  };

  Panel.prototype.open = function(trigger) {
    var done;
    if (trigger == null) {
      trigger = true;
    }
    done = (function(_this) {
      return function() {
        _this.DOM.removeClass("cui-panel-closed");
        if (trigger) {
          Events.trigger({
            type: "content-resize",
            node: _this.DOM
          });
        }
      };
    })(this);
    if (this._load_on_open && !this.__content_loaded) {
      this.loadContent().done(done);
    } else {
      done();
    }
    return this;
  };

  Panel.prototype.loadContent = function() {
    var dfr, ret;
    if (CUI.isFunction(this._content)) {
      ret = this._content(this);
    } else {
      ret = this._content;
    }
    dfr = new CUI.Deferred();
    if (isPromise(ret)) {
      ret.always((function(_this) {
        return function(content) {
          _this.setContent(content);
          return dfr.resolve();
        };
      })(this));
    } else {
      this.setContent(ret);
      dfr.resolve();
    }
    this.__content_loaded = true;
    return dfr.promise();
  };

  Panel.prototype.setContent = function(content, key) {
    if (key == null) {
      key = "content";
    }
    if (content === false && this._content_placeholder) {
      return this;
    }
    this.__has_placeholder = false;
    this.replace(content, key);
    return this;
  };

  Panel.prototype.appendContent = function(content, key) {
    if (key == null) {
      key = "content";
    }
    if (this.__has_placeholder) {
      this.setContent(content, key);
    } else {
      this.append(content, key);
    }
    return this;
  };

  return Panel;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Input,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Input = (function(superClass) {
  extend(Input, superClass);

  function Input(opts) {
    var hint, j, k, len1, ref;
    this.opts = opts != null ? opts : {};
    Input.__super__.constructor.call(this, this.opts);
    this.addClass("cui-input");
    if (this._overwrite) {
      this.__getCursorBlocks = this.__overwriteBlocks;
    } else {
      this.__getCursorBlocks = this._getCursorBlocks;
    }
    if (this._content_size) {
      this.addClass("cui-input-content-size");
    }
    if (this.isRequired()) {
      this.addClass("cui-input-required");
    }
    if (this._checkInput) {
      this.addClass("cui-input-has-check-input");
      this.__checkInput = this._checkInput;
    }
    if (this._prevent_invalid_input) {
      this.addClass("cui-input-has-prevent-invalid-input");
    }
    this.__inputHints = {};
    this.__inputHintTexts = {};
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      hint = this["_" + k + "Hint"];
      if (!hint) {
        continue;
      }
      this.__inputHints[k];
      if (hint instanceof Label) {
        this.__inputHints[k] = hint;
      } else {
        this.__inputHints[k] = new CUI.defaults["class"].Label(hint);
      }
      this.__inputHints[k].addClass("cui-input-" + k + "-hint");
      this.__inputHintTexts[k] = this.__inputHints[k].getText();
      this.addClass("cui-input-has-" + k + "-hint");
    }
    this.__doSetContentSize = (function(_this) {
      return function() {
        return _this.__setContentSize();
      };
    })(this);
    return;
  }

  Input.prototype.initOpts = function() {
    Input.__super__.initOpts.call(this);
    return this.addOpts({
      spellcheck: {
        "default": false,
        check: Boolean
      },
      autocomplete: {
        "default": false,
        check: Boolean
      },
      overwrite: {
        check: Boolean
      },
      checkInput: {
        check: Function
      },
      getValueForDisplay: {
        check: Function
      },
      getValueForInput: {
        check: Function
      },
      correctValueForInput: {
        check: Function
      },
      emptyHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      invalidHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      validHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      maxLength: {
        check: function(v) {
          return v >= 0;
        }
      },
      onFocus: {
        check: Function
      },
      onClick: {
        check: Function
      },
      onKeyup: {
        check: Function
      },
      onSelectionchange: {
        check: Function
      },
      incNumbers: {
        "default": true,
        check: Boolean
      },
      onBlur: {
        check: Function
      },
      regexp: {
        check: String
      },
      regexp_flags: {
        "default": "",
        check: String
      },
      getInputBlocks: {
        check: Function
      },
      getCursorBlocks: {
        check: function(v) {
          return CUI.isFunction(v) && !this._overwrite;
        }
      },
      placeholder: {
        check: function(v) {
          return CUI.isFunction(v) || isString(v);
        }
      },
      readonly: {
        check: Boolean
      },
      readonly_select_all: {
        "default": true,
        check: Boolean
      },
      textarea: {
        check: Boolean
      },
      rows: {
        check: function(v) {
          return v >= 1;
        }
      },
      content_size: {
        "default": false,
        check: Boolean
      },
      prevent_invalid_input: {
        "default": false,
        check: Boolean
      },
      required: {
        "default": false,
        check: Boolean
      }
    });
  };

  Input.prototype.readOpts = function() {
    if (this.opts.readonly) {
      assert(!(this.opts.getCursorBlocks || this.opts.getInputBlocks || this.opts.checkInput), "new Input", "opts.readonly conflicts with opts.getCursorBlocks, opts.getInputBlocks, opts.checkInput.");
    }
    if (this.opts.textarea) {
      assert(!this.opts.autocomplete, "new Input", "opts.textarea does not work with opts.autocomplete", {
        opts: this.opts
      });
      assert(!this.opts.incNumbers, "new Input", "opts.textarea does not work with opts.incNumbers", {
        opts: this.opts
      });
    }
    Input.__super__.readOpts.call(this);
    if (this._readonly && this._readonly_select_all) {
      this._getCursorBlocks = (function(_this) {
        return function(v) {
          return [
            new InputBlock({
              start: 0,
              string: v
            })
          ];
        };
      })(this);
    }
    if (this._regexp) {
      this.__regexp = new RegExp(this._regexp, this._regexp_flags);
      this.__checkInput = (function(_this) {
        return function(value) {
          if (!_this.__checkInputRegexp(value)) {
            return false;
          } else if (_this._checkInput) {
            return _this._checkInput(value);
          } else {
            return true;
          }
        };
      })(this);
    }
    if (this._required) {
      this.__checkInput = (function(_this) {
        return function(value) {
          if (value.trim().length === 0) {
            return false;
          } else if (_this._checkInput) {
            return _this._checkInput(value);
          } else {
            return true;
          }
        };
      })(this);
    }
    if (this._spellcheck === false) {
      this.__spellcheck = "false";
    } else {
      this.__spellcheck = "default";
    }
    if (this._autocomplete === true) {
      this.__autocomplete = "on";
    } else if (this._autocomplete === false) {
      this.__autocomplete = "off";
    }
    return this;
  };

  Input.prototype.__checkInputRegexp = function(value) {
    if (this.__regexp.exec(value)) {
      return true;
    } else {
      return false;
    }
  };

  Input.prototype.setSpellcheck = function(spellcheck) {
    if (spellcheck) {
      return DOM.setAttribute(this.__input0, "spellcheck", "default");
    } else {
      return DOM.setAttribute(this.__input0, "spellcheck", "false");
    }
  };

  Input.prototype.setPlaceholder = function(placeholder) {
    return DOM.setAttribute(this.__input[0], "placeholder", placeholder);
  };

  Input.prototype.getPlaceholder = function() {
    if (!this._placeholder) {
      return void 0;
    }
    if (CUI.isFunction(this._placeholder)) {
      return this._placeholder(this, this.getData());
    } else {
      return this._placeholder;
    }
  };

  Input.prototype.__createElement = function(input_type) {
    var oldSizes;
    if (input_type == null) {
      input_type = "text";
    }
    if (this._textarea === true) {
      this.__input = $element("textarea", "cui-textarea", {
        placeholder: this.getPlaceholder(),
        tabindex: "0",
        maxLength: this._maxLength,
        id: "cui-input-" + this.getUniqueId(),
        spellcheck: this.__spellcheck
      });
    } else {
      this.__input = $element("input", "cui-input", {
        type: input_type,
        size: 1,
        placeholder: this.getPlaceholder(),
        tabindex: "0",
        maxLength: this._maxLength,
        id: "cui-input-" + this.getUniqueId(),
        spellcheck: this.__spellcheck,
        autocomplete: this.__autocomplete
      });
    }
    Events.listen({
      node: this.__input,
      type: "dragstart",
      call: function(ev) {
        return ev.preventDefault();
      }
    });
    Events.listen({
      node: this.__input,
      type: "keydown",
      call: (function(_this) {
        return function(ev) {
          var ref, ref1, ref2;
          _this.lastKeyDownEvent = ev;
          if (_this._incNumbers && !_this._textarea && !_this._readonly) {
            _this.incNumberBounds(ev);
          }
          if ((ref = ev.keyCode()) === 37 || ref === 39 || ref === 36 || ref === 35) {
            _this.moveCursor(ev);
            _this.showCursor(ev);
            return;
          }
          if ((ref1 = ev.keyCode()) === 9 || ref1 === 16 || ref1 === 17 || ref1 === 18 || ref1 === 27 || ref1 === 33 || ref1 === 34 || ref1 === 35 || ref1 === 36 || ref1 === 38 || ref1 === 40) {
            return;
          }
          if (!_this._textarea && ev.keyCode() === 13) {
            return;
          }
          if (ev.keyCode() === 8 && (0 === (ref2 = _this.__input0.selectionStart) && ref2 === _this.__input0.selectionEnd)) {
            return;
          }
          _this.__focusShadowInput();
        };
      })(this)
    });
    Events.listen({
      type: "keyup",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var ref;
          if ((ref = ev.keyCode()) === 37 || ref === 39 || ref === 36 || ref === 35) {
            ev.preventDefault();
            if (!_this.cursor) {
              _this.showCursor(ev);
            }
            return;
          }
          _this.initCursor(ev);
          _this.showCursor(ev);
          if (_this._onKeyup) {
            _this._onKeyup(_this, ev);
          }
        };
      })(this)
    });
    Events.listen({
      type: "focus",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var ref;
          if (_this.hasShadowFocus()) {
            return;
          }
          _this.enterInput();
          _this.addClass("cui-has-focus");
          _this.__initShadowInput();
          if (typeof _this._onFocus === "function") {
            _this._onFocus(_this, ev);
          }
          if ((ref = _this.__invalidTooltip) != null) {
            ref.show();
          }
          _this.__setCursor(ev);
        };
      })(this)
    });
    oldSizes = null;
    Events.listen({
      type: "mousedown",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var mev, trigger;
          oldSizes = [_this.__input0.offsetWidth, _this.__input0.offsetHeight];
          trigger = function() {
            if (oldSizes[0] !== _this.__input0.offsetWidth || oldSizes[1] !== _this.__input0.offsetHeight) {
              return Events.trigger({
                type: "content-resize",
                node: _this.__input
              });
            }
          };
          mev = Events.listen({
            type: "mousemove",
            call: function() {
              trigger();
            }
          });
          return Events.listen({
            type: "mouseup",
            only_once: true,
            capture: true,
            call: function(ev) {
              Events.ignore(mev);
            }
          });
        };
      })(this)
    });
    Events.listen({
      type: "mouseup",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          _this.__setCursor(ev);
        };
      })(this)
    });
    Events.listen({
      type: "blur",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          if (_this.hasShadowFocus()) {
            return;
          }
          _this.removeClass("cui-has-focus");
          _this.leaveInput();
          _this.__removeShadowInput();
          if (typeof _this._onBlur === "function") {
            _this._onBlur(_this, ev);
          }
        };
      })(this)
    });
    Events.listen({
      type: "input",
      node: this.__input,
      call: (function(_this) {
        return function(ev, info) {
          if (!ev.isDefaultPrevented()) {
            _this.checkInput();
            _this.moveCursor(ev);
            _this.showCursor(ev);
            if (_this.getValueForStore(_this.__input0.value) !== _this.getValue()) {
              _this.storeValue(_this.__input0.value);
            }
          }
        };
      })(this)
    });
    Events.listen({
      type: "paste",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          return _this.__focusShadowInput();
        };
      })(this)
    });
    Events.listen({
      type: "click",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          ev.stopPropagation();
          if (typeof _this._onClick === "function") {
            _this._onClick(_this, ev);
          }
        };
      })(this)
    });
    this.__input0 = this.__input[0];
    if (this._content_size) {
      DOM.waitForDOMInsert({
        node: this.__input
      }).done((function(_this) {
        return function() {
          if (_this.isDestroyed()) {
            return;
          }
          return _this.setContentSize();
        };
      })(this));
    }
    return this.__input;
  };

  Input.prototype.__setCursor = function(ev) {
    return CUI.setTimeout((function(_this) {
      return function() {
        var block, blocks, j, len1, s;
        _this.initCursor(ev);
        if (_this.cursor === null && (s = _this.__input0.selectionStart) === _this.__input0.selectionEnd && _this.__input0.selectionEnd !== _this.__input0.value.length) {
          blocks = _this.getInputBlocks();
          if (blocks.length > 0) {
            for (j = 0, len1 = blocks.length; j < len1; j++) {
              block = blocks[j];
              if ((block.start <= s && s <= block.end)) {
                _this.markBlock(ev, block);
                break;
              }
            }
          }
        }
        return _this.showCursor(ev);
      };
    })(this), 0);
  };

  Input.prototype.getValueForStore = function(value) {
    return value;
  };

  Input.prototype.storeValue = function(value, flags) {
    if (flags == null) {
      flags = {};
    }
    return Input.__super__.storeValue.call(this, this.getValueForStore(value), flags);
  };

  Input.prototype.handleSelectionChange = function() {
    var ref;
    return (ref = this._onSelectionchange) != null ? ref.apply(this, arguments) : void 0;
  };

  Input.prototype.getElement = function() {
    return this.__input;
  };

  Input.prototype.getUniqueIdForLabel = function() {
    return "cui-input-" + this.getUniqueId();
  };

  Input.prototype.markBlock = function(ev, bl) {
    this.__input0.setSelectionRange(bl.start, bl.end);
    return this.initCursor(ev);
  };

  Input.prototype.remove = function() {
    this.__removeShadowInput();
    return Input.__super__.remove.call(this);
  };

  Input.prototype.__focusShadowInput = function() {
    if (!this.__shadow) {
      return;
    }
    this.__shadow_focused = true;
    this.__shadow0.value = this.__input0.value;
    this.__shadow0.focus();
    return this.__shadow0.setSelectionRange(this.__input0.selectionStart, this.__input0.selectionEnd);
  };

  Input.prototype.__unfocusShadowInput = function() {
    if (!this.hasShadowFocus()) {
      return;
    }
    this.setContentSize();
    this.__input0.focus();
    this.showCursor();
    return this.__shadow_focused = false;
  };

  Input.prototype.hasShadowFocus = function() {
    return this.__shadow_focused;
  };

  Input.prototype.setContentSize = function() {
    if (!this._content_size) {
      return this;
    }
    if (this.__contentSize) {
      CUI.scheduleCallback({
        call: this.__doSetContentSize,
        ms: 100
      });
    } else {
      this.__initContentSize();
      this.__setContentSize();
      this.__removeContentSize();
    }
    return this;
  };

  Input.prototype.__initContentSize = function() {
    var correct_height, css, j, k, len1, ref, style;
    if (this.__contentSize) {
      return;
    }
    this.__contentSize = $element("textarea", "cui-input-shadow", {
      tabindex: "-1",
      autocomplete: "off"
    });
    this.__contentSize.appendTo(document.body);
    this.__contentSize0 = this.__contentSize[0];
    style = window.getComputedStyle(this.__input0);
    css = {};
    ref = ["fontFamily", "fontKerning", "fontSize", "wordBreak", "wordSpacing", "wordWrap", "fontStretch", "lineHeight", "fontStyle", "fontVariant", "fontVariantLigatures", "fontWeight"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      css[k] = style[k];
    }
    if (!this._textarea) {
      css.whiteSpace = "nowrap";
    }
    this.__contentSize.css(css);
    DOM.height(this.__contentSize, 1);
    if (this._textarea) {
      DOM.width(this.__contentSize, DOM.width(this.__contentSize));
      this.__max_height = parseInt(this.__input.css("max-height"));
      this.__input0.style.overflow = "hidden";
      if (isNaN(this.__max_height)) {
        this.__max_height = null;
      } else {
        correct_height = parseInt(this.__input.css("height")) - DOM.height(this.__input);
        this.__max_height -= correct_height;
      }
    } else {
      DOM.width(this.__contentSize, 1);
    }
    return this;
  };

  Input.prototype.__setContentSize = function() {
    var changed, h, previous_height, w;
    this.__contentSize0.value = this.__input0.value;
    if (this.hasShadowFocus()) {
      this.__contentSize0.focus();
    }
    changed = false;
    if (this._textarea) {
      if (this.__input0.value.length === 0) {
        this.__contentSize0.value = "A";
      }
      if (DOM.width(this.__input) !== DOM.width(this.__contentSize)) {
        DOM.width(this.__contentSize, DOM.width(this.__input));
      }
      h = this.__contentSize0.scrollHeight;
      if (this.__max_height === null || h <= this.__max_height) {
        this.__input0.style.overflow = "hidden";
      } else {
        this.__input0.style.overflow = "";
      }
      previous_height = DOM.height(this.__input);
      DOM.height(this.__input, h);
      if (DOM.height(this.__input) !== previous_height) {
        changed = true;
      }
    } else {
      w = this.__contentSize0.scrollWidth;
      if (this.__contentSize0.value.length === 0) {
        w = 1;
      } else {
        w = w + 1;
      }
      if (DOM.width(this.__input) !== w) {
        changed = true;
      }
      DOM.width(this.__input, w);
    }
    if (changed) {
      Events.trigger({
        type: "content-resize",
        node: this.__input
      });
    }
    return this;
  };

  Input.prototype.checkBlocks = function(blocks) {
    var b, idx, j, len1;
    if (!CUI.isArray(blocks)) {
      return false;
    }
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      b = blocks[idx];
      assert(b instanceof InputBlock, "Input.getInputBlocks", "Block[" + idx + "] needs to be instance of InputBlock.", {
        blocks: blocks,
        block: b
      });
      b.idx = idx;
    }
    return blocks;
  };

  Input.prototype.getInputBlocks = function() {
    var blocks;
    if (this._getInputBlocks) {
      blocks = this._getInputBlocks(this.__input0.value);
    } else if (this._getCursorBlocks) {
      blocks = this._getCursorBlocks(this.__input0.value);
    } else {
      blocks = this.__getInputBlocks(this.__input0.value);
    }
    return this.checkBlocks(blocks);
  };

  Input.prototype.__getInputBlocks = function(v) {
    var blocks, char_1_before, char_2_before, match, match_start, match_str, re;
    blocks = [];
    v = this.__input0.value;
    re = /[0-9]+/g;
    blocks = [];
    while ((match = re.exec(v)) !== null) {
      match_str = match[0];
      match_start = match.index;
      if (match_start > 0) {
        char_1_before = v.substr(match_start - 1, 1);
      } else {
        char_1_before = null;
      }
      if (match_start > 1) {
        char_2_before = v.substr(match_start - 2, 1);
      } else {
        char_2_before = null;
      }
      if (char_1_before === "-" && !(char_2_before != null ? char_2_before.match(/[0-9]/) : void 0)) {
        match_str = "-" + match_str;
        match_start -= 1;
      }
      blocks.push(new NumberInputBlock({
        start: match_start,
        string: match_str
      }));
    }
    return blocks;
  };

  Input.prototype.__overwriteBlocks = function(v) {
    var blocks, i, j, ref;
    blocks = [];
    for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      blocks.push(new InputBlock({
        start: i,
        string: v.substr(i, 1)
      }));
    }
    blocks.push(new InputBlock({
      start: v.length,
      string: ""
    }));
    return blocks;
  };

  Input.prototype.getMarkedBlock = function() {
    var block, blocks, e, idx, j, len1, s;
    blocks = this.getInputBlocks();
    if (blocks === false || blocks.length === 0) {
      return null;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      block = blocks[idx];
      if (block.start === s && block.end === e) {
        return block;
      }
    }
    return null;
  };

  Input.prototype.getSelection = function() {
    var e, s;
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    return {
      start: s,
      end: e,
      value: this.__input0.value,
      before: this.__input0.value.substring(0, s),
      selected: this.__input0.value.substring(s, e),
      after: this.__input0.value.substring(e)
    };
  };

  Input.prototype.setSelection = function(selection) {
    this.__input0.selectionStart = selection.start;
    return this.__input0.selectionEnd = selection.end;
  };

  Input.prototype.selectAll = function() {
    this.__input0.selectionStart = 0;
    this.__input0.selectionEnd = this.__input0.value.length;
    return this;
  };

  Input.prototype.updateSelection = function(txt) {
    var end, sel, start;
    if (txt == null) {
      txt = "";
    }
    sel = this.getSelection();
    this.setValue(sel.before + txt + sel.after);
    start = sel.before.length;
    end = start + txt.length;
    if (sel.start === sel.end) {
      start = end;
    }
    return this.setSelection({
      start: start,
      end: end
    });
  };

  Input.prototype.setValue = function(v, flags) {
    var ref;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      if ((ref = this.__input0) != null) {
        ref.value = v;
      }
      this.setContentSize();
    }
    return Input.__super__.setValue.call(this, v, flags);
  };

  Input.prototype.incNumberBounds = function(ev) {
    var bl, block, block_jump_to, block_move, blocks, e, idx, j, l, last_block, len1, len2, len3, m, new_str, new_value, parts_inbetween, ref, ref1, s, v;
    if ((ref = ev.keyCode()) !== 38 && ref !== 40 && ref !== 33 && ref !== 34) {
      return;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    v = this.__input0.value;
    blocks = this.getInputBlocks();
    if (blocks === false || blocks.length === 0) {
      return;
    }
    parts_inbetween = [v.substring(0, blocks[0].start)];
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      block = blocks[idx];
      if (idx === blocks.length - 1) {
        break;
      }
      parts_inbetween.push(v.substring(block.end, blocks[idx + 1].start));
    }
    last_block = blocks[blocks.length - 1];
    parts_inbetween.push(v.substring(last_block.end));
    block_move = 0;
    if ((ref1 = ev.keyCode()) === 9 || ref1 === 33 || ref1 === 34) {
      if (ev.shiftKey() || ev.keyCode() === 33) {
        block_move = -1;
      } else {
        block_move = 1;
      }
    }
    for (idx = l = 0, len2 = blocks.length; l < len2; idx = ++l) {
      block = blocks[idx];
      if (block.start === s && block.end === e) {
        if (block_move) {
          block_jump_to = idx + block_move;
          break;
        }
        if (ev.keyCode() === 38) {
          block.incrementBlock(block, blocks);
        } else {
          block.decrementBlock(block, blocks);
        }
        block_jump_to = idx;
        break;
      }
      if ((s === e || (this.cursor && this.cursor.start === this.cursor.end)) && (block.start <= s && s <= block.end)) {
        block_jump_to = idx;
        continue;
      }
    }
    if (block_move && s === 0 && e === v.length && blocks.length > 1) {
      if (block_move === -1) {
        block_jump_to = blocks.length - 1;
      } else {
        block_jump_to = 0;
      }
    }
    if (bl = blocks[block_jump_to]) {
      new_str = [parts_inbetween[0]];
      for (idx = m = 0, len3 = blocks.length; m < len3; idx = ++m) {
        block = blocks[idx];
        new_str.push(block.string);
        new_str.push(parts_inbetween[idx + 1]);
      }
      new_value = new_str.join("");
      if (!this.checkInput(new_value)) {
        ev.preventDefault();
        return;
      }
      this.__input0.value = new_value;
      this.markBlock(ev, bl);
      this.storeValue(this.__input0.value);
      ev.preventDefault();
    }
  };

  Input.prototype.__removeContentSize = function() {
    var ref;
    if ((ref = this.__contentSize) != null) {
      ref.remove();
    }
    this.__contentSize = null;
    this.__contentSize0 = null;
    return this;
  };

  Input.prototype.__removeShadowInput = function() {
    var ref;
    this.__removeContentSize();
    if ((ref = this.__shadow) != null) {
      ref.remove();
    }
    this.__shadow = null;
    this.__shadow_focused = false;
    return this;
  };

  Input.prototype.preventInvalidInput = function() {
    if (this.__checkInput && this._prevent_invalid_input) {
      return true;
    } else {
      return false;
    }
  };

  Input.prototype.__initShadowInput = function() {
    if (!(this.preventInvalidInput() || this._content_size || this._correctValueForInput || this._readonly || this._rows)) {
      return;
    }
    if (this.__shadow) {
      return;
    }
    if (this._textarea) {
      this.__shadow = $element("textarea", "cui-input-shadow");
    } else {
      this.__shadow = $element("input", "cui-input-shadow", {
        type: "text"
      });
    }
    this.__shadow.prop("tabindex", "-1");
    this.__shadow.prop("autocomplete", "off");
    this.__shadow.appendTo(document.body);
    this.__shadow0 = this.__shadow[0];
    if (this._content_size) {
      this.__initContentSize();
    }
    Events.listen({
      type: "input",
      node: this.__shadow,
      call: (function(_this) {
        return function(ev) {
          _this.__shadowInput(ev);
          _this.__unfocusShadowInput();
          new CUI.Event({
            type: "input",
            node: _this.__input
          }).dispatch();
        };
      })(this)
    });
    Events.listen({
      type: "keyup",
      node: this.__shadow,
      call: (function(_this) {
        return function(ev) {
          _this.__unfocusShadowInput();
        };
      })(this)
    });
    return this;
  };

  Input.prototype.__shadowInput = function(ev) {
    var ret, shadow_v;
    shadow_v = this.__shadow0.value;
    if (this._rows && shadow_v.split("\n").length > this._rows) {
      return;
    }
    if (this.preventInvalidInput() && shadow_v.length > 0) {
      ret = this.checkInput(this.correctValueForInput(shadow_v));
      if (ret === false) {
        return;
      }
    }
    if (!this._readonly) {
      this.__input0.value = this.correctValueForInput(shadow_v);
      this.__input0.setSelectionRange(this.__shadow0.selectionStart, this.__shadow0.selectionEnd);
    }
    this.initCursor(ev);
  };

  Input.prototype.checkValue = function(v) {
    if (!isString(v) || null) {
      throw new Error(this.__cls + ".checkValue(value): Value needs to be String or null.");
    }
    return this;
  };

  Input.prototype.render = function() {
    var j, k, len1, ref;
    Input.__super__.render.call(this);
    this.replace(this.__createElement(), this.getTemplateKeyForRender());
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      this.append(this.__inputHints[k], this.getTemplateKeyForRender());
    }
    return this;
  };

  Input.prototype.getTemplateKeyForRender = function() {
    return null;
  };

  Input.prototype.isRequired = function() {
    return this._required;
  };

  Input.prototype.updateInputState = function(__inputState) {
    var j, k, len1, ref, ref1, ref2, ref3, state;
    this.__inputState = __inputState != null ? __inputState : this.__inputState;
    if (this.hasUserInput()) {
      this.addClass("cui-input-has-user-input");
      this.removeClass("cui-input-has-no-user-input");
    } else {
      this.removeClass("cui-input-has-user-input");
      this.addClass("cui-input-has-no-user-input");
    }
    state = this.getInputState();
    switch (state) {
      case "empty":
      case "valid":
        this.removeClass("cui-input-invalid");
        break;
      case "invalid":
        this.addClass("cui-input-invalid");
    }
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      DOM.hideElement((ref1 = this.__inputHints[k]) != null ? ref1.DOM[0] : void 0);
    }
    if (!this.hasUserInput() && state === "invalid") {
      DOM.showElement((ref2 = this.__inputHints.empty) != null ? ref2.DOM[0] : void 0);
    } else {
      DOM.showElement((ref3 = this.__inputHints[state]) != null ? ref3.DOM[0] : void 0);
    }
    return this;
  };

  Input.prototype.getInputState = function() {
    if (this.__inputState !== false) {
      return "valid";
    }
    if (this.hasUserInput() || this.isRequired()) {
      return "invalid";
    }
    return "empty";
  };

  Input.prototype.leaveInput = function() {
    if (this.getInputState() !== "invalid") {
      this.__input0.value = this.getValueForDisplay();
      this.checkInput();
    }
    return this;
  };

  Input.prototype.enterInput = function() {
    if (this.getInputState() !== "invalid") {
      this.__input0.value = this.getValueForInput();
      this.checkInput();
    }
    return this;
  };

  Input.prototype.hasUserInput = function() {
    return this.__input0.value.length > 0;
  };

  Input.prototype.checkInput = function(value) {
    var state;
    state = this.__checkInputInternal(value);
    if (!this.hasShadowFocus()) {
      this.updateInputState(state);
    }
    return state;
  };

  Input.prototype.__checkInputInternal = function(value) {
    if (value == null) {
      value = this.__input0.value;
    }
    if (this.__checkInput) {
      return this.__checkInput(value);
    } else {
      return true;
    }
  };

  Input.prototype.setInputHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.input) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.setInvalidHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.invalid) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.setValidHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.valid) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.displayValue = function() {
    var value;
    Input.__super__.displayValue.call(this);
    value = this.getValueForDisplay();
    if (value !== this.__input0.value) {
      this.__input0.value = value;
    }
    this.checkInput();
    return this;
  };

  Input.prototype.getValueForDisplay = function() {
    if (this._getValueForDisplay) {
      return this._getValueForDisplay(this, this.getValue());
    } else {
      return this.getValue();
    }
  };

  Input.prototype.getValueForInput = function() {
    if (this._getValueForInput) {
      return this._getValueForInput(this, this.getValue());
    } else {
      return this.getValue();
    }
  };

  Input.prototype.correctValueForInput = function(value) {
    if (this._correctValueForInput) {
      return this._correctValueForInput(this, value);
    } else {
      return value;
    }
  };

  Input.prototype.getDefaultValue = function() {
    return "";
  };

  Input.prototype.getValue = function() {
    var ref;
    if (this.hasData()) {
      return Input.__super__.getValue.call(this);
    } else {
      return (ref = this.__input0) != null ? ref.value : void 0;
    }
  };

  Input.prototype.enable = function() {
    var ref;
    Input.__super__.enable.call(this);
    return (ref = this.__input) != null ? ref.prop("disabled", false) : void 0;
  };

  Input.prototype.disable = function() {
    var ref;
    Input.__super__.disable.call(this);
    return (ref = this.__input) != null ? ref.prop("disabled", true) : void 0;
  };

  Input.prototype.focus = function() {
    var ref;
    if ((ref = this.__input0) != null) {
      ref.focus();
    }
    return this;
  };

  Input.prototype.getCursorBlocks = function() {
    var blocks;
    blocks = typeof this.__getCursorBlocks === "function" ? this.__getCursorBlocks(this.__input0.value) : void 0;
    return this.checkBlocks(blocks);
  };

  Input.prototype.findBlock = function(blocks, idx, cut) {
    var block, j, len1, ref;
    for (j = 0, len1 = blocks.length; j < len1; j++) {
      block = blocks[j];
      if ((idx === (ref = block.start) && ref === block.end)) {
        return block;
      }
      if (cut === "full" && idx >= block.start && idx <= block.end) {
        return block;
      }
      if (cut === "left" && idx >= block.start && idx < block.end) {
        return block;
      }
      if (cut === "right" && idx > block.start && idx <= block.end) {
        return block;
      }
      if (cut === "touch" && idx >= block.start && idx <= block.end) {
        return block;
      }
    }
    return null;
  };

  Input.prototype.initCursor = function(ev) {
    var block_left, block_right, blocks, dist_left, dist_right, e, i, j, l, len, range, ref, ref1, ref2, ref3, ref4, ref5, ref6, s;
    blocks = this.getCursorBlocks();
    if (blocks === false) {
      this.cursor = null;
      return;
    }
    if (blocks.length === 0) {
      CUI.warn("initCursor: 0 cursor blocks");
      this.cursor = null;
      return;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    len = this.__input0.value.length;
    this.cursor = {
      shift: (ref = this.cursor) != null ? ref.shift : void 0,
      start: null,
      end: null
    };
    if (ev.getType() === "keyup" && ev.keyCode() === 16) {
      this.cursor.shift = null;
    }
    if (ev.getType() === "keydown" && ((ref1 = ev.keyCode()) === 46 || ref1 === 8)) {
      this.cursor.shift = null;
    }
    if (isUndef(this.cursor.shift)) {
      this.cursor.shift = null;
    }
    this.cursor.start = this.findBlock(blocks, s, "left");
    this.cursor.end = this.findBlock(blocks, e, "right");
    if (((ref2 = this.cursor.end) != null ? ref2.idx : void 0) < ((ref3 = this.cursor.start) != null ? ref3.idx : void 0)) {
      this.cursor.end = this.cursor.start;
    }
    if (s === e && !this.cursor.start && !this.cursor.end) {
      dist_left = null;
      dist_right = null;
      for (i = j = ref4 = s; j >= 0; i = j += -1) {
        block_left = this.findBlock(blocks, i, "left");
        if (block_left) {
          dist_left = s - i;
          break;
        }
      }
      for (i = l = ref5 = s, ref6 = len; l < ref6; i = l += 1) {
        block_right = this.findBlock(blocks, i, "left");
        if (block_right) {
          dist_right = i - s;
          break;
        }
      }
      if (block_right && !block_left) {
        this.cursor.start = block_right;
      } else if (block_left && !block_right) {
        this.cursor.start = block_left;
      } else if (block_left && block_right) {
        if (dist_left > dist_right) {
          this.cursor.start = block_right;
        } else {
          this.cursor.start = block_left;
        }
      }
    }
    range = this.getRangeFromCursor();
    if (!this.cursor.start && !this.cursor.end) {
      this.cursor.start = this.cursor.end = blocks[blocks.length - 1];
    } else if (!this.cursor.start) {
      this.cursor.start = this.cursor.end;
    } else if (!this.cursor.end) {
      this.cursor.end = this.cursor.start;
    }
    if (range[0] === s && range[1] === e) {
      1;
    }
  };

  Input.prototype.showCursor = function(ev) {
    var r;
    if (this.cursor) {
      r = this.getRangeFromCursor();
      this.__input0.setSelectionRange(r[0], r[1]);
    }
    return this;
  };

  Input.prototype.checkSelectionChange = function() {
    var sel;
    sel = this.getSelection();
    if (this.__currentSelection && (this.__currentSelection.start !== sel.start || this.__currentSelection.end !== sel.end)) {
      this.handleSelectionChange();
    }
    this.__currentSelection = sel;
    return this;
  };

  Input.prototype.getRangeFromCursor = function() {
    var ref, ref1;
    return [(ref = this.cursor.start) != null ? ref.start : void 0, (ref1 = this.cursor.end) != null ? ref1.end : void 0];
  };

  Input.prototype.moveCursor = function(ev) {
    var blocks, c_idx, e_idx, left, right, s_idx;
    if (!this.cursor) {
      return;
    }
    ev.preventDefault();
    blocks = this.getCursorBlocks();
    if (blocks === false || blocks.length === 0) {
      this.cursor = null;
      return;
    }
    if (ev.keyCode() === 36) {
      this.cursor.start = blocks[0];
      this.cursor.end = blocks[0];
      return;
    }
    if (ev.keyCode() === 35) {
      this.cursor.start = blocks[blocks.length - 1];
      this.cursor.end = blocks[blocks.length - 1];
      return;
    }
    if (this.lastKeyDownEvent.keyCode() === 46) {
      this.initCursor(this.lastKeyDownEvent);
      return;
    }
    if (this.lastKeyDownEvent.keyCode() === 8) {
      this.initCursor(this.lastKeyDownEvent);
      return;
    }
    left = ev.keyCode() === 37;
    right = ev.keyCode() === 39 || ev.getType() === "input";
    s_idx = this.cursor.start.idx;
    e_idx = this.cursor.end.idx;
    if (!blocks[s_idx] || !blocks[e_idx]) {
      CUI.warn("repositioning cursor, not executing cursor move");
      this.initCursor(ev);
      return;
    }
    if (ev.keyCode() === 46) {
      return;
    }
    if (ev.shiftKey() && this.cursor.shift === null) {
      this.cursor.shift = this.cursor.end.idx;
    }
    if (this.cursor.shift === null) {
      if (s_idx === e_idx) {
        if (left) {
          if (s_idx > 0) {
            this.cursor.start = blocks[s_idx - 1];
          }
        } else if (right) {
          if (s_idx < blocks.length - 1) {
            this.cursor.start = blocks[s_idx + 1];
          }
        }
        this.cursor.end = this.cursor.start;
      } else if (left) {
        this.cursor.end = this.cursor.start;
      } else if (right) {
        this.cursor.start = this.cursor.end;
      }
    } else {
      c_idx = this.cursor.shift;
      if (left) {
        if (c_idx >= e_idx) {
          if (s_idx > 0) {
            this.cursor.start = blocks[s_idx - 1];
          }
        } else {
          this.cursor.end = blocks[e_idx - 1];
        }
      } else if (right) {
        if (c_idx > s_idx) {
          this.cursor.start = blocks[s_idx + 1];
        } else {
          if (e_idx < blocks.length - 1) {
            this.cursor.end = blocks[e_idx + 1];
          }
        }
      }
    }
    return this;
  };

  Input.prototype.destroy = function() {
    this.__removeShadowInput();
    return Input.__super__.destroy.call(this);
  };

  Input.uniqueId = 0;

  return Input;

})(CUI.DataFieldInput);

Input = CUI.Input;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MarkdownInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MarkdownInput = (function(superClass) {
  extend(MarkdownInput, superClass);

  function MarkdownInput() {
    return MarkdownInput.__super__.constructor.apply(this, arguments);
  }

  MarkdownInput.prototype.initOpts = function() {
    MarkdownInput.__super__.initOpts.call(this);
    this.removeOpt("textarea");
    return this.addOpts({
      preview: {
        check: Boolean
      },
      preview_ms: {
        "default": 500,
        check: (function(_this) {
          return function(v) {
            return v >= 0;
          };
        })(this)
      },
      renderFunction: {
        mandatory: true,
        "default": (function(_this) {
          return function(md) {
            return window.marked(md, CUI.defaults.marked_opts);
          };
        })(this),
        check: Function
      }
    });
  };

  MarkdownInput.prototype.readOpts = function() {
    var i, k, len1, ref, vl_opts;
    MarkdownInput.__super__.readOpts.call(this);
    this._textarea = true;
    this.__preview = null;
    this.__updatePreview = (function(_this) {
      return function() {
        return _this.updatePreview();
      };
    })(this);
    vl_opts = {
      top: {}
    };
    ref = ["maximize", "maximize_horizontal", "maximize_vertical"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (this.hasSetOpt(k)) {
        vl_opts[k] = this.getSetOpt(k);
      }
    }
    return this.__verticalLayout = new Pane(vl_opts);
  };

  MarkdownInput.prototype.initTemplate = function() {
    return this.registerTemplate(this.__verticalLayout.getLayout());
  };

  MarkdownInput.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  MarkdownInput.prototype.encloseSelection = function(char) {
    var len, rows, sel;
    sel = this.getSelection();
    len = char.length;
    rows = sel.selected.split("\n");
    if (rows.length > 1) {
      return;
    }
    if (sel.selected.startsWith(char) && sel.selected.endsWith(char)) {
      this.setValue(sel.before + sel.selected.substr(len, sel.selected.length - len * 2) + sel.after);
      return this.setSelection({
        start: sel.start,
        end: sel.end - len * 2
      });
    } else {
      this.setValue(sel.before + char + sel.selected + char + sel.after);
      return this.setSelection({
        start: sel.start,
        end: sel.end + len * 2
      });
    }
  };

  MarkdownInput.prototype.makeOrderedList = function() {
    return this.__makeList(false);
  };

  MarkdownInput.prototype.makeUnorderedList = function() {
    return this.__makeList(true);
  };

  MarkdownInput.prototype.checkList = function() {
    var type;
    type = this.__makeList(null, true);
    return console.debug("selection is type", type);
  };

  MarkdownInput.prototype.__makeList = function(ul, check_only) {
    var i, is_ul, item, len1, match, new_rows, prefix, row, rows, sel, space;
    if (ul == null) {
      ul = true;
    }
    if (check_only == null) {
      check_only = false;
    }
    sel = this.getSelection();
    rows = sel.selected.split("\n");
    if (sel.before !== "" && !sel.before.endsWith("\n")) {
      return null;
    }
    space = null;
    if (check_only) {
      is_ul = void 0;
    } else if (ul) {
      prefix = "- ";
    } else {
      prefix = "1. ";
    }
    new_rows = [];
    for (i = 0, len1 = rows.length; i < len1; i++) {
      row = rows[i];
      console.debug("row:", row);
      if (row.trim().length === 0) {
        new_rows.push(row);
        continue;
      }
      match = row.match(/^(\s*)([0-9]+\.|\*|\-|)(\s*)(.*)$/);
      console.debug("match", row, match);
      if (!match) {
        console.warn("No match, not making list.", row);
        return null;
      }
      if (space === null) {
        space = match[1];
        item = match[2];
        if (item !== "") {
          is_ul = isNaN(parseInt(item));
        } else {
          is_ul = null;
        }
        if (is_ul !== null && !xor(is_ul, ul)) {
          prefix = "";
        }
        console.debug("rowcriteria.", space.length, item);
      } else if (match[1] !== space) {
        new_rows.push(row.substring(match[1].length - space.length));
        console.debug("row not matching space criteria.");
        continue;
      }
      if (!check_only) {
        new_rows.push(space + prefix + match[4]);
      }
    }
    if (check_only) {
      if (is_ul === null) {
        return "nolist";
      } else if (is_ul === true) {
        return "ul";
      } else if (is_ul === false) {
        return "ol";
      } else {
        return null;
      }
    }
    return this.updateSelection(new_rows.join("\n"));
  };

  MarkdownInput.prototype.handleSelectionChange = function(ev) {
    var sel;
    MarkdownInput.__super__.handleSelectionChange.call(this, ev);
    sel = this.getSelection();
    console.debug("md selection change", ev, dump(sel));
    return this.checkList();
  };

  MarkdownInput.prototype.render = function() {
    var bb;
    MarkdownInput.__super__.render.call(this);
    bb = new Toolbar({
      left: {
        content: [
          {
            group: "lists",
            icon: "fa-list-ul",
            onClick: (function(_this) {
              return function() {
                return _this.makeUnorderedList();
              };
            })(this)
          }, {
            group: "lists",
            icon: "fa-list-ol",
            onClick: (function(_this) {
              return function() {
                return _this.makeOrderedList();
              };
            })(this)
          }, {
            text: "*",
            onClick: (function(_this) {
              return function() {
                return _this.encloseSelection("*");
              };
            })(this)
          }, {
            text: "**",
            onClick: (function(_this) {
              return function() {
                return _this.encloseSelection("**");
              };
            })(this)
          }, {
            text: "SC",
            onClick: (function(_this) {
              return function() {
                return _this.handleSelectionChange();
              };
            })(this)
          }
        ]
      }
    });
    this.__verticalLayout.append(bb, "top");
    return this;
  };

  MarkdownInput.prototype.storeValue = function(value, flags) {
    var ret;
    if (flags == null) {
      flags = {};
    }
    ret = MarkdownInput.__super__.storeValue.call(this, value, flags);
    if (!this.__preview) {
      return ret;
    }
    if (this._preview_ms === 0) {
      this.updatePreview();
    } else {
      CUI.scheduleCallback({
        ms: this._preview_ms,
        call: this.__updatePreview
      });
    }
    return ret;
  };

  MarkdownInput.prototype.getPreview = function() {
    if (!this.__preview) {
      this.__preview = DOM.element("div", {
        "class": "cui-markdown-input-preview"
      });
      this.updatePreview();
    }
    return this.__preview;
  };

  MarkdownInput.prototype.updatePreview = function() {
    return this.__preview.innerHTML = this.renderHTML();
  };

  MarkdownInput.prototype.renderHTML = function() {
    return this._renderFunction(this.getElement().value);
  };

  MarkdownInput.__escape_regexp = new RegExp('[\\' + ('*-_\\![]()'.split("").join("\\")) + ']', 'g');

  MarkdownInput.escape = function(obj) {
    var k, new_obj, ref, v;
    assert((ref = typeof obj) === "string" || ref === "object", "MarkdownInput.escape", "Object needs to be typof 'string' or 'object'.", {
      obj: obj
    });
    if (typeof obj === "string") {
      return obj.replace(this.__escape_regexp, "\\$&");
    }
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      new_obj[k] = this.escape(v);
    }
    return new_obj;
  };

  return MarkdownInput;

})(Input);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FileUploadFile,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileUploadFile = (function(superClass) {
  extend(FileUploadFile, superClass);

  function FileUploadFile(opts) {
    this.opts = opts != null ? opts : {};
    FileUploadFile.__super__.constructor.call(this, this.opts);
    this.__progress = {
      status: "CREATED",
      total: this._file.size,
      loaded: 0,
      percent: null
    };
    this.__dfr = new CUI.Deferred();
    this.__promise = this.__dfr.promise();
  }

  FileUploadFile.prototype.initOpts = function() {
    FileUploadFile.__super__.initOpts.call(this);
    return this.addOpts({
      file: {
        mandatory: true,
        check: function(v) {
          return v instanceof File;
        }
      },
      fileUpload: {
        mandatory: true,
        check: FileUpload
      },
      batch: {
        check: function(v) {
          return v >= 0;
        }
      },
      onRemove: {
        check: Function
      },
      onDequeue: {
        check: Function
      },
      onBeforeDone: {
        check: Function
      }
    });
  };

  FileUploadFile.prototype.queue = function() {
    this.__progress.status = "QUEUED";
    this.__dfr.notify(this);
    return this;
  };

  FileUploadFile.prototype.getImage = function() {
    var img;
    if (this.__imgDiv) {
      return this.__imgDiv;
    }
    img = $img()[0];
    img.src = window.URL.createObjectURL(this._file);
    img.onload = (function(_this) {
      return function(ev) {
        if (img.width < img.height) {
          _this.__imgDiv.removeClass("landscape");
          _this.__imgDiv.addClass("portrait");
        }
        return window.URL.revokeObjectURL(img.src);
      };
    })(this);
    return this.__imgDiv = $div("cui-file-upload-file-img").addClass("landscape").append($div().append(img));
  };

  FileUploadFile.prototype.getFile = function() {
    return this._file;
  };

  FileUploadFile.prototype.getFileUpload = function() {
    return this._fileUpload;
  };

  FileUploadFile.prototype.getPromise = function() {
    return this.__promise;
  };

  FileUploadFile.prototype.getBatch = function() {
    return this._batch;
  };

  FileUploadFile.prototype.getName = function() {
    return this._file.webkitRelativePath || this._file.name;
  };

  FileUploadFile.prototype.getStatus = function() {
    return this.__progress.status;
  };

  FileUploadFile.prototype.getError = function() {
    return this.__progress.fail;
  };

  FileUploadFile.prototype.getErrorXHR = function() {
    return this.__progress.fail_xhr;
  };

  FileUploadFile.prototype.getData = function() {
    return this.__progress.data;
  };

  FileUploadFile.prototype.getProgress = function() {
    return this.__progress;
  };

  FileUploadFile.prototype.getPercent = function() {
    return this.__progress.percent;
  };

  FileUploadFile.prototype.getInfo = function() {
    var s;
    s = this.getStatus();
    if (s === "PROGRESS" || s === "COMPLETED") {
      return (this.getPercent() || 0) + "%";
    }
    return s;
  };

  FileUploadFile.prototype.abort = function() {
    switch (this.getStatus()) {
      case "CREATED":
      case "QUEUED":
        this.__progress.status = "ABORT";
        this.__dfr.reject(this);
        break;
      case "STARTED":
      case "PROGRESS":
      case "COMPLETED":
        console.debug("FileUploadFile.abort:", this.__upload);
        this.__upload.abort();
        break;
      case "ABORT":
      case "DEQUEUED":
    }
    return this;
  };

  FileUploadFile.prototype.dequeue = function() {
    this.__progress.status = "DEQUEUED";
    if (typeof this._onDequeue === "function") {
      this._onDequeue(this);
    }
    return this;
  };

  FileUploadFile.prototype.remove = function() {
    if (this.isDone()) {
      this.dequeue();
    } else {
      this.abort();
    }
    this._fileUpload.removeFile(this);
    if (typeof this._onRemove === "function") {
      this._onRemove(this);
    }
    return this;
  };

  FileUploadFile.prototype.isDone = function() {
    var ref;
    return (ref = this.__progress.status) !== "CREATED" && ref !== "QUEUED" && ref !== "STARTED" && ref !== "PROGRESS" && ref !== "COMPLETED";
  };

  FileUploadFile.prototype.isUploading = function() {
    return !!this.__upload;
  };

  FileUploadFile.prototype.upload = function(url, name) {
    var form, onDone;
    assert(!this.__upload, "FileUploadFile.upload", "A file can only be uploaded once.", {
      file: this
    });
    form = {};
    form[name] = this._file;
    onDone = (function(_this) {
      return function() {};
    })(this);
    if (this._file.size > 0) {
      this.__upload = new CUI.XHR({
        url: url,
        form: form
      });
      this.__upload.start().progress((function(_this) {
        return function(type, loaded, total, percent) {
          if (type === "download") {
            return;
          }
          if (_this.__progress.status === "ABORT") {
            return;
          }
          if (loaded === total) {
            _this.__progress.status = "COMPLETED";
          } else {
            _this.__progress.status = "PROGRESS";
          }
          _this.__progress.loaded = loaded;
          _this.__progress.total = total;
          _this.__progress.percent = percent;
          return _this.__dfr.notify(_this);
        };
      })(this)).done((function(_this) {
        return function(data) {
          _this.__progress.data = data;
          onDone = function() {
            _this.__progress.status = "DONE";
            _this.__upload = null;
            return _this.__dfr.resolve(_this);
          };
          if (_this._onBeforeDone) {
            return CUI.decide(_this._onBeforeDone(_this)).done(onDone).fail(function() {
              _this.__progress.status = "ABORT";
              _this.__upload = null;
              return _this.__dfr.reject(_this);
            });
          } else {
            return onDone();
          }
        };
      })(this)).fail((function(_this) {
        return function(data, status, statusText) {
          console.warn("FileUploadFile.fail", status, statusText);
          if (statusText === "abort") {
            _this.__progress.status = "ABORT";
          }
          if (_this.__progress.status !== "ABORT") {
            _this.__progress.status = "FAILED";
          }
          _this.__progress.fail = _this.__upload.response();
          _this.__progress.fail_xhr = _this.__upload.getXHR();
          _this.__upload = null;
          return _this.__dfr.reject(_this);
        };
      })(this));
    } else {
      CUI.setTimeout({
        call: (function(_this) {
          return function() {
            console.warn("FileUploadFile.fail, Not uploading empty file.");
            _this.__progress.status = "FAILED";
            _this.__upload = null;
            return _this.__dfr.reject(_this);
          };
        })(this)
      });
    }
    this.__progress.status = "STARTED";
    this.__progress.percent = 0;
    this.__dfr.notify(this);
    return this.__promise;
  };

  return FileUploadFile;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FileUploadButton,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileUploadButton = (function(superClass) {
  extend(FileUploadButton, superClass);

  function FileUploadButton(opts) {
    this.opts = opts != null ? opts : {};
    this.__onClick = bind(this.__onClick, this);
    FileUploadButton.__super__.constructor.call(this, this.opts);
    this.addClass("cui-button");
    if (this._drop) {
      this._fileUpload.initDropZone({
        dropZone: this.DOM
      });
    }
  }

  FileUploadButton.prototype.initOpts = function() {
    FileUploadButton.__super__.initOpts.call(this);
    return this.addOpts({
      fileUpload: {
        mandatory: true,
        check: FileUpload
      },
      multiple: {
        "default": true,
        check: Boolean
      },
      directory: {
        check: Boolean
      },
      drop: {
        check: Boolean
      }
    });
  };

  FileUploadButton.prototype.getTemplateName = function() {
    this.__has_left = true;
    this.__has_right = true;
    if (CUI.__ng__) {
      return "file-upload-button-ng";
    } else {
      return "file-upload-button";
    }
  };

  FileUploadButton.prototype.readOpts = function() {
    this.__ownClick = this.opts.onClick;
    this.opts.onClick = this.__onClick;
    return FileUploadButton.__super__.readOpts.call(this);
  };

  FileUploadButton.prototype.__onClick = function(ev, btn) {
    var ref, uploadBtn;
    if ((ref = this.__ownClick) != null) {
      ref.call(this, ev, btn);
    }
    if (ev.isDefaultPrevented() || ev.isImmediatePropagationStopped()) {
      return;
    }
    uploadBtn = document.getElementById("cui-file-upload-button");
    uploadBtn.form.reset();
    this._fileUpload.initFilePicker({
      directory: (ev.altKey() || ev.shiftKey() && this._multiple) || this._directory,
      multiple: this._multiple,
      fileUpload: uploadBtn
    });
  };

  return FileUploadButton;

})(Button);

CUI.ready((function(_this) {
  return function() {
    return CUI.DOM.append(document.body, CUI.DOM.htmlToNodes("<!-- CUI.FileUploadButton --><form style=\"display:none;\"><input type=\"file\" id=\"cui-file-upload-button\"></input></form><!-- /CUI.FileUploadButton -->"));
  };
})(this));
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FileUpload,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

FileUpload = (function(superClass) {
  extend(FileUpload, superClass);

  function FileUpload(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FileUpload.__super__.constructor.call(this, this.opts);
    this.__files = [];
    this.__dropZones = [];
    this.__batch_id = 0;
    this.__batches_done = 0;
  }

  FileUpload.prototype.initOpts = function() {
    FileUpload.__super__.initOpts.call(this);
    return this.addOpts({
      url: {
        mandatory: true,
        check: String
      },
      name: {
        "default": CUI.defaults.FileUpload.name,
        check: String
      },
      parallel: {
        "default": 2,
        check: function(v) {
          return v >= 1;
        }
      },
      onAdd: {
        check: Function
      },
      onBatchQueued: {
        check: Function
      },
      onBatchDone: {
        check: Function
      },
      onProgress: {
        check: Function
      },
      onDone: {
        check: Function
      },
      onUpdate: {
        check: Function
      },
      onDequeue: {
        check: Function
      },
      onRemove: {
        check: Function
      },
      onFail: {
        check: Function
      },
      onAlways: {
        check: Function
      },
      onBeforeDone: {
        check: Function
      }
    });
  };

  FileUpload.prototype.readOpts = function() {
    FileUpload.__super__.readOpts.call(this);
    return this.setUrl(this._url);
  };

  FileUpload.prototype.setUrl = function(__url) {
    this.__url = __url;
    return this.__url;
  };

  FileUpload.prototype.getUrl = function() {
    return this.__url;
  };

  FileUpload.prototype.getFiles = function(filter) {
    var file, files, i, len, ref, ref1;
    if (isString(filter)) {
      filter = [filter];
    }
    files = [];
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      file = ref[i];
      if (!filter || (ref1 = file.getStatus(), indexOf.call(filter, ref1) >= 0)) {
        files.push(file);
      }
    }
    return files;
  };

  FileUpload.prototype.getInfo = function() {
    var _fuf, _p, all_done, count, done, i, info, len, loaded, ref, s, status, total;
    status = {};
    total = 0;
    loaded = 0;
    count = 0;
    done = 0;
    all_done = true;
    ref = this.getFiles();
    for (i = 0, len = ref.length; i < len; i++) {
      _fuf = ref[i];
      _p = _fuf.getProgress();
      s = _p.status;
      if (!status[s]) {
        status[s] = 1;
      } else {
        status[s]++;
      }
      if (!_fuf.isDone()) {
        all_done = false;
      } else {
        done += 1;
      }
      total += _p.total;
      loaded += _p.loaded;
      count += 1;
    }
    return info = {
      status: status,
      total: total,
      count: count,
      done: done,
      loaded: loaded,
      percent: Math.floor(loaded / total * 100),
      all_done: all_done
    };
  };

  FileUpload.prototype.getUploadFileClass = function() {
    return FileUploadFile;
  };

  FileUpload.prototype.queueFiles = function(files) {
    var batch, idx, next_file;
    batch = ++this.__batch_id;
    idx = -1;
    next_file = (function(_this) {
      return function() {
        var cls, dont_queue_file, f, file, queue_file;
        idx++;
        if (idx === files.length) {
          if (typeof _this._onBatchQueued === "function") {
            _this._onBatchQueued();
          }
          _this.uploadNextFiles();
          return;
        }
        file = files[idx];
        cls = _this.getUploadFileClass();
        f = new cls({
          file: file,
          fileUpload: _this,
          batch: batch,
          onBeforeDone: _this._onBeforeDone,
          onDequeue: function(f) {
            if (typeof _this._onDequeue === "function") {
              _this._onDequeue(f);
            }
            return typeof _this._onUpdate === "function" ? _this._onUpdate(f) : void 0;
          },
          onRemove: function(f) {
            return typeof _this._onRemove === "function" ? _this._onRemove(f) : void 0;
          }
        });
        f.getPromise().progress(function() {
          if (typeof _this._onProgress === "function") {
            _this._onProgress(f);
          }
          return typeof _this._onUpdate === "function" ? _this._onUpdate(f) : void 0;
        }).done(function() {
          if (typeof _this._onDone === "function") {
            _this._onDone(f);
          }
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          return _this.uploadNextFiles();
        }).fail(function() {
          if (typeof _this._onFail === "function") {
            _this._onFail(f);
          }
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          return _this.uploadNextFiles();
        }).always(function() {
          if (typeof _this._onAlways === "function") {
            _this._onAlways(f);
          }
          return _this.checkBatchDone(f);
        });
        dont_queue_file = function() {
          console.debug("FileUpload.onAdd: Skipping file, function returned 'false'.");
          return next_file();
        };
        queue_file = function() {
          _this.__files.push(f);
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          f.queue();
          return next_file();
        };
        _this.__isQueueing = true;
        return CUI.decide(typeof _this._onAdd === "function" ? _this._onAdd(f) : void 0).done(function() {
          return queue_file();
        }).fail(function() {
          return dont_queue_file();
        }).always(function() {
          return _this.__isQueueing = false;
        });
      };
    })(this);
    next_file();
    return this;
  };

  FileUpload.prototype.clear = function() {
    var file;
    while (file = this.__files[0]) {
      file.remove();
    }
    return this;
  };

  FileUpload.prototype.removeFile = function(file) {
    return removeFromArray(file, this.__files);
  };

  FileUpload.prototype.isDone = function() {
    var f, i, len, ref;
    if (this.__isQueueing) {
      return false;
    }
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (!f.isDone()) {
        return false;
      }
    }
    return true;
  };

  FileUpload.prototype.isUploading = function() {
    var f, i, len, ref;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.isUploading()) {
        return true;
      }
    }
    return false;
  };

  FileUpload.prototype.uploadNextFiles = function() {
    var f, file, files, i, j, len, len1, ref, slots;
    files = [];
    slots = this._parallel;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getStatus() === "QUEUED") {
        files.push(f);
        slots--;
      }
      if (f.isUploading()) {
        slots--;
      }
      if (slots === 0) {
        break;
      }
    }
    for (j = 0, len1 = files.length; j < len1; j++) {
      file = files[j];
      this.uploadFile(file);
    }
    return this;
  };

  FileUpload.prototype.uploadFile = function(file) {
    return file.upload(this.getUrl(), this._name);
  };

  FileUpload.prototype.checkBatchDone = function(file) {
    var alarm, f, i, len, ref;
    alarm = false;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getBatch() !== file.getBatch()) {
        continue;
      }
      if (!f.isDone()) {
        return;
      }
      alarm = true;
    }
    if (alarm) {
      if (typeof this._onBatchDone === "function") {
        this._onBatchDone();
      }
    }
  };

  FileUpload.prototype.initDropZone = function(_opts) {
    var dropZone, dz, i, len, multiple, opts, ref, selector;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "FileUpload.initDropZone", {
      dropZone: {
        mandatory: true,
        check: function(v) {
          return isElement(v) || isElement(v.DOM);
        }
      },
      multiple: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      selector: {
        check: String
      },
      allow_drop: (function(_this) {
        return function(ev) {
          return {
            check: Function
          };
        };
      })(this)
    });
    dropZone = opts.dropZone.DOM || opts.dropZone;
    selector = opts.selector;
    multiple = opts.multiple;
    Events.ignore({
      node: dropZone,
      instance: this
    });
    dropZone.classList.add("cui-file-upload-drop-zone");
    Events.listen({
      node: dropZone,
      type: ["dragover"],
      instance: this,
      selector: selector,
      call: (function(_this) {
        return function(ev) {
          if (opts.allow_drop && !opts.allow_drop(ev)) {
            return ev.stop();
          }
          FileUpload.setDropClassByEvent(ev);
          ev.stopPropagation();
          ev.preventDefault();
          return false;
        };
      })(this)
    });
    Events.listen({
      node: dropZone,
      type: "drop",
      instance: this,
      selector: selector,
      call: (function(_this) {
        return function(ev) {
          var dt, file, files, i, len, ref, ref1, warn;
          if (opts.allow_drop && !opts.allow_drop(ev)) {
            return ev.stop();
          }
          FileUpload.setDropClassByEvent(ev);
          dt = ev.getNativeEvent().dataTransfer;
          if (((ref = dt.files) != null ? ref.length : void 0) > 0) {
            warn = [];
            files = [];
            ref1 = dt.files;
            for (i = 0, len = ref1.length; i < len; i++) {
              file = ref1[i];
              files.push(file);
              if (multiple === false) {
                break;
              }
            }
            if (warn.length > 0) {
              console.warn("Files empty or directories, not uploaded...", warn);
            }
            if (files.length > 0) {
              _this.queueFiles(files);
            }
          }
          ev.stopPropagation();
          ev.preventDefault();
          return false;
        };
      })(this)
    });
    ref = this.__dropZones;
    for (i = 0, len = ref.length; i < len; i++) {
      dz = ref[i];
      if (dz === dropZone) {
        return this;
      }
    }
    this.__dropZones.push(dropZone);
    return this;
  };

  FileUpload.setDropClassByEvent = function(ev) {
    var el, ref;
    el = ev.getCurrentTarget();
    switch (ev.getType()) {
      case "dragover":
        CUI.clearTimeout(this.__dropElementTimeout);
        if ((ref = this.__dropElement) != null) {
          ref.classList.remove("cui-file-upload-drag-over");
        }
        el.classList.add("cui-file-upload-drag-over");
        this.__dropElement = el;
        this.__dropElementTimeout = CUI.setTimeout({
          ms: 500,
          call: (function(_this) {
            return function() {
              el.classList.remove("cui-file-upload-drag-over");
              return delete _this.__dropElement;
            };
          })(this)
        });
        ev.getNativeEvent().dataTransfer.dropEffect = "copy";
        break;
      case "drop":
        el.classList.remove("cui-file-upload-drag-over");
    }
    return this;
  };

  FileUpload.prototype.initFilePicker = function(opts) {
    var dfr, i, inp, k, len, ref;
    inp = opts.fileUpload;
    ref = ["webkitdirectory", "mozdirectory", "directory"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (opts.directory) {
        DOM.setAttribute(inp, k, true);
      } else {
        DOM.removeAttribute(inp, k);
      }
    }
    if (opts.multiple) {
      DOM.setAttribute(inp, "multiple", true);
    } else {
      DOM.removeAttribute(inp, "multiple");
    }
    dfr = new CUI.Deferred();
    Events.ignore({
      node: inp
    });
    Events.listen({
      type: "change",
      node: inp,
      call: (function(_this) {
        return function() {
          var file, files;
          files = (function() {
            var j, len1, ref1, results;
            ref1 = inp.files;
            results = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              file = ref1[j];
              results.push(file);
            }
            return results;
          })();
          _this.queueFiles(files);
          inp.form.reset();
          dfr.resolve();
        };
      })(this)
    });
    return dfr.promise();
  };

  FileUpload.prototype.resetDropZones = function() {
    var dz, i, len, ref;
    Events.ignore({
      instance: this
    });
    ref = this.__dropZones;
    for (i = 0, len = ref.length; i < len; i++) {
      dz = ref[i];
      $(dz).removeClass("cui-file-upload-drop-zone");
    }
    this.__dropZones = [];
    return this;
  };

  FileUpload.prototype.destroy = function() {
    this.resetDropZones();
    FileUpload.__super__.destroy.call(this);
    return this;
  };

  return FileUpload;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.FileReader = (function(superClass) {
  extend(FileReader, superClass);

  function FileReader() {
    return FileReader.__super__.constructor.apply(this, arguments);
  }

  FileReader.prototype.initOpts = function() {
    FileReader.__super__.initOpts.call(this);
    return this.removeOpt("url");
  };

  FileReader.prototype.readOpts = function() {
    return CUI.Element.prototype.readOpts.call(this);
  };

  FileReader.prototype.getUploadFileClass = function() {
    return FileReaderFile;
  };

  FileReader.prototype.uploadFile = function(file) {
    CUI.debug("filereader upload file", file);
    return file.upload(file);
  };

  FileReader.save = function(filename, data, type) {
    var blob, elem;
    if (type == null) {
      type = "text/csv";
    }
    blob = new Blob([data], {
      type: type
    });
    if (window.navigator.msSaveOrOpenBlob) {
      window.navigator.msSaveBlob(blob, filename);
    } else {
      elem = window.document.createElement('a');
      elem.href = window.URL.createObjectURL(blob);
      elem.download = filename;
      document.body.appendChild(elem);
      elem.click();
      document.body.removeChild(elem);
    }
    return window.URL.revokeObjectURL(blob);
  };

  return FileReader;

})(FileUpload);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FileReaderFile,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileReaderFile = (function(superClass) {
  extend(FileReaderFile, superClass);

  function FileReaderFile() {
    return FileReaderFile.__super__.constructor.apply(this, arguments);
  }

  FileReaderFile.prototype.initOpts = function() {
    FileReaderFile.__super__.initOpts.call(this);
    return this.addOpts({
      format: {
        mandatory: true,
        "default": "Text",
        check: ["ArrayBuffer", "Text"]
      }
    });
  };

  FileReaderFile.prototype.upload = function(file) {
    var fn, i, key, len, ref;
    this.__reader = new FileReader();
    ref = ["loadStart", "progress", "abort", "error", "load", "loadend"];
    fn = (function(_this) {
      return function(key) {
        return _this.__reader.addEventListener(key.toLowerCase(), function(ev) {
          return _this["__event_" + key](ev);
        });
      };
    })(this);
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      fn(key);
    }
    switch (this._format) {
      case "Text":
        this.__reader.readAsText(this._file);
        break;
      case "ArrayBuffer":
        this.__reader.readAsArrayBuffer(this._file);
    }
  };

  FileReaderFile.prototype.getResult = function() {
    return this.__reader.result;
  };

  FileReaderFile.prototype.__event_loadStart = function() {
    this.__progress.status = "STARTED";
    this.__progress.percent = 0;
    this.__dfr.notify(this);
  };

  FileReaderFile.prototype.__event_progress = function(ev) {
    var loaded, percent, total;
    total = ev.total;
    loaded = ev.loaded;
    if (ev.lengthComputable) {
      percent = Math.floor(ev.loaded / ev.total * 100);
    } else {
      percent = -1;
    }
    if (loaded === total) {
      this.__progress.status = "COMPLETED";
    } else {
      this.__progress.status = "PROGRESS";
    }
    this.__progress.loaded = loaded;
    this.__progress.total = total;
    this.__progress.percent = percent;
    this.__dfr.notify(this);
  };

  FileReaderFile.prototype.__event_abort = function() {};

  FileReaderFile.prototype.__event_error = function() {};

  FileReaderFile.prototype.__event_load = function() {};

  FileReaderFile.prototype.__event_loadend = function() {
    this.__progress.data = this.__reader.result;
    this.__progress.status = "DONE";
    this.__upload = null;
    return this.__dfr.resolve(this);
  };

  FileReaderFile.prototype.abort = function() {
    return this.__reader.abort();
  };

  return FileReaderFile;

})(FileUploadFile);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var InputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

InputBlock = (function(superClass) {
  extend(InputBlock, superClass);

  function InputBlock(opts) {
    this.opts = opts != null ? opts : {};
    InputBlock.__super__.constructor.call(this, this.opts);
    this.__start = this._start;
    this.setString(this._string);
  }

  InputBlock.prototype.initOpts = function() {
    InputBlock.__super__.initOpts.call(this);
    return this.addOpts({
      start: {
        mandatory: true,
        check: function(v) {
          return isInteger(v) && v >= 0;
        }
      },
      string: {
        mandatory: true,
        check: function(v) {
          return isString(v);
        }
      }
    });
  };

  InputBlock.prototype.setString = function(s) {
    assert(isString(s), (getObjectClass(this)) + ".setString", "Parameter needs to be String with a minimum length of 1.", {
      string: s
    });
    this.__string = s;
    this.calcSizes();
    return this;
  };

  InputBlock.prototype.getString = function() {
    return this._string;
  };

  InputBlock.prototype.calcSizes = function() {
    var i, k, len, ref;
    this.__len = this.__string.length;
    this.__end = this.__start + this.__len;
    ref = ["len", "end", "start", "string"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this[k] = this["__" + k];
    }
    return this;
  };

  InputBlock.prototype.incrementBlock = function(block, blocks) {
    return block;
  };

  InputBlock.prototype.decrementBlock = function(block, blocks) {
    return block;
  };

  InputBlock.prototype.toString = function() {
    return dump({
      start: this.__start,
      end: this.__end,
      len: this.__len,
      string: this.__string
    });
  };

  return InputBlock;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var NumberInputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

NumberInputBlock = (function(superClass) {
  extend(NumberInputBlock, superClass);

  function NumberInputBlock() {
    return NumberInputBlock.__super__.constructor.apply(this, arguments);
  }

  NumberInputBlock.prototype.incrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, 1);
  };

  NumberInputBlock.prototype.decrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, -1);
  };

  NumberInputBlock.prototype.__changeBlock = function(block, blocks, diff) {
    var nn, number;
    number = parseInt(this.__string);
    nn = ("" + (number + diff)).split("");
    return block.setString(nn.join(""));
  };

  return NumberInputBlock;

})(InputBlock);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var NumberInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.NumberInput = (function(superClass) {
  extend(NumberInput, superClass);

  function NumberInput() {
    return NumberInput.__super__.constructor.apply(this, arguments);
  }

  NumberInput.prototype.initOpts = function() {
    NumberInput.__super__.initOpts.call(this);
    this.addOpts({
      decimals: {
        "default": 0,
        check: "Integer"
      },
      symbol: {
        check: function(v) {
          return isString(v) && v.length > 0;
        }
      },
      symbol_before: {
        "default": false,
        check: Boolean
      },
      store_as_integer: {
        "default": false,
        check: Boolean
      },
      decimalpoint: {
        mandatory: true,
        "default": ".",
        check: [",", "."]
      },
      separator: {
        check: function(v) {
          return isString(v) && v.length > 0;
        }
      },
      min: {
        "default": null,
        check: function(v) {
          return isNumber(v);
        }
      },
      max: {
        "default": null,
        check: function(v) {
          return isNumber(v);
        }
      }
    });
    this.removeOpt("checkInput");
    this.removeOpt("getValueForDisplay");
    this.removeOpt("getValueForInput");
    this.removeOpt("correctValueForInput");
    return this.removeOpt("prevent_invalid_input");
  };

  NumberInput.prototype.readOpts = function() {
    NumberInput.__super__.readOpts.call(this);
    this._checkInput = this.__checkInput;
    this._prevent_invalid_input = true;
    this.setMin(this._min);
    return this.setMax(this._max);
  };

  NumberInput.prototype.setMin = function(__min) {
    this.__min = __min;
  };

  NumberInput.prototype.setMax = function(__max) {
    this.__max = __max;
  };

  NumberInput.prototype.formatValueForDisplay = function(value, forInput) {
    var decimals, number, v, v0, v1;
    if (value == null) {
      value = this.getValue();
    }
    if (forInput == null) {
      forInput = false;
    }
    assert(typeof value === "number" || value === null, "NumberInput.formatValueForDisplay", "value needs to be Number or null", {
      value: value,
      type: typeof value
    });
    if (isEmpty(value)) {
      return "";
    }
    if (this._store_as_integer) {
      v = (value / Math.pow(10, this._decimals)).toFixed(this._decimals);
    } else {
      v = value + "";
    }
    v0 = v.split(".");
    if (v0.length > 1) {
      number = v0[0];
      decimals = v0[1];
    } else {
      number = v0[0];
      decimals = "";
    }
    if (this._decimals > 0) {
      while (decimals.length < this._decimals) {
        decimals = decimals + "0";
      }
    }
    if (forInput) {
      if (this._decimals > 0) {
        return number + this._decimalpoint + decimals;
      } else {
        return number;
      }
    }
    if (this._decimals > 0) {
      v1 = this.__addSeparator(number) + this._decimalpoint + decimals;
    } else {
      v1 = this.__addSeparator(number);
    }
    return this.__addSymbol(v1);
  };

  NumberInput.prototype.getValue = function() {
    var v;
    v = NumberInput.__super__.getValue.call(this);
    if (this.hasData()) {
      return v;
    }
    return this.getValueForStore(v);
  };

  NumberInput.prototype.getValueForDisplay = function() {
    return this.formatValueForDisplay(this.getValue());
  };

  NumberInput.prototype.getValueForStore = function(value) {
    var number;
    if (!isString(value)) {
      value = value + "";
    }
    number = parseFloat(value.replace(/,/, "."));
    if (isNaN(number)) {
      return null;
    }
    if (this._store_as_integer) {
      return parseInt((number * Math.pow(10, this._decimals)).toFixed(0));
    }
    return number;
  };

  NumberInput.prototype.getDefaultValue = function() {
    return null;
  };

  NumberInput.prototype.setValue = function(v, flags) {
    if (flags == null) {
      flags = {};
    }
    this.checkValue(v);
    return NumberInput.__super__.setValue.call(this, v, flags);
  };

  NumberInput.prototype.checkValue = function(v) {
    if (v === null) {
      return true;
    } else if (this._decimals > 0 && isFloat(v)) {
      return true;
    } else if (isInteger(v)) {
      return true;
    } else {
      throw new Error(this.__cls + ".setValue(value): Value needs to be Number or null.");
    }
  };

  NumberInput.prototype.__addSymbol = function(str) {
    if (isEmpty(this._symbol)) {
      return str;
    }
    if (this._symbol_before) {
      return this._symbol + " " + str;
    } else {
      return str + " " + this._symbol;
    }
  };

  NumberInput.prototype.__addSeparator = function(str) {
    var i, idx, len, n, nn, ref;
    if (isEmpty(this._separator)) {
      return str;
    }
    nn = [];
    ref = str.split("").reverse();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      n = ref[idx];
      if (idx % 3 === 0 && idx > 0) {
        nn.push(this._separator);
      }
      nn.push(n);
    }
    nn.reverse();
    return nn.join("");
  };

  NumberInput.prototype.correctValueForInput = function(value) {
    return value.replace(/[,\.]/, this._decimalpoint);
  };

  NumberInput.prototype.getValueForInput = function() {
    return this.formatValueForDisplay(null, true);
  };

  NumberInput.prototype.checkInput = function(value) {
    if (value === null) {
      return true;
    } else {
      return NumberInput.__super__.checkInput.call(this, value);
    }
  };

  NumberInput.prototype.__checkInput = function(value) {
    var number, point_idx, points, re, v;
    if (!this.hasShadowFocus()) {
      v = value.replace(this._symbol, "");
    } else {
      v = value;
    }
    v = v.trim();
    if (v === "") {
      return true;
    }
    if (this._separator) {
      re = new RegExp(RegExp.escape(this._separator), "g");
      v = v.replace(re, "");
    }
    point_idx = v.lastIndexOf(this._decimalpoint);
    if (point_idx === -1) {
      number = v;
      points = "";
    } else {
      if (this._decimals === 0) {
        return false;
      }
      number = v.substring(0, point_idx);
      points = v.substring(point_idx + 1);
    }
    if (points.length > this._decimals) {
      return false;
    }
    if (number.length > 0 && !number.match(/^((0|[1-9]+[0-9]*)|(-|-[1-9]|-[1-9][0-9]*))$/)) {
      return false;
    }
    if (!isNull(this.__min)) {
      if (this.__min >= 0 && number === "-") {
        return false;
      }
      if (number < this.__min) {
        return false;
      }
    }
    if (!isNull(this.__max)) {
      if (number > this.__max) {
        return false;
      }
    }
    if (!points.match(/^([0-9]*)$/)) {
      return false;
    }
    if (points.length > this._decimals) {
      return false;
    }
    return true;
  };

  NumberInput.format = function(v, opts) {
    var _v, ni;
    if (opts == null) {
      opts = {};
    }
    if (isEmpty(v)) {
      v = null;
    }
    if (isFloat(v) && !opts.hasOwnProperty("decimals")) {
      _v = v + "";
      opts.decimals = _v.length - _v.indexOf(".") - 1;
    }
    ni = new NumberInput(opts);
    ni.start();
    if (!ni.checkInput(v + "")) {
      return null;
    } else {
      return ni.formatValueForDisplay(v);
    }
  };

  return NumberInput;

})(CUI.Input);

NumberInput = CUI.NumberInput;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var EmailInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.EmailInput = (function(superClass) {
  extend(EmailInput, superClass);

  function EmailInput() {
    return EmailInput.__super__.constructor.apply(this, arguments);
  }

  EmailInput.prototype.initOpts = function() {
    EmailInput.__super__.initOpts.call(this);
    return this.removeOpt("checkInput");
  };

  EmailInput.prototype.readOpts = function() {
    EmailInput.__super__.readOpts.call(this);
    return this._checkInput = this.__checkInput;
  };

  EmailInput.prototype.__checkInput = function(value) {
    if (isEmpty(value) || EmailInput.regexp.exec(value)) {
      return true;
    } else {
      return false;
    }
  };

  EmailInput.regexp = /^[\S]+@(?:[\S]+\.[A-Z]{2,}|localhost)$/i;

  return EmailInput;

})(CUI.Input);

EmailInput = CUI.EmailInput;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DateTime,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.tz_data = {};

CUI.DateTime = (function(superClass) {
  extend(DateTime, superClass);

  function DateTime(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    DateTime.__super__.constructor.call(this, this.opts);
    this.init();
  }

  DateTime.defaults = {
    button_tooltip: "Open calendar"
  };

  DateTime.prototype.initOpts = function() {
    var locale;
    DateTime.__super__.initOpts.call(this);
    if (DateTime.__locale) {
      locale = DateTime.__locale;
    } else {
      for (locale in DateTimeFormats) {
        break;
      }
    }
    this.addOpts({
      locale: {
        mandatory: true,
        "default": locale,
        check: function(v) {
          var ref;
          return CUI.isArray((ref = DateTimeFormats[v]) != null ? ref.formats : void 0);
        }
      },
      input_types: {
        check: Array
      },
      display_type: {
        "default": "long",
        check: ["long", "short"]
      },
      min_year: {
        mandatory: true,
        "default": 0,
        check: "Integer"
      },
      max_year: {
        mandatory: true,
        "default": 2499,
        check: "Integer"
      },
      store_invalid: {
        mandatory: true,
        "default": false,
        check: Boolean
      }
    });
    this.removeOpt("getValueForDisplay");
    this.removeOpt("getValueForInput");
    this.removeOpt("checkInput");
    return this.removeOpt("getInputBlocks");
  };

  DateTime.prototype.init = function() {
    var f, format, found, i, j, l, len, len1, len2, ref, ref1, ref2, ref3, type;
    this.__regexpMatcher = this.regexpMatcher();
    this.__input_formats_known = DateTimeFormats[this._locale].formats;
    this.__locale_format = DateTimeFormats[this._locale];
    this.__input_formats = [];
    if (!((ref = this._input_types) != null ? ref.length : void 0)) {
      this.__input_formats = this.__input_formats_known.slice(0);
    } else {
      ref1 = this._input_types;
      for (i = 0, len = ref1.length; i < len; i++) {
        type = ref1[i];
        found = false;
        ref2 = this.__input_formats_known;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          f = ref2[j];
          if (f.type === type) {
            this.__input_formats.push(f);
            found = true;
          }
        }
        assert(found, "new DateTime", "opts.input_types contains unknown type: " + type, {
          formats: this.__input_formats_known,
          input_type: this._input_types
        });
      }
    }
    this.__default_format = this.__input_formats[0];
    ref3 = this.__input_formats;
    for (l = 0, len2 = ref3.length; l < len2; l++) {
      format = ref3[l];
      if (format.clock === false) {
        this.__input_format_no_time = format;
        this.__default_format = format;
        break;
      }
    }
    this.__input_format = this.initFormat(this.__default_format);
  };

  DateTime.prototype.setInputFormat = function(use_clock) {
    if (use_clock === true) {
      this.__input_format = this.initFormat(this.__input_formats[0]);
    } else {
      this.__input_format = this.initFormat(this.__input_format_no_time);
    }
    return this;
  };

  DateTime.prototype.initDateTimePicker = function() {
    var i, k, len, ref;
    if (this.__dateTimeTmpl) {
      return this.__dateTimeTmpl;
    }
    this.__dateTimeTmpl = new Template({
      name: "date-time",
      map: {
        calendar: true,
        analog_clock: true,
        hour_minute: true,
        digi_clock: true,
        header_left: true,
        header_center: true,
        header_right: true,
        hour: true,
        minute: true,
        second: true
      }
    });
    ref = ["calendar", "hour_minute", "hour", "minute", "second"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this["__" + k] = this.__dateTimeTmpl.map[k];
    }
    this.__dateTimeTmpl.append(new CUI.defaults["class"].Button({
      "class": "cui-date-time-browser-date",
      icon_left: "left",
      text: this.__locale_format.tab_date,
      onClick: (function(_this) {
        return function() {
          return _this.setCursor("day");
        };
      })(this)
    }), "header_left");
    this.__dateTimeTmpl.append(new CUI.defaults["class"].Button({
      "class": "cui-date-time-browser-time",
      icon_right: "right",
      text: this.__locale_format.tab_time,
      onClick: (function(_this) {
        return function() {
          return _this.setCursor("hour");
        };
      })(this)
    }), "header_right");
    this.setCursor("day");
    return this.__dateTimeTmpl;
  };

  DateTime.prototype.getTemplate = function() {
    return new Template({
      name: "date-time-input",
      map: {
        center: true,
        right: true
      }
    });
  };

  DateTime.prototype.readOpts = function() {
    DateTime.__super__.readOpts.call(this);
    this._checkInput = this.__checkInput;
    return this._getInputBlocks = this.__getInputBlocks;
  };

  DateTime.prototype.getCurrentFormat = function() {
    return this.__input_format;
  };

  DateTime.prototype.getCurrentFormatDisplay = function() {
    var ref;
    return (ref = this.__input_format) != null ? ref.__display : void 0;
  };

  DateTime.prototype.setCursor = function(cursor) {
    var title;
    switch (cursor) {
      case "hour":
      case "minute":
      case "second":
      case "am_pm":
        title = this.__locale_format.tab_time;
        DOM.setAttribute(this.__dateTimeTmpl.DOM[0], "browser", "time");
        this.setDigiClock();
        break;
      default:
        title = this.__locale_format.tab_date;
        DOM.setAttribute(this.__dateTimeTmpl.DOM[0], "browser", "date");
    }
    this.__dateTimeTmpl.replace(new Label({
      text: title
    }), "header_center");
    return this;
  };

  DateTime.prototype.initFormat = function(input_format) {
    var input, k, last_match_end, match, match_start, match_str, matcher, re, ref, regexp, rstr, s, v;
    moment.locale(this.__locale_format.moment_locale || this._locale);
    switch (this._display_type) {
      case "short":
        input_format.__display = input_format.display_short;
        break;
      default:
        input_format.__display = input_format.display;
    }
    this._invalidHint = {
      text: input_format.invalid
    };
    ref = this.__regexpMatcher;
    for (k in ref) {
      v = ref[k];
      v.match_str = k;
    }
    input = input_format.input;
    rstr = "(" + Object.keys(this.__regexpMatcher).join("|") + ")";
    re = new RegExp(rstr, "g");
    s = input.split("");
    regexp = [];
    matcher = [];
    last_match_end = 0;
    while ((match = re.exec(input)) !== null) {
      match_str = match[0];
      match_start = match.index;
      regexp.push("(" + escapeRegExp(s.slice(last_match_end, match_start).join("")) + ")");
      regexp.push("(" + this.__regexpMatcher[match_str].regexp + ")");
      matcher.push(this.__regexpMatcher[match_str]);
      last_match_end = match_start + match_str.length;
    }
    regexp.push("(" + escapeRegExp(s.slice(last_match_end).join("")) + ")");
    input_format.regexp = new RegExp("^" + regexp.join("") + "$");
    input_format.matcher = matcher;
    return input_format;
  };

  DateTime.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  DateTime.prototype.render = function() {
    var attr, btn, display_key;
    DateTime.__super__.render.call(this);
    if (isEmpty(this._placeholder)) {
      this.__input.prop("placeholder", this.__input_formats[0].text);
    }
    switch (this._display_type) {
      case "short":
        display_key = "display_short";
        break;
      default:
        display_key = "display";
    }
    attr = this.__input_formats[0][display_key + '_attribute'];
    if (!attr) {
      attr = this.__input_formats[0][display_key].replace(/[:, \.]/g, "-").replace(/-+/g, "-");
    }
    this.DOM.setAttribute("data-cui-date-time-format", attr);
    btn = new CUI.defaults["class"].Button({
      icon: "calendar",
      tooltip: {
        text: CUI.DateTime.defaults.button_tooltip
      },
      onClick: (function(_this) {
        return function() {
          return _this.openPopover(btn);
        };
      })(this)
    });
    return this.replace(btn, "right");
  };

  DateTime.prototype.format = function(_s, type, output_type) {
    var f, format, formats_tried, i, j, k, l, len, len1, len2, mom, output_format, ref, ref1, ref2, s;
    if (type == null) {
      type = "display";
    }
    if (output_type == null) {
      output_type = null;
    }
    assert(indexOf.call(DateTime.formatTypes, type) >= 0, "DateTime.format", "type must be on of \"" + (DateTime.formatTypes.join(',')) + "\".", {
      parm1: _s,
      type: type
    });
    if (moment.isMoment(_s)) {
      mom = _s;
    } else {
      s = _s != null ? _s.trim() : void 0;
      if (isEmpty(s)) {
        return null;
      }
      mom = this.parse(s, this.__input_formats_known);
    }
    if (mom.isValid() && isNull(output_type)) {
      output_type = this.getCurrentFormat().type;
    }
    if (!mom.isValid()) {
      formats_tried = [];
      ref = this.__input_formats_known;
      for (i = 0, len = ref.length; i < len; i++) {
        format = ref[i];
        ref1 = DateTime.formatTypes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          k = ref1[j];
          formats_tried.push(format[k]);
        }
      }
      console.warn("DateTime.format: Moment '" + s + "' is invalid. Tried formats:", formats_tried);
      return null;
    }
    output_format = null;
    ref2 = this.__input_formats_known;
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      f = ref2[l];
      if (f.type === output_type) {
        output_format = f;
        break;
      }
    }
    assert(output_format, "DateTime.format", "output_type must be in known formats", {
      formats: this.__input_formats_known,
      output_type: output_type
    });
    return mom.format(output_format[type]);
  };

  DateTime.prototype.regexpMatcher = function() {
    return {
      YYYY: {
        regexp: "(?:-|)[0-9]{1,}",
        inc_func: "year",
        cursor: "year"
      },
      MM: {
        regexp: "(?:0[1-9]|1[0-2])",
        inc_func: "month",
        cursor: "month"
      },
      DD: {
        regexp: "[0-3][0-9]",
        inc_func: "day",
        cursor: "day"
      },
      HH: {
        regexp: "[0-2][0-9]",
        inc_func: "hour",
        cursor: "hour"
      },
      hh: {
        regexp: "[0-1][0-9]",
        inc_func: "hour",
        cursor: "hour"
      },
      mm: {
        regexp: "[0-5][0-9]",
        inc_func: "minute",
        cursor: "minute"
      },
      ss: {
        regexp: "[0-5][0-9]",
        inc_func: "second",
        cursor: "second"
      },
      A: {
        regexp: "(?:AM|PM)",
        inc_func: this.incAMPM,
        cursor: "am_pm"
      },
      a: {
        regexp: "(?:am|pm)",
        inc_func: this.incAMPM,
        cursor: "am_pm"
      }
    };
  };

  DateTime.prototype.incAMPM = function(mom, diff) {
    var current_hour;
    current_hour = mom.hour();
    if (current_hour < 12) {
      return mom.add(12, "hour");
    } else {
      return mom.subtract(12, "hour");
    }
  };

  DateTime.prototype.initValue = function() {
    var corrected_value, value;
    DateTime.__super__.initValue.call(this);
    value = this.getValue();
    corrected_value = this.parseValue(value, "store");
    if (corrected_value && corrected_value !== value) {
      CUI.warn("DateTime.initValue: Corrected value in data:", corrected_value, "Original value:", value);
      this.__data[this._name] = corrected_value;
    }
    return this;
  };

  DateTime.prototype.getValueForDisplay = function() {
    var mom, ref, value;
    value = (ref = this.getValue()) != null ? typeof ref.trim === "function" ? ref.trim() : void 0 : void 0;
    if (isEmpty(value)) {
      return "";
    }
    mom = this.parse(value);
    if (mom.isValid()) {
      return mom.format(this.getCurrentFormatDisplay());
    } else {
      return value;
    }
  };

  DateTime.prototype.getValueForInput = function(v) {
    var mom;
    if (v == null) {
      v = this.getValue();
    }
    if (isEmpty(v != null ? v.trim() : void 0)) {
      return "";
    }
    mom = this.parse(v);
    if (mom.isValid()) {
      return mom.format(this.__input_format.input);
    } else {
      return v;
    }
  };

  DateTime.prototype.__checkInput = function(value) {
    var mom;
    if (!isEmpty(value != null ? value.trim() : void 0)) {
      mom = this.parse(value);
      if (!mom.isValid()) {
        return false;
      }
    } else {
      this.__input_format = this.initFormat(this.__default_format);
    }
    return true;
  };

  DateTime.prototype.__getInputBlocks = function(v) {
    var blocks, i, idx, len, m, match, pos;
    CUI.debug("getInputBlocks", v, this.__input_format.regexp);
    match = v.match(this.__input_format.regexp);
    if (!match) {
      return false;
    }
    blocks = [];
    pos = 0;
    for (idx = i = 0, len = match.length; i < len; idx = ++i) {
      m = match[idx];
      if (idx === 0) {
        continue;
      }
      if (idx % 2 === 0) {
        blocks.push(new DateTimeInputBlock({
          start: pos,
          string: m,
          datetime: v,
          input_format: this.__input_format,
          matcher: this.__input_format.matcher[idx / 2 - 1]
        }));
      }
      pos += m.length;
      if (idx % 2 === 1) {
        continue;
      }
    }
    return blocks;
  };

  DateTime.prototype.start_day = 1;

  DateTime.prototype.storeValue = function(value, flags) {
    var mom;
    if (flags == null) {
      flags = {};
    }
    mom = this.parse(value);
    if (mom.isValid()) {
      value = mom.format(this.__input_format.store);
    } else if (this._store_invalid && value.trim().length > 0) {
      value = 'invalid';
    } else {
      value = null;
    }
    DateTime.__super__.storeValue.call(this, value, flags);
    return this;
  };

  DateTime.prototype.getDigiDisplay = function(format) {
    var cursor, d, digits, i, idx, len, ref;
    digits = [];
    ref = format.split("");
    for (i = 0, len = ref.length; i < len; i++) {
      d = ref[i];
      if ((idx = ["H", "h", "m", "s", "A", "a"].indexOf(d)) > -1) {
        cursor = ["hour", "hour", "minute", "second", "am_pm", "am_pm"][idx];
        if (d === "A" || d === "a") {
          digits.push({
            mask: "[aApP]",
            attr: {
              cursor: cursor,
              title: cursor
            }
          });
          digits.push({
            mask: "[mM]",
            attr: {
              cursor: cursor,
              title: cursor
            }
          });
        } else {
          digits.push({
            mask: "[0-9]",
            attr: {
              cursor: cursor
            }
          });
        }
      } else if (d === "*") {
        digits.push({
          mask: "[0-9A-Z+\-:\. ]"
        });
      } else {
        digits.push({
          "static": ":"
        });
      }
    }
    return this.__digiDisplay = new DigiDisplay({
      digits: digits
    });
  };

  DateTime.prototype.openPopover = function(btn) {
    this.initDateTimePicker();
    this.__popover = new Popover({
      element: btn,
      handle_focus: false,
      onHide: (function(_this) {
        return function() {
          _this.displayValue();
          return _this.closePopover();
        };
      })(this),
      placement: "se",
      "class": "cui-date-time-popover",
      pane: {
        content: this.__dateTimeTmpl
      }
    });
    this.updateDateTimePicker();
    this.setCursor("day");
    this.__popover.show();
    return this;
  };

  DateTime.prototype.closePopover = function() {
    if (this.__popover) {
      this.__popover.destroy();
      this.__gridTable = null;
      delete this.__popover;
    }
    return this;
  };

  DateTime.prototype.updateDateTimePicker = function() {
    this.setMomentFromInput();
    CUI.debug("updating popover...", this.__input_format);
    this.drawDate();
    this.setClock();
    this.setDigiClock();
    this.setPrintClock();
    return this;
  };

  DateTime.prototype.destroy = function() {
    this.closePopover();
    return DateTime.__super__.destroy.call(this);
  };

  DateTime.prototype.setClock = function(mom) {
    var hour, hours, millisecond, minute, minutes, second, seconds;
    if (mom == null) {
      mom = this.__current_moment;
    }
    hour = mom.hour();
    minute = mom.minute();
    second = mom.second();
    millisecond = 0;
    seconds = second + millisecond / 1000;
    minutes = minute + seconds / 60;
    hours = (hour % 12) + minutes / 60;
    this.__hour.css("transform", "rotate(" + hours * 30 + "deg)");
    this.__minute.css("transform", "rotate(" + minutes * 6 + "deg)");
    return this.__second.css("transform", "rotate(" + seconds * 6 + "deg)");
  };

  DateTime.prototype.setDigiClock = function(mom) {
    var f;
    if (mom == null) {
      mom = this.__current_moment;
    }
    f = this.__input_format.digi_clock;
    CUI.debug("setDigiClock", f, mom, mom.format(f));
    if (f) {
      this.__digiDisplay.display(mom.format(f));
    }
    return this;
  };

  DateTime.prototype.setPrintClock = function(mom) {
    var mom_tz;
    if (mom == null) {
      mom = this.__current_moment;
    }
    if (!this.__input_format.timezone_display) {
      return this;
    }
    mom_tz = mom.clone();
    mom_tz.tz(CUI.tz_data.tz);
    return this.__timezone_display.empty().append(mom_tz.format(this.__input_format.timezone_display));
  };

  DateTime.prototype.setTimezone = function() {};

  DateTime.prototype.UNUSEDgetTimezoneData = function() {
    if (this.__tz_data) {
      return CUI.resolvedPromise();
    }
    return $.get((CUI.getPathToScript()) + "/moment-timezone-meta.json").done((function(_this) {
      return function(tz_data) {
        var by_name, i, j, len, len1, n, names, results, tz;
        names = [];
        by_name = {};
        for (i = 0, len = tz_data.length; i < len; i++) {
          tz = tz_data[i];
          tz.geo = tz.lat + "/" + tz.long;
          tz.print_name = tz.name;
          names.push(tz.print_name);
          by_name[tz.print_name] = tz;
        }
        names.sort();
        _this.__tz_data = [];
        results = [];
        for (j = 0, len1 = names.length; j < len1; j++) {
          n = names[j];
          results.push(_this.__tz_data.push(by_name[n]));
        }
        return results;
      };
    })(this));
  };

  DateTime.prototype.getTimezoneOpts = function() {
    var i, idx, len, mom, opts, ref, tz;
    if (this.__current_moment) {
      mom = this.__current_moment.clone();
    }
    opts = [];
    ref = this.__tz_data;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      tz = ref[idx];
      if (!mom && tz.name !== DateTimeFormats["de-DE"].timezone) {
        continue;
      }
      opts.push({
        text: tz.print_name,
        right: mom ? $span("cui-timezone-offset").prop("title", tz.geo).text(mom.tz(tz.name).format("zZ")) : null,
        value: tz.name
      });
    }
    return opts;
  };

  DateTime.prototype.parse = function(s, formats, use_formats) {
    var format, i, len, mom;
    if (formats == null) {
      formats = this.__input_formats;
    }
    if (use_formats == null) {
      use_formats = formats;
    }
    if (!((s != null ? typeof s.trim === "function" ? s.trim().length : void 0 : void 0) > 0)) {
      return moment.invalid();
    }
    for (i = 0, len = formats.length; i < len; i++) {
      format = formats[i];
      mom = this.__parseFormat(format, s);
      if (mom) {
        if (indexOf.call(use_formats, format) >= 0) {
          this.__input_format = this.initFormat(format);
        } else {
          this.__input_format = this.initFormat(this.__default_format);
        }
        mom.locale(moment.locale());
        return mom;
      }
    }
    return moment.invalid();
  };

  DateTime.prototype.parseValue = function(value, output_format) {
    var format, i, input_formats, len, mom, ref;
    if (output_format == null) {
      output_format = null;
    }
    input_formats = this.__input_formats.slice(0);
    ref = this.__input_formats_known;
    for (i = 0, len = ref.length; i < len; i++) {
      format = ref[i];
      pushOntoArray(format, input_formats);
    }
    mom = this.parse(value, input_formats, this.__input_formats);
    if (!output_format) {
      return mom;
    }
    if (mom.isValid()) {
      return mom.format(this.__input_format[output_format]);
    } else {
      return null;
    }
  };

  DateTime.prototype.__parseFormat = function(f, s) {
    var i, j, k, len, len1, mom, p, ref, ref1;
    ref = DateTime.formatTypes;
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      assert(f[k], "DateTime.__parseFormat", "." + k + " must be set", {
        format: f
      });
      mom = moment(s, f[k], true);
      if (mom.isValid()) {
        return mom;
      }
    }
    ref1 = f.parse;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      p = ref1[j];
      mom = moment(s, p, true);
      if (mom.isValid()) {
        return mom;
      }
    }
  };

  DateTime.prototype.setMomentFromInput = function() {
    var inp;
    inp = this.__input0.value.trim();
    if (inp.length > 0) {
      this.__current_moment = this.parse(inp);
    }
    if (inp === "" || !this.__current_moment.isValid()) {
      this.__current_moment = moment();
      this.__current_moment.__now = true;
      this.__input_format = this.initFormat(this.__default_format);
    }
  };

  DateTime.prototype.setInputFromMoment = function() {
    this.__clearOverwriteMonthAndYear();
    this.setValue(this.__current_moment.format(this.__input_format.input), {
      no_trigger: false
    });
    return this;
  };

  DateTime.prototype.__clearOverwriteMonthAndYear = function() {
    this.__overwrite_month = null;
    return this.__overwrite_year = null;
  };

  DateTime.prototype.drawDate = function(_mom) {
    var mom;
    if (!_mom) {
      mom = this.__current_moment.clone();
    } else {
      mom = _mom;
    }
    return this.updateCalendar(mom, false);
  };

  DateTime.prototype.updateCalendar = function(mom, update_current_moment) {
    if (update_current_moment == null) {
      update_current_moment = true;
    }
    this.__calendar.empty();
    if (CUI.__ng__) {
      this.__calendar.append(this.getDateTimeDrawer(mom));
      this.__calendar.append(this.drawMonthTable(mom));
      this.__calendar.append(this.drawYearMonthsSelect(mom));
    } else {
      this.__calendar.append(this.drawYearMonthsSelect(mom));
      this.__calendar.append(this.drawMonthTable(mom));
    }
    if (update_current_moment) {
      this.__current_moment = mom.clone();
      this.setInputFromMoment();
    }
    console.info("DateTime.updateCalendar:", this.__current_moment.format(this.__input_format.input));
    this.markDay();
    return this;
  };

  DateTime.prototype.getDateTimeDrawer = function(mom) {
    var am_pm, am_pm_sel, data, date_sel, emtpy_clock_opts, hour_sel, minute_sel, month_sel, pad0, year_sel;
    am_pm = this.__input_formats[0].clock_am_pm;
    data = {
      month: mom.month(),
      year: mom.year(),
      date: mom.date(),
      hour: null,
      minute: null,
      second: null,
      am_pm: null
    };
    if (this.__input_format.clock) {
      data.hour = mom.hour();
      data.minute = mom.minute();
      data.second = mom.second();
      if (am_pm) {
        data.am_pm = Math.floor(data.hour / 12) * 12;
        data.hour = data.hour % 12;
      }
    }
    pad0 = function(n) {
      if (n < 10) {
        return "0" + n;
      } else {
        return "" + n;
      }
    };
    date_sel = new Select({
      name: "date",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.date(data.date));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var day, i, opts, ref;
          opts = [];
          for (day = i = 1, ref = mom.daysInMonth(); 1 <= ref ? i <= ref : i >= ref; day = 1 <= ref ? ++i : --i) {
            opts.push({
              text: pad0(day),
              value: day
            });
          }
          return opts;
        };
      })(this)
    }).start();
    month_sel = new Select({
      name: "month",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.month(data.month));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var i, month, opts;
          opts = [];
          for (month = i = 0; i <= 11; month = ++i) {
            opts.push({
              text: pad0(month + 1),
              value: month
            });
          }
          return opts;
        };
      })(this)
    }).start();
    year_sel = new Select({
      name: "year",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.year(data.year));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var i, opts, ref, ref1, year;
          opts = [];
          for (year = i = ref = data.year - 20, ref1 = data.year + 20; ref <= ref1 ? i <= ref1 : i >= ref1; year = ref <= ref1 ? ++i : --i) {
            opts.push({
              text: "" + year,
              value: year
            });
          }
          return opts;
        };
      })(this)
    }).start();
    if (this.__input_formats[0].clock) {
      if (this.__input_format_no_time) {
        emtpy_clock_opts = [
          {
            text: '',
            value: null
          }
        ];
      } else {
        emtpy_clock_opts = [];
      }
      hour_sel = new Select({
        name: "hour",
        data: data,
        group: "time",
        onDataChanged: (function(_this) {
          return function(_data) {
            if (_data.hour === null) {
              _this.setInputFormat(false);
              return _this.updateCalendar(mom);
            } else {
              _this.setInputFormat(true);
              if (am_pm) {
                return _this.updateCalendar(mom.hour(data.hour + data.am_pm));
              } else {
                return _this.updateCalendar(mom.hour(data.hour));
              }
            }
          };
        })(this),
        options: (function(_this) {
          return function() {
            var hour, i, j, opts;
            opts = emtpy_clock_opts.slice(0);
            if (am_pm) {
              for (hour = i = 1; i <= 12; hour = ++i) {
                opts.push({
                  text: pad0(hour),
                  value: hour % 12
                });
              }
            } else {
              for (hour = j = 0; j <= 23; hour = ++j) {
                opts.push({
                  text: pad0(hour),
                  value: hour
                });
              }
            }
            return opts;
          };
        })(this)
      }).start();
      minute_sel = new Select({
        "class": "cui-date-time-60-select",
        name: "minute",
        group: "time",
        data: data,
        onDataChanged: (function(_this) {
          return function(_data) {
            if (_data.minute === null) {
              _this.setInputFormat(false);
              return _this.updateCalendar(mom);
            } else {
              _this.setInputFormat(true);
              return _this.updateCalendar(mom.minute(data.minute));
            }
          };
        })(this),
        options: (function(_this) {
          return function() {
            var i, minute, opts;
            opts = emtpy_clock_opts.slice(0);
            for (minute = i = 0; i <= 59; minute = ++i) {
              opts.push({
                text: pad0(minute),
                value: minute
              });
            }
            return opts;
          };
        })(this)
      }).start();
      if (am_pm) {
        am_pm_sel = new Select({
          "class": "cui-date-time-am-pm-select",
          name: "am_pm",
          group: "time",
          data: data,
          onDataChanged: (function(_this) {
            return function(_data) {
              if (_data.am_pm === null) {
                _this.setInputFormat(false);
                return _this.updateCalendar(mom);
              } else {
                _this.setInputFormat(true);
                return _this.updateCalendar(mom.hour(data.hour + data.am_pm));
              }
            };
          })(this),
          options: (function(_this) {
            return function() {
              var i, len, opts, ref;
              opts = emtpy_clock_opts.slice(0);
              ref = ["AM", "PM"];
              for (i = 0, len = ref.length; i < len; i++) {
                am_pm = ref[i];
                opts.push({
                  text: am_pm,
                  value: am_pm === "AM" ? 0 : 12
                });
              }
              return opts;
            };
          })(this)
        }).start();
      }
    }
    return new Buttonbar({
      buttons: [date_sel, month_sel, year_sel, hour_sel, minute_sel, am_pm_sel]
    }).DOM;
  };

  DateTime.prototype.drawYearMonthsSelect = function(mom) {
    var data, header_year_month, i, idx, len, m, month_opts, now_year, ref;
    data = {
      month: mom.month(),
      year: mom.year()
    };
    month_opts = [];
    ref = moment.months();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      m = ref[idx];
      month_opts.push({
        text: m,
        value: idx
      });
    }
    now_year = moment().year();
    header_year_month = new HorizontalLayout({
      maximize_vertical: false,
      maximize_horizontal: true,
      "class": "cui-date-time-footer",
      left: {
        content: new Buttonbar({
          "class": "cui-date-time-header-month",
          buttons: [
            {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "left",
              onClick: (function(_this) {
                return function(ev) {
                  if (mom.clone().subtract(1, "months").year() < _this._min_year) {
                    return;
                  }
                  mom.subtract(1, "months");
                  return _this.drawDate(mom);
                };
              })(this)
            }, new Label({
              text: month_opts[data.month].text
            }), {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "right",
              onClick: (function(_this) {
                return function(ev) {
                  if (mom.clone().add(1, "months").year() > _this._max_year) {
                    return;
                  }
                  mom.add(1, "months");
                  return _this.drawDate(mom);
                };
              })(this)
            }
          ]
        })
      },
      right: {
        content: new Buttonbar({
          "class": "cui-date-time-header-year",
          buttons: [
            {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "left",
              group: CUI.__ng__ ? "year" : null,
              onClick: (function(_this) {
                return function(ev) {
                  if (data.year - 1 < _this._min_year) {
                    return;
                  }
                  mom.subtract(1, "years");
                  return _this.drawDate(mom);
                };
              })(this)
            }, new NumberInput({
              attr: {
                cursor: "year"
              },
              max: this._max_year,
              min: this._min_year,
              placeholder: "" + now_year,
              data: data,
              name: "year",
              group: CUI.__ng__ ? "year" : null,
              onDataChanged: (function(_this) {
                return function(data) {
                  var year;
                  if (isEmpty(data.year)) {
                    year = now_year;
                  } else {
                    year = data.year;
                  }
                  return _this.updateCalendar(mom.year(year));
                };
              })(this)
            }).start(), {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "right",
              group: CUI.__ng__ ? "year" : null,
              onClick: (function(_this) {
                return function(ev) {
                  if (data.year + 1 > _this._max_year) {
                    return;
                  }
                  mom.add(1, "years");
                  return _this.drawDate(mom);
                };
              })(this)
            }
          ]
        })
      }
    });
    return header_year_month.DOM;
  };

  DateTime.prototype.drawMonthTable = function(_mom) {
    var curr_m, curr_y, day_div, day_no, div_type, dow, i, mom, month, month_table, now, ref, ref1, td, td_func, tr, week_no, weekday, weeks, year;
    month = _mom.month();
    year = _mom.year();
    mom = moment([year, month, 1, _mom.hour(), _mom.minute(), _mom.second(), 0]);
    month_table = $table("cui-date-time-date");
    Events.listen({
      node: month_table,
      type: "click",
      call: (function(_this) {
        return function(ev) {
          var $target, data;
          ev.stopPropagation();
          $target = $(ev.getTarget());
          if ($target.closest(".cui-date-time-day").length) {
            data = DOM.data($target.closest("td,.cui-td")[0]);
            _this.__current_moment.year(data.year);
            _this.__current_moment.month(data.month);
            _this.__current_moment.date(data.date);
            _this.updateCalendar(_this.__current_moment);
            _this.closePopover();
          }
        };
      })(this)
    });
    tr = $tr("cui-date-time-month-header").appendTo(month_table);
    if (CUI.__ng__) {
      td_func = $th;
    } else {
      td_func = $td;
    }
    tr.append(td_func("cui-date-time-week-title").append($div("cui-date-time-dow").text(this.__locale_format.tab_week)));
    for (dow = i = ref = this.start_day, ref1 = this.start_day + 6; ref <= ref1 ? i <= ref1 : i >= ref1; dow = ref <= ref1 ? ++i : --i) {
      weekday = moment.weekdaysMin(dow % 7);
      day_div = $div("cui-date-time-dow").text(weekday);
      day_div.addClass("cui-date-time-day-" + weekday.toLowerCase());
      tr.append(td_func().append(day_div));
    }
    mom.subtract((mom.day() - this.start_day + 7) % 7, "days");
    dow = this.start_day;
    weeks = 0;
    now = moment();
    while (true) {
      curr_y = mom.year();
      curr_m = mom.month();
      day_no = mom.date();
      if ((dow - this.start_day) % 7 === 0) {
        if (weeks === 6) {
          break;
        }
        tr = $tr().appendTo(month_table);
        week_no = mom.week();
        tr.append($td("cui-date-time-week").append($text(week_no)));
        weeks++;
      }
      if (CUI.__ng__) {
        div_type = $td;
      } else {
        div_type = $div;
      }
      day_div = div_type("cui-date-time-day", {
        cursor: "day",
        datestr: [curr_y, curr_m, day_no].join("-")
      }).text(day_no);
      if (curr_m < month) {
        day_div.addClass("cui-date-time-previous-month");
      } else if (curr_m > month) {
        day_div.addClass("cui-date-time-next-month");
      } else {
        day_div.addClass("cui-date-time-same-month");
        if (year === now.year() && month === now.month() && day_no === now.date()) {
          day_div.addClass("cui-date-time-now");
        }
      }
      day_div.addClass("cui-date-time-day-" + mom.format("dd").toLowerCase());
      if (CUI.__ng__) {
        td = day_div.appendTo(tr);
      } else {
        td = $td().append(day_div).appendTo(tr);
      }
      DOM.data(td[0], {
        date: day_no,
        month: curr_m,
        year: curr_y
      });
      mom.add(1, "days");
      dow++;
    }
    return month_table;
  };

  DateTime.prototype.markDay = function() {
    var datestr;
    this.__dateTimeTmpl.DOM.find(".cui-date-time-calendar .cui-date-time-selected").removeClass("cui-date-time-selected");
    if (this.__current_moment.__now) {
      return;
    }
    datestr = [this.__current_moment.year(), this.__current_moment.month(), this.__current_moment.date()].join("-");
    this.__calendar.find("[datestr=\"" + datestr + "\"]").addClass("cui-date-time-selected");
  };

  DateTime.formatTypes = ["store", "input", "display", "display_short"];

  DateTime.setLocale = function(locale) {
    assert(DateTimeFormats[locale], "DateTime.setLocale", "Locale " + locale + " unknown", {
      DateTimeFormats: DateTimeFormats
    });
    return DateTime.__locale = locale;
  };

  DateTime.format = function(datestr_or_moment, type, output_type) {
    var dt, str;
    dt = new DateTime();
    str = dt.format(datestr_or_moment, type, output_type);
    return str;
  };

  DateTime.display = function(datestr_or_moment, opts) {
    var dt, mom;
    if (opts == null) {
      opts = {};
    }
    if (!opts.hasOwnProperty("input_types")) {
      opts.input_types = null;
    }
    dt = new DateTime(opts);
    mom = dt.parseValue(datestr_or_moment);
    if (!mom.isValid()) {
      return null;
    }
    return mom.format(dt.getCurrentFormatDisplay());
  };

  DateTime.toMoment = function(datestr) {
    var dt;
    if (isEmpty(datestr)) {
      return null;
    }
    dt = new DateTime({
      input_types: null
    });
    return dt.parse(datestr);
  };

  return DateTime;

})(CUI.Input);

DateTime = CUI.DateTime;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DateTimeFormats;

DateTimeFormats = {};

DateTimeFormats["de-DE"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wo",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      display_attribute: "date-time",
      display_short_attribute: "date-time-short",
      parse: ["YYYY-MM-DDTHH:mm:ss.SSSZ", "YYYY-MM-DDTHH:mm:ssZ", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      display_attribute: "date-time-seconds",
      display_short_attribute: "date-time-seconds-short",
      clock: true,
      clock_seconds: true,
      parse: ["YYYY-MM-DDTHH:mm:ssZ", "YYYY-MM-DD HH:mm:ss", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      display_attribute: "date",
      display_short_attribute: "date-short",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY", "YYYYMMDD"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      display_attribute: "year-month",
      display_short_attribute: "year-month-short",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY", "MM/YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      display_attribute: "year",
      display_short_attribute: "year",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["it-IT"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wk",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      display_attribute: "date-time",
      display_short_attribute: "date-time-short",
      parse: ["YYYY-MM-DDTHH:mm:ss.SSSZ", "YYYY-MM-DDTHH:mm:ssZ", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      display_attribute: "date-time-seconds",
      display_short_attribute: "date-time-seconds-short",
      clock: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      display_attribute: "date",
      display_short_attribute: "date-short",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY", "YYYYMMDD"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      display_attribute: "year-month",
      display_short_attribute: "year-month-short",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY", "MM/YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      display_attribute: "year",
      display_short_attribute: "year",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["es-ES"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wk",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      display_attribute: "date-time",
      display_short_attribute: "date-time-short",
      parse: ["YYYY-MM-DDTHH:mm:ss.SSSZ", "YYYY-MM-DDTHH:mm:ssZ", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      display_attribute: "date-time-seconds",
      display_short_attribute: "date-time-seconds-short",
      clock: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      display_attribute: "date",
      display_short_attribute: "date-short",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY", "YYYYMMDD"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      display_attribute: "year-month",
      display_short_attribute: "year-month-short",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY", "MM/YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      display_attribute: "year",
      display_short_attribute: "year",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["en-US"] = {
  timezone: "Europe/Berlin",
  moment_locale: "en-US",
  tab_date: "Date",
  tab_time: "Time",
  tab_week: "Wk",
  formats: [
    {
      text: "Date+Time",
      invalid: "Invalid Date",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_am_pm: true,
      clock_seconds: false,
      input: "MM/DD/YYYY HH:mm",
      display: "dd, MM/DD/YYYY HH:mm",
      display_short: "MM/DD/YYYY HH:mm",
      display_attribute: "date-time",
      display_short_attribute: "date-time-short",
      parse: ["YYYY-MM-DDTHH:mm:ss.SSSZ", "YYYY-MM-DDTHH:mm:ssZ", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Date+Time+Seconds",
      invalid: "Invalid Date",
      type: "date_time_seconds",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      input: "MM/DD/YYYY HH:mm:ss",
      display: "dd, MM/DD/YYYY HH:mm:ss",
      display_short: "MM/DD/YYYY HH:mm:ss",
      display_attribute: "date-time-seconds",
      display_short_attribute: "date-time-seconds-short",
      clock: true,
      clock_am_pm: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Date",
      input: "MM/DD/YYYY",
      invalid: "Invalid date",
      display: "dd, MM/DD/YYYY",
      display_short: "MM/DD/YYYY",
      display_attribute: "date",
      display_short_attribute: "date-short",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY", "YYYYMMDD"]
    }, {
      text: "Jahr-Monat",
      input: "MM/YYYY",
      invalid: "Invalid date",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM/YYYY",
      display_attribute: "year-month",
      display_short_attribute: "year-month-short",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY", "MM/YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Invalid date",
      display: "YYYY",
      display_short: "YYYY",
      display_attribute: "year",
      display_short_attribute: "year",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DateTimeInputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DateTimeInputBlock = (function(superClass) {
  extend(DateTimeInputBlock, superClass);

  function DateTimeInputBlock() {
    return DateTimeInputBlock.__super__.constructor.apply(this, arguments);
  }

  DateTimeInputBlock.prototype.initOpts = function() {
    DateTimeInputBlock.__super__.initOpts.call(this);
    return this.addOpts({
      matcher: {
        mandatory: true,
        check: "PlainObject"
      },
      datetime: {
        mandatory: true,
        check: String
      },
      input_format: {
        mandatory: true,
        check: function(v) {
          return !!v.input;
        }
      }
    });
  };

  DateTimeInputBlock.prototype.incrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, 1);
  };

  DateTimeInputBlock.prototype.decrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, -1);
  };

  DateTimeInputBlock.prototype.__changeBlock = function(block, blocks, diff) {
    var bl, i, len, mom;
    CUI.debug("change block", block, blocks, diff, this._datetime, this._input_format.format);
    mom = moment(this._datetime, this._input_format.input);
    if (CUI.isFunction(this._matcher.inc_func)) {
      this._matcher.inc_func(mom, diff);
    } else {
      if (diff < 0) {
        mom.subtract(this._matcher.inc_func_amount || 1, this._matcher.inc_func);
      } else {
        mom.add(this._matcher.inc_func_amount || 1, this._matcher.inc_func);
      }
    }
    for (i = 0, len = blocks.length; i < len; i++) {
      bl = blocks[i];
      bl.setString(mom.format(bl._matcher.match_str));
    }
    return block;
  };

  return DateTimeInputBlock;

})(InputBlock);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Password,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Password = (function(superClass) {
  extend(Password, superClass);

  function Password() {
    return Password.__super__.constructor.apply(this, arguments);
  }

  Password.prototype.__createElement = function() {
    return Password.__super__.__createElement.call(this, "password");
  };

  Password.prototype.showPassword = function() {
    return this.__input.prop("type", "text");
  };

  Password.prototype.hidePassword = function() {
    return this.__input.prop("type", "password");
  };

  return Password;

})(Input);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MultiInputControl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInputControl = (function(superClass) {
  extend(MultiInputControl, superClass);

  function MultiInputControl(opts) {
    var i, idx, key, key_names, len, ref;
    this.opts = opts != null ? opts : {};
    MultiInputControl.__super__.constructor.call(this, this.opts);
    this.__body = $(document.body);
    this.__keys = [];
    if (!this._keys) {
      return;
    }
    key_names = {};
    ref = this._keys;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      key = ref[idx];
      assert(isString(key.name) && !isEmpty(key.name), "new " + this.__cls, "opts.keys[" + idx + "].name must be non-empty String.", {
        opts: this.opts,
        key: key
      });
      assert(isString(key.tag) && !isEmpty(key.tag), "new " + this.__cls, "opts.keys[" + idx + "].tag must be non-empty String.", {
        opts: this.opts,
        key: key
      });
      assert(isUndef(key.enabled) || isBoolean(key.enabled), "new " + this.__cls, "opts.keys[" + idx + "].enabled must be Boolean.", {
        opts: this.opts,
        key: key
      });
      if (key_names.hasOwnProperty(key.name)) {
        assert(false, "new " + this.__cls, "Duplicate opts.keys[" + idx + "].name \"" + key.name + "\", name already used in #" + idx + ". Skipping.", {
          opts: this.opts,
          key: key
        });
        continue;
      }
      key_names[key.name] = idx;
      this.__keys.push({
        name: key.name,
        tag: key.tag,
        enabled: key.enabled,
        __idx: idx
      });
    }
    this.setPreferredKey(this._preferred_key);
  }

  MultiInputControl.prototype.initOpts = function() {
    MultiInputControl.__super__.initOpts.call(this);
    return this.addOpts({
      preferred_key: {
        check: String
      },
      keys: {
        check: function(v) {
          return CUI.isArray(v) && v.length > 0;
        }
      },
      user_control: {
        "default": true,
        check: Boolean
      }
    });
  };

  MultiInputControl.prototype.setPreferredKey = function(key_name) {
    var i, key, len, ref;
    this.__preferred_key = null;
    if (isNull(key_name)) {
      return this.__preferred_key;
    }
    ref = this.__keys;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (key.name === key_name) {
        this.__preferred_key = key;
      }
    }
    assert(this.__preferred_key, this.__cls + ".setPreferredKey", "key.name == \"" + key_name + "\" not found in keys.", {
      keys: this.__keys
    });
    return this.__preferred_key;
  };

  MultiInputControl.prototype.getPreferredKey = function() {
    return this.__preferred_key;
  };

  MultiInputControl.prototype.copy = function() {
    return this;
  };

  MultiInputControl.prototype.getKeys = function() {
    return this.__keys;
  };

  MultiInputControl.prototype.isEnabled = function(name) {
    var i, k, len, ref;
    ref = this.getKeys();
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (k.name === name) {
        return k.enabled;
      }
    }
    return void 0;
  };

  MultiInputControl.prototype.getUserControlOptions = function() {
    var fn, i, key, len, options, ref;
    options = [];
    ref = this.__keys;
    fn = function(key) {
      return options.push({
        active: key.enabled,
        onActivate: function() {
          CUI.debug("control activate", key.tag);
          key.enabled = true;
          return Events.trigger({
            type: "multi-input-control-update"
          });
        },
        onDeactivate: function(cb) {
          CUI.debug("control deactivate", key.tag);
          key.enabled = false;
          return Events.trigger({
            type: "multi-input-control-update"
          });
        },
        text: key.tag
      });
    };
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      fn(key);
    }
    return options;
  };

  MultiInputControl.prototype.showUserControl = function() {
    var options;
    options = new Options({
      min_checked: 1,
      options: this.getUserControlOptions()
    }).start();
    return this.popover = new Modal({
      "class": "cui-multi-input-control",
      onHide: (function(_this) {
        return function() {
          return _this.popover = null;
        };
      })(this),
      pane: {
        footer_right: new Button({
          text: "Done",
          onClick: (function(_this) {
            return function() {
              return _this.popover.destroy();
            };
          })(this)
        }),
        header_left: new Label({
          text: "MultiInputControl"
        }),
        content: options
      }
    }).show();
  };

  MultiInputControl.prototype.hasUserControl = function() {
    return this._user_control;
  };

  return MultiInputControl;

})(CUI.Element);

CUI.Events.registerEvent({
  type: "multi-input-control-update",
  sink: true
});
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MultiInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInput = (function(superClass) {
  extend(MultiInput, superClass);

  function MultiInput(opts) {
    this.opts = opts != null ? opts : {};
    MultiInput.__super__.constructor.call(this, this.opts);
    this.addClass("cui-multi-input");
  }

  MultiInput.prototype.initOpts = function() {
    MultiInput.__super__.initOpts.call(this);
    return this.addOpts({
      textarea: {
        "default": false,
        check: Boolean
      },
      spellcheck: {
        "default": false,
        check: Boolean
      },
      placeholder: {
        check: "PlainObject"
      },
      onFocus: {
        check: Function
      },
      onClick: {
        check: Function
      },
      onKeyup: {
        check: Function
      },
      onBlur: {
        check: Function
      },
      control: {
        mandatory: true,
        check: function(v) {
          return v instanceof MultiInputControl;
        }
      },
      content_size: {
        "default": false,
        check: Boolean
      }
    });
  };

  MultiInput.prototype.readOpts = function() {
    MultiInput.__super__.readOpts.call(this);
    return this.__inputs = null;
  };

  MultiInput.prototype.disable = function() {
    var i, inp, len, ref, results;
    MultiInput.__super__.disable.call(this);
    if (!this.__inputs) {
      return;
    }
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      results.push(inp.disable());
    }
    return results;
  };

  MultiInput.prototype.enable = function() {
    var i, inp, len, ref, results;
    MultiInput.__super__.enable.call(this);
    if (!this.__inputs) {
      return;
    }
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      results.push(inp.enable());
    }
    return results;
  };

  MultiInput.prototype.initValue = function() {
    var i, key, len, ref, v;
    if (isNull(v = this.__data[this._name])) {
      v = this.__data[this._name] = {};
    }
    ref = this._control.getKeys();
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (!v.hasOwnProperty(key.name)) {
        v[key.name] = "";
      }
    }
    return this;
  };

  MultiInput.prototype.setData = function(data) {
    MultiInput.__super__.setData.call(this, data);
    return this.setDataOnInputs();
  };

  MultiInput.prototype.setDataOnInputs = function() {
    var i, input, input_data, len, ref, results, v;
    if (!this.__inputs) {
      return;
    }
    input_data = copyObject(this.getValue(), true);
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      input = ref[i];
      input.setData(input_data);
      if (this._undo_support) {
        v = this.getInitValue()[input.getName()];
      } else {
        v = this.getValue()[input.getName()];
      }
      results.push(input.setCheckChangedValue(v));
    }
    return results;
  };

  MultiInput.prototype.setInputVisibility = function() {
    var i, inp, key, len, names, ok, ref;
    names = (function() {
      var i, len, ref, results;
      ref = this._control.getKeys();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        results.push(key.name);
      }
      return results;
    }).call(this);
    this.__inputs.sort((function(_this) {
      return function(a, b) {
        return compareIndex(names.indexOf(a.getOpt("name")), names.indexOf(b.getOpt("name")));
      };
    })(this));
    ok = false;
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      this.__multiInputDiv.append(inp.DOM);
      if (this._control.isEnabled(inp.getName())) {
        inp.show();
        ok = true;
      } else {
        inp.hide();
      }
    }
    if (!ok) {
      CUI.warn("MulitInput.setInputVisibility: No input visible.", {
        input: this.__inputs,
        control: this._control
      });
    }
    return Events.trigger({
      type: "content-resize",
      node: inp.DOM
    });
  };

  MultiInput.prototype.getUniqueIdForLabel = function() {
    var i, inp, len, ref;
    this.__initInputs();
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      if (this._control.isEnabled(inp.getName())) {
        return inp.getUniqueIdForLabel();
      }
    }
    return null;
  };

  MultiInput.prototype.focus = function() {
    var i, inp, len, ref;
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      if (this._control.isEnabled(inp.getName())) {
        inp.focus();
        return;
      }
    }
  };

  MultiInput.prototype.displayValue = function() {
    var i, input, len, ref;
    MultiInput.__super__.displayValue.call(this);
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      input = ref[i];
      input.displayValue();
    }
    return this;
  };

  MultiInput.prototype.__initInputs = function() {
    var fn, i, idx, input, input_opts, key, len, ref, ref1;
    if (this.__inputs) {
      return;
    }
    this.__multiInputDiv = $div("cui-multi-input-container");
    Events.listen({
      type: "multi-input-control-update",
      node: this.__multiInputDiv,
      call: (function(_this) {
        return function(ev) {
          return _this.setInputVisibility();
        };
      })(this)
    });
    this.__inputs = [];
    ref = this._control.getKeys();
    fn = (function(_this) {
      return function(input, key) {
        var btn;
        btn = new CUI.defaults["class"].Button({
          text: key.tag,
          tabindex: null,
          disabled: !_this._control.hasUserControl(),
          onClick: function(ev, btn) {
            return _this._control.showUserControl(ev, btn, _this.__multiInputDiv);
          },
          role: "multi-input-tag",
          "class": "cui-multi-input-tag-button"
        });
        input.append(btn, "right");
        return Events.listen({
          type: "data-changed",
          node: input,
          call: function(ev) {
            var values;
            values = copyObject(_this.getValue());
            values[key.name] = input.getValue();
            ev.stopImmediatePropagation();
            return _this.storeValue(values);
          }
        });
      };
    })(this);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      key = ref[idx];
      assert(CUI.isPlainObject(key), "new " + this.__cls, "opts.keys[" + idx + "] needs to be PlainObject.", {
        opts: this.opts
      });
      assert(isString(key.name), "new " + this.__cls, "opts.keys[" + idx + "].name needs to be String.", {
        opts: this.opts
      });
      assert(isString(key.tag), "new " + this.__cls, "opts.keys[" + idx + "].tag needs to be String.", {
        opts: this.opts
      });
      input_opts = {
        "class": "cui-multi-input-input",
        textarea: this._textarea,
        spellcheck: this._spellcheck,
        onBlur: this._onBlur,
        onClick: this._onClick,
        onFocus: this._onFocus,
        onKeyup: this._onKeyup,
        name: key.name,
        undo_support: false,
        content_size: this._content_size,
        placeholder: (ref1 = this._placeholder) != null ? ref1[key.name] : void 0
      };
      input = new MultiInputInput(input_opts);
      input.render();
      fn(input, key);
      this.__inputs.push(input);
    }
  };

  MultiInput.prototype.render = function() {
    MultiInput.__super__.render.call(this);
    this.__initInputs();
    if (this.hasData()) {
      this.setDataOnInputs();
    }
    this.replace(this.__multiInputDiv);
    this.setInputVisibility();
    return this;
  };

  return MultiInput;

})(DataFieldInput);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MultiInputInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInputInput = (function(superClass) {
  extend(MultiInputInput, superClass);

  function MultiInputInput() {
    return MultiInputInput.__super__.constructor.apply(this, arguments);
  }

  MultiInputInput.prototype.getTemplate = function() {
    return new Template({
      name: "data-field-multi-input",
      map: {
        center: true,
        right: true
      }
    });
  };

  MultiInputInput.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  return MultiInputInput;

})(Input);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Checkbox,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Checkbox = (function(superClass) {
  extend(Checkbox, superClass);

  Checkbox.prototype.initOpts = function() {
    Checkbox.__super__.initOpts.call(this);
    return this.addOpts({
      onClick: {
        check: Function
      },
      value: {
        "default": true
      },
      value_unchecked: {
        "default": false
      },
      text: {
        check: String
      },
      multiline: {
        "default": false,
        check: Boolean
      },
      content: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      active: {
        "default": false,
        check: Boolean
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      radio: {
        check: String
      },
      group: {
        check: String
      },
      radio_allow_null: {
        check: Boolean
      },
      tooltip: {
        check: "PlainObject"
      },
      icon_active: {
        "default": "check",
        mandatory: true,
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_inactive: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      }
    });
  };

  function Checkbox(opts) {
    this.opts = opts != null ? opts : {};
    Checkbox.__super__.constructor.call(this, this.opts);
    if (this._multiline) {
      this.addClass("cui-checkbox--multiline");
    }
  }

  Checkbox.prototype.enable = function() {
    var ref;
    Checkbox.__super__.enable.call(this);
    return (ref = this.__checkbox) != null ? ref.enable() : void 0;
  };

  Checkbox.prototype.disable = function() {
    var ref;
    Checkbox.__super__.disable.call(this);
    return (ref = this.__checkbox) != null ? ref.disable() : void 0;
  };

  Checkbox.prototype.registerLabel = function(lbl) {
    lbl.setAttribute('data-label-clickable', '1');
    Events.listen({
      type: 'click',
      node: lbl,
      call: (function(_this) {
        return function(ev) {
          return _this.getButton().onClickAction(ev);
        };
      })(this)
    });
    return this;
  };

  Checkbox.prototype.getButton = function() {
    return this.__checkbox;
  };

  Checkbox.prototype.getOptValue = function() {
    return this._value;
  };

  Checkbox.prototype.getOptValueUnchecked = function() {
    return this._value_unchecked;
  };

  Checkbox.prototype.getCheckboxClass = function() {
    return "cui-button-checkbox";
  };

  Checkbox.prototype.destroy = function() {
    var ref;
    if ((ref = this.__checkbox) != null) {
      ref.destroy();
    }
    return Checkbox.__super__.destroy.call(this);
  };

  Checkbox.prototype.render = function() {
    var btn_opts, i, k, len, ref;
    Checkbox.__super__.render.call(this);
    btn_opts = this.getButtonOpts();
    btn_opts.onActivate = (function(_this) {
      return function(btn, flags, event) {
        var ret;
        if (flags.initial_activate) {
          return;
        }
        _this.storeValue(_this._value, flags);
        ret = typeof _this._onActivate === "function" ? _this._onActivate(_this, flags, event) : void 0;
        if (isPromise(ret)) {
          ret.fail(function() {
            return _this.storeValue(_this._value_unchecked, flags);
          });
        }
        return ret;
      };
    })(this);
    btn_opts.onDeactivate = (function(_this) {
      return function(btn, flags, event) {
        var ret;
        if (flags.initial_activate) {
          return;
        }
        _this.storeValue(_this._value_unchecked, flags);
        ret = typeof _this._onDeactivate === "function" ? _this._onDeactivate(_this, flags, event) : void 0;
        if (isPromise(ret)) {
          ret.fail(function() {
            return _this.storeValue(_this._value, flags);
          });
        }
        return ret;
      };
    })(this);
    if (this._onClick) {
      btn_opts.onClick = (function(_this) {
        return function(ev) {
          _this._onClick(ev, _this);
        };
      })(this);
    }
    ref = ["text", "radio_allow_null", "active"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (!isUndef(btn_opts[k])) {
        continue;
      }
      btn_opts[k] = this["_" + k];
    }
    if (isEmpty(btn_opts.text)) {
      btn_opts.text = "";
    }
    btn_opts.disabled = this.isDisabled();
    btn_opts.center = this._content;
    this.__checkbox = new CUI.defaults["class"].Button(btn_opts);
    this.__checkbox.addClass(this.getCheckboxClass());
    if (this._icon_active !== "check" || this._icon_inactive) {
      this.addClass("cui-checkbox--icon");
    }
    if (CUI.__ng__) {
      this.__checkbox.removeClass("cui-button-button");
    }
    this.proxy(this.__checkbox, ["activate", "deactivate", "isActive", "getGroup", "setGroup", "setTextMaxChars", "setText", "getText", "getElementForLayer"]);
    return this.replace(this.__checkbox);
  };

  Checkbox.prototype.checkValue = function(v, flags) {
    if (!isBoolean(v)) {
      throw new Error(this.__cls + ".setValue(value): Value needs to be Boolean.");
    }
  };

  Checkbox.prototype.displayValue = function() {
    Checkbox.__super__.displayValue.call(this);
    if (!this.hasData()) {
      return;
    }
    if (this.getOptValue() === this.getValue()) {
      this.__checkbox.activate({
        initial_activate: true
      });
    } else {
      this.__checkbox.deactivate({
        initial_activate: true
      });
    }
    return this;
  };

  Checkbox.prototype.getButtonOpts = function() {
    if (this._radio) {
      return {
        role: "radio",
        radio: this._radio,
        group: this._group,
        icon_active: this._icon_active,
        icon_inactive: this._icon_inactive
      };
    } else {
      return {
        role: "checkbox",
        "switch": true,
        group: this._group,
        icon_active: this._icon_active,
        icon_inactive: this._icon_inactive
      };
    }
  };

  Checkbox.prototype.getDefaultValue = function() {
    if (this._active) {
      return this._value;
    } else {
      return this._value_unchecked;
    }
  };

  Checkbox.prototype.isChanged = function() {
    if (!this.hasData()) {
      return void 0;
    }
    if (!this._radio) {
      return Checkbox.__super__.isChanged.call(this);
    }
    if (this.getValue() === this.getOptValue()) {
      return Checkbox.__super__.isChanged.call(this);
    }
    return this.__checkChangedValue === JSON.stringify(this.getOptValue());
  };

  return Checkbox;

})(DataFieldInput);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Options,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Options = (function(superClass) {
  extend(Options, superClass);

  function Options(opts) {
    this.opts = opts != null ? opts : {};
    Options.__super__.constructor.call(this, this.opts);
    if (this._sortable) {
      this.DOM.addClass("cui-options--sortable");
    }
  }

  Options.prototype.initOpts = function() {
    Options.__super__.initOpts.call(this);
    return this.addOpts({
      radio: {
        check: function(v) {
          return isString(v) || isBoolean(v);
        }
      },
      radio_unchecked_value: {
        "default": false
      },
      min_checked: {
        check: function(v) {
          if (this._radio) {
            return v === 0 || v === 1;
          } else {
            return isInteger(v) && v >= 0;
          }
        }
      },
      options: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      horizontal: {
        check: function(v) {
          if (isBoolean(v) || (isInteger(v) && v > 0)) {
            return true;
          }
        }
      },
      title: {
        check: String
      },
      activatable: {
        check: Boolean
      },
      sortable: {
        check: Boolean
      },
      sortable_hint: {
        check: String
      },
      placeholder: {
        "default": "No options available.",
        check: String
      },
      columns: {
        check: function(v) {
          if (isInteger(v) && v <= 12) {
            return true;
          }
        },
        "default": 1
      }
    });
  };

  Options.prototype.readOpts = function() {
    Options.__super__.readOpts.call(this);
    assert(!this._sortable || !this._left, "new Options", "opts.sortable and opts.left cannot be used together.", {
      opts: this.opts
    });
    assert(!this._sortable || !this._radio, "new Options", "opts.sortable and opts.radio cannot be used together.", {
      opts: this.opts
    });
    assert(!this._sortable || !this.opts.horizontal, "new Options", "opts.sortable and opts.horizontal cannot be used together.", {
      opts: this.opts
    });
    if (CUI.__ng__) {
      if (this.opts.horizontal === void 0) {
        this._horizontal = !this._sortable;
      }
    }
    if (this._sortable && this._activatable === void 0) {
      this._activatable = true;
    }
    return assert(!(this._sortable && !this._activatable), "new Options", "opts.sortable needs opts.activatable to be set.", {
      opts: this.opts
    });
  };

  Options.prototype.getTemplate = function() {
    if (!CUI.__ng__) {
      return Options.__super__.getTemplate.call(this);
    }
    if (this._activatable) {
      return this.__tmpl = new Template({
        name: "options-activatable",
        map_prefix: "cui-options",
        map: {
          top: true,
          bottom: true,
          active: true,
          inactive: true
        }
      });
    } else {
      return this.__tmpl = new Template({
        name: "options",
        map: {
          top: true,
          bottom: true,
          center: true
        }
      });
    }
  };

  Options.prototype.init = function() {
    switch (this._radio) {
      case false:
        this.__radio = void 0;
        break;
      case true:
        this.__radio = "options--" + this.getUniqueId();
        break;
      default:
        this.__radio = this._radio;
    }
    return this.__options_data = {};
  };

  Options.prototype.setData = function(data) {
    Options.__super__.setData.call(this, data);
    if (this._radio) {
      if (CUI.isArray(this.getValue())) {
        this.__radio_use_array = true;
      } else {
        this.__radio_use_array = false;
      }
    }
    this.__setDataOnOptions();
    return this;
  };

  Options.prototype.__setDataOnOptions = function(init_data) {
    var cb, i, j, l, len, len1, len2, opt, opt_unchecked, ref, ref1, ref2;
    if (init_data == null) {
      init_data = true;
    }
    if (!this.__checkboxes) {
      return;
    }
    if (init_data) {
      ref = this.__checkboxes;
      for (i = 0, len = ref.length; i < len; i++) {
        cb = ref[i];
        cb.callOnOthers("setData", this.__data);
      }
    }
    if (this._radio && !this.__radio_use_array) {
      ref1 = this.__checkboxes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        cb = ref1[j];
        this.__options_data[cb.getName()] = this.getValue();
        if (!init_data) {
          continue;
        }
        if (this._check_changed && JSON.parse(this.getCheckChangedValue()) === cb.getOptValue()) {
          cb.setCheckChangedValue(cb.getOptValue());
        } else {
          cb.setCheckChangedValue(cb.getOptValueUnchecked());
        }
      }
    } else {
      ref2 = this.__checkboxes;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        cb = ref2[l];
        opt = cb.getOptValue();
        opt_unchecked = cb.getOptValueUnchecked();
        if (this.getValue().indexOf(opt) > -1) {
          this.__options_data[cb.getName()] = opt;
        } else {
          this.__options_data[cb.getName()] = opt_unchecked;
        }
        if (!init_data) {
          continue;
        }
        if (this._check_changed && JSON.parse(this.getCheckChangedValue()).indexOf(opt) > -1) {
          cb.setCheckChangedValue(opt);
        } else {
          cb.setCheckChangedValue(opt_unchecked);
        }
      }
    }
    return this;
  };

  Options.prototype.disableOption = function(value) {
    var cb;
    cb = this.__getCheckboxByValue(value);
    cb.disable();
    return this;
  };

  Options.prototype.enableOption = function(value) {
    var cb;
    cb = this.__getCheckboxByValue(value);
    cb.enable();
    return this;
  };

  Options.prototype.__getCheckboxByValue = function(value) {
    var found, i, idx, len, opt, ref;
    found = null;
    ref = this.__options;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      opt = ref[idx];
      if (opt.value === value) {
        found = idx;
        break;
      }
    }
    assert(found !== null, "CUI.Options.__getCheckboxByValue", "Value " + value + " not found in Options.", {
      options: this.__options
    });
    return this.__checkboxes[found];
  };

  Options.prototype.getOptions = function() {
    return this.__options;
  };

  Options.prototype.setValue = function(v, flags) {
    if (flags == null) {
      flags = {};
    }
    flags.__set_on_data = true;
    return Options.__super__.setValue.call(this, v, flags);
  };

  Options.prototype.storeValue = function(value, flags) {
    if (flags == null) {
      flags = {};
    }
    Options.__super__.storeValue.call(this, value, flags);
    if (flags.__set_on_data) {
      this.__setDataOnOptions();
    }
    return this;
  };

  Options.prototype.displayValue = function() {
    var cb, i, len, ref;
    Options.__super__.displayValue.call(this);
    ref = this.__checkboxes;
    for (i = 0, len = ref.length; i < len; i++) {
      cb = ref[i];
      cb.displayValue();
    }
    return this;
  };

  Options.prototype.checkValue = function(_value) {
    var check, i, j, len, len1, opt, ref, value;
    if (this.__radio_use_array || !this._radio) {
      if (!CUI.isArray(_value)) {
        throw new CheckValueError("Value must be Array.");
      }
      check = _value;
    } else {
      check = [_value];
    }
    for (i = 0, len = check.length; i < len; i++) {
      value = check[i];
      ref = this.__options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        opt = ref[j];
        if (opt.value === value) {
          CUI.debug("value is ok.", this.hasData(), this.getData()[this._name]);
          return;
        }
      }
    }
    throw new CheckValueError("Value is not in the options.");
  };

  Options.prototype.disable = function() {
    if (!CUI.__ng__) {
      return;
    }
    return Options.__super__.disable.call(this);
  };

  Options.prototype.enable = function() {
    if (!CUI.__ng__) {
      return;
    }
    return Options.__super__.enable.call(this);
  };

  Options.prototype.render = function() {
    var _opt, bottom, cb, drag_handle, drag_handle_inner, el, find_value_in_options, fn, i, idx, j, len, len1, order_options_by_value_array, order_value_array, ref, ref1, sort_options, sortable_element, sortable_selector, top, unsorted_options;
    Options.__super__.render.call(this);
    unsorted_options = this.getArrayFromOpt("options");
    sort_options = (function(_this) {
      return function() {
        return _this.__options.sort(function(a, b) {
          var a_idx, b_idx;
          a_idx = idxInArray(idxInArray(a, unsorted_options), _this.__options_order);
          b_idx = idxInArray(idxInArray(b, unsorted_options), _this.__options_order);
          return compareIndex(a_idx, b_idx);
        });
      };
    })(this);
    find_value_in_options = function(value, options) {
      var i, idx, len, opt;
      for (idx = i = 0, len = options.length; i < len; idx = ++i) {
        opt = options[idx];
        if (opt.value === value || (!opt.hasOwnProperty("value") && opt.text === value)) {
          return idx;
        }
      }
      return -1;
    };
    order_value_array = (function(_this) {
      return function(arr) {
        var a, i, idx, j, len, len1, results;
        for (idx = i = 0, len = arr.length; i < len; idx = ++i) {
          a = arr[idx];
          a.___idx = idx;
        }
        arr.sort(function(a, b) {
          var a_idx, b_idx;
          a_idx = find_value_in_options(a, _this.__options);
          if (a_idx === -1) {
            a_idx = arr.length + a.__idx;
          }
          b_idx = find_value_in_options(b, _this.__options);
          if (b_idx === -1) {
            b_idx = arr.length + b.__idx;
          }
          return compareIndex(a_idx, b_idx);
        });
        results = [];
        for (idx = j = 0, len1 = arr.length; j < len1; idx = ++j) {
          a = arr[idx];
          results.push(delete a.___idx);
        }
        return results;
      };
    })(this);
    order_options_by_value_array = (function(_this) {
      return function() {
        var arr, i, idx, j, l, len, len1, len2, missing_opts, mopt, opt, results, value;
        if (_this.hasData()) {
          arr = _this.getValue();
        } else {
          arr = [];
        }
        _this.__options_order = [];
        for (i = 0, len = arr.length; i < len; i++) {
          value = arr[i];
          _this.__options_order.push(find_value_in_options(value, unsorted_options));
        }
        missing_opts = [];
        for (idx = j = 0, len1 = unsorted_options.length; j < len1; idx = ++j) {
          opt = unsorted_options[idx];
          if (idxInArray(idx, _this.__options_order) === -1) {
            missing_opts.push({
              opt: opt,
              idx: idx
            });
          }
        }
        missing_opts.sort(function(a, b) {
          var a_txt, b_txt;
          a_txt = a.opt.text.toLocaleUpperCase();
          b_txt = b.opt.text.toLocaleUpperCase();
          if (a_txt < b_txt) {
            return -1;
          } else if (a_txt > b_txt) {
            return 1;
          } else {
            return 0;
          }
        });
        results = [];
        for (l = 0, len2 = missing_opts.length; l < len2; l++) {
          mopt = missing_opts[l];
          results.push(_this.__options_order.push(mopt.idx));
        }
        return results;
      };
    })(this);
    if (this._sortable && !this.__options_order) {
      order_options_by_value_array();
    }
    this.__options = unsorted_options.slice(0);
    if (this.__options_order) {
      sort_options();
    }
    this.__checkboxes = [];
    this.__maxChars = -1;
    ref = this.__options;
    fn = (function(_this) {
      return function(_opt) {
        var cb, chars, k, opt, ref1, ref2, v;
        opt = {};
        for (k in _opt) {
          v = _opt[k];
          opt[k] = v;
        }
        assert(!isEmpty(opt.text) || !isEmpty(opt.content), "new " + _this.__cls, "opts.options[" + idx + "].text|content must be set.", {
          opts: _this.opts
        });
        if (!opt.hasOwnProperty("value")) {
          assert(!isEmpty(opt.text), "new " + _this.__cls, "opts.options[" + idx + "].text must be set.", {
            opts: _this.opts
          });
          opt.value = opt.text;
        }
        chars = ((ref1 = opt.text) != null ? ref1.length : void 0) || -1;
        if (_this.__maxChars < chars) {
          _this.__maxChars = chars;
        }
        if (CUI.__ng__ && ((ref2 = opt.form) != null ? ref2.right : void 0)) {
          console.error("Options.render: form.right is obsolete. 'right' part will not appear.", _this, opt);
        }
        opt.radio = _this.__radio;
        if (_this._radio && _this._min_checked === 0) {
          if (_this.__options.length === 1) {
            delete opt.radio;
          } else {
            opt.radio_allow_null = true;
          }
        }
        opt.onActivate = function(_cb, flags) {
          var arr;
          if (_cb.hasData()) {
            if (_this._radio && !_this.__radio_use_array) {
              _this.storeValue(_cb.getValue(), flags);
            } else {
              addToArray(_cb.getOptValue(), arr = _this.getValue().slice(0));
              order_value_array(arr);
              _this.storeValue(arr, flags);
              if (_this._sortable) {
                order_options_by_value_array();
                _this.reload();
              }
            }
          }
          if (typeof _opt.onActivate === "function") {
            _opt.onActivate(_cb, flags);
          }
        };
        opt.onDeactivate = function(_cb, flags) {
          var arr, c, f, j, len1, ref3;
          if (!_this._radio) {
            c = 0;
            ref3 = _this.__checkboxes;
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              f = ref3[j];
              if (f.isActive()) {
                c++;
              }
            }
            if (c < _this._min_checked) {
              return _cb.activate();
            }
          }
          if (_cb.hasData()) {
            if (_this._radio && !_this.__radio_use_array) {
              if (!flags.prior_activate) {
                _this.storeValue(_cb.getValue(), flags);
              }
            } else {
              removeFromArray(_cb.getOptValue(), arr = _this.getValue().slice(0));
              _this.storeValue(arr, flags);
              if (_this._sortable) {
                order_options_by_value_array();
                _this.reload();
              }
            }
          }
          if (typeof _opt.onDeactivate === "function") {
            _opt.onDeactivate(_cb, flags);
          }
        };
        opt.undo_support = false;
        opt.mark_changed = _this._mark_changed;
        opt.multiline = true;
        if (_this.getName()) {
          if (_this.__radio && !_this.__radio_use_array) {
            opt.name = _this.__radio;
            opt.group = _this.__radio;
          } else {
            opt.group = "options-" + _this.getUniqueId();
            opt.name = opt.group + "--" + idx;
          }
          opt.data = _this.__options_data;
          opt.data_not_for_others = true;
        }
        cb = new Checkbox(opt);
        Events.listen({
          type: "data-changed",
          node: cb,
          call: function(ev, info) {
            if (info.element === cb) {
              ev.stopImmediatePropagation();
            }
          }
        });
        return _this.__checkboxes.push(cb);
      };
    })(this);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      _opt = ref[idx];
      fn(_opt);
    }
    if (this.hasData()) {
      this.__setDataOnOptions();
    }
    if (this.__checkboxes.length) {
      if (this._sortable && !isEmpty(this._sortable_hint)) {
        bottom = new Label({
          multiline: true,
          "class": "cui-options-order-hint",
          text: this._sortable_hint
        });
      } else {
        bottom = void 0;
      }
      if (!isEmpty(this._title)) {
        top = new Label({
          "class": "cui-options-title",
          text: this._title
        });
      } else {
        top = void 0;
      }
      if (CUI.__ng__) {
        this.replace(bottom, "bottom");
        this.replace(top, "top");
        if (this._horizontal) {
          this.addClass("cui-options--horizontal");
        } else {
          this.addClass("cui-options--vertical");
        }
        if (this._columns > 1) {
          this.addClass("cui-options--columns-" + this._columns);
        }
        if (this._activatable) {
          this.empty("active");
          this.empty("inactive");
        } else {
          this.empty("center");
        }
        ref1 = this.__checkboxes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          cb = ref1[j];
          cb.start();
          if (this.__maxChars > 0) {
            cb.setTextMaxChars(this.__maxChars);
          }
          if (this._sortable && cb.isActive()) {
            el = CUI.DOM.element("DIV", {
              "class": "cui-options-sortable-option"
            });
            drag_handle = CUI.DOM.element("DIV", {
              "class": "cui-options-sortable-drag-handle"
            });
            drag_handle_inner = CUI.DOM.element("DIV", {
              "class": "cui-drag-handle-row"
            });
            drag_handle.appendChild(drag_handle_inner);
            el.appendChild(drag_handle);
            el.appendChild(cb.DOM);
          } else {
            el = cb.DOM;
          }
          if (this._activatable) {
            if (cb.isActive()) {
              this.append(el, "active");
            } else {
              this.append(el, "inactive");
            }
          } else {
            this.append(el, "center");
          }
        }
        sortable_element = this.__tmpl.map.active;
        sortable_selector = ".cui-options-sortable-drag-handle";
      } else {
        this.__optionsForm = new Form({
          "class": "cui-options-form cui-form-options",
          horizontal: this._horizontal !== false ? this._horizontal : void 0,
          top: top,
          bottom: bottom,
          fields: this.__checkboxes
        });
        this.replace(this.__optionsForm);
        this.proxy(this.__optionsForm, ["disable", "enable"]);
        this.__optionsForm.render();
        sortable_element = this.__optionsForm.getTable();
        sortable_selector = void 0;
      }
      if (this._sortable) {
        new CUI.Sortable({
          axis: "y",
          element: sortable_element,
          selector: sortable_selector,
          sorted: (function(_this) {
            return function(ev, from_idx, to_idx) {
              var arr;
              moveInArray(from_idx, to_idx, _this.__options_order, from_idx < to_idx);
              sort_options();
              if (_this.hasData()) {
                arr = _this.getValue().slice(0);
                order_value_array(arr);
                _this.storeValue(arr);
              }
              order_options_by_value_array();
              return _this.reload();
            };
          })(this)
        });
      }
    } else if (!isEmpty(this._placeholder)) {
      this.replace(new EmptyLabel({
        text: this._placeholder
      }), "center");
    }
    return this;
  };

  Options.prototype.getDefaultValue = function() {
    if (this._radio && !this.__radio_use_array) {
      return this._radio_unchecked_value;
    } else {
      return [];
    }
  };

  return Options;

})(CUI.DataField);

Options = CUI.Options;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ObjectDumper = (function(superClass) {
  extend(ObjectDumper, superClass);

  function ObjectDumper(opts) {
    var headerRow;
    this.opts = opts != null ? opts : {};
    ObjectDumper.__super__.constructor.call(this, this.opts);
    if (this._headers) {
      headerRow = new CUI.ListViewTreeHeaderNode({
        headers: this._headers
      });
      this.root.children.splice(0, 0, headerRow);
    }
    this.render(false);
    this.root.open();
  }

  ObjectDumper.prototype.initOpts = function() {
    ObjectDumper.__super__.initOpts.call(this);
    this.addOpts({
      object: {
        mandatory: true,
        check: function(v) {
          if (CUI.isArray(v) || CUI.isPlainObject(v)) {
            return true;
          } else {
            return false;
          }
        }
      },
      headers: {
        "default": [
          {
            label: {
              text: "key"
            }
          }, {
            label: {
              text: "value"
            }
          }
        ],
        check: function(v) {
          return v.length === 2;
        }
      },
      do_open: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      parse_json: {
        mandatory: true,
        "default": false,
        check: Boolean
      }
    });
    this.removeOpt("root");
    this.removeOpt("cols");
    this.removeOpt("colResize");
    return this.removeOpt("fixedRows");
  };

  ObjectDumper.prototype.readOpts = function() {
    ObjectDumper.__super__.readOpts.call(this);
    this._cols = ["auto", "auto"];
    this._colClasses = ["cui-object-dumper-key", "cui-object-dumper-value"];
    if (this._headers) {
      this._colResize = true;
      return this._fixedRows = 1;
    }
  };

  ObjectDumper.prototype.initListView = function() {
    ObjectDumper.__super__.initListView.call(this);
    return this.root = new CUI.ObjectDumperNode({
      data: this._object,
      do_open: this._do_open,
      parse_json: this._parse_json
    });
  };

  return ObjectDumper;

})(CUI.ListViewTree);
// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ObjectDumperNode = (function(superClass) {
  extend(ObjectDumperNode, superClass);

  function ObjectDumperNode() {
    return ObjectDumperNode.__super__.constructor.apply(this, arguments);
  }

  ObjectDumperNode.prototype.initOpts = function() {
    ObjectDumperNode.__super__.initOpts.call(this);
    this.addOpts({
      key: {
        "default": "root",
        mandatory: true
      },
      data: {},
      do_open: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      parse_json: {
        mandatory: true,
        "default": false,
        check: Boolean
      }
    });
    this.removeOpt("colspan");
    this.removeOpt("children");
    return this.removeOpt("getChildren");
  };

  ObjectDumperNode.prototype.readOpts = function() {
    ObjectDumperNode.__super__.readOpts.call(this);
    this.setData(this._data);
    this.__info = this.getInfoFromData(this.getData());
    if (this._key === "root") {
      this.children = this.getNodesFromData(this.getData());
    }
    if (!this.isLeaf() && this._do_open) {
      return this.do_open = true;
    }
  };

  ObjectDumperNode.prototype.setData = function(data) {
    var e, error;
    if (this._parse_json && isString(data)) {
      try {
        this.__data = JSON.parse(data);
      } catch (error) {
        e = error;
        this.__data = data;
      }
    } else {
      this.__data = data;
    }
    return this;
  };

  ObjectDumperNode.prototype.getData = function() {
    return this.__data;
  };

  ObjectDumperNode.prototype.getChildren = function() {
    return this.getNodesFromData(this.getData());
  };

  ObjectDumperNode.prototype.isLeaf = function() {
    return !this.__info.has_children;
  };

  ObjectDumperNode.prototype.renderContent = function() {
    if (this.isLeaf() || !this.isOpen()) {
      this.addColumn(new ListViewColumn({
        "class": "cui-object-dumper-node-value",
        element: new Label({
          text: this.__info.text,
          multiline: true
        })
      }));
    }
    return new Label({
      "class": "cui-object-dumper-node-key",
      text: this._key,
      multiline: true
    });
  };

  ObjectDumperNode.prototype.getClass = function() {
    var cls;
    cls = ObjectDumperNode.__super__.getClass.call(this);
    return cls + " cui-object-dumper-node-" + this.__info.cls.toLowerCase();
  };

  ObjectDumperNode.prototype.getInfoFromData = function(data) {
    var info;
    info = {};
    if (data === void 0) {
      info.cls = "undefined";
      info.text = "undefined";
    } else if (data === null) {
      info.cls = "null";
      info.text = "null";
    } else if (data === true) {
      info.cls = "boolean";
      info.text = "true";
    } else if (data === false) {
      info.cls = "boolean";
      info.text = "false";
    } else if (typeof data === "number" && isNaN(data)) {
      info.cls = "NaN";
      info.text = "NaN";
    } else if (isNumber(data)) {
      info.cls = "number";
      info.text = "" + data;
    } else if (isString(data)) {
      info.cls = "String";
      info.text = '"' + data + '"';
    } else {
      info.cls = getObjectClass(data);
      if (CUI.isArray(data) || CUI.isPlainObject(data)) {
        info.has_children = !CUI.isEmptyObject(data);
        if (CUI.isArray(data)) {
          info.text = info.cls + " [" + data.length + "]";
        }
        if (CUI.isPlainObject(data)) {
          info.text = info.cls + " {" + Object.keys(data).length + "}";
        }
      } else {
        info.has_children = true;
        info.text = info.cls;
      }
    }
    return info;
  };

  ObjectDumperNode.prototype.getNodesFromData = function(data) {
    var i, idx, info, k, nodes, ref, v;
    nodes = [];
    info = this.getInfoFromData(data);
    if (info.cls === "Array") {
      for (idx = i = 0, ref = data.length; 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
        nodes.push(new CUI.ObjectDumperNode({
          key: idx,
          data: data[idx],
          do_open: this._do_open,
          parse_json: this._parse_json
        }));
      }
    } else {
      for (k in data) {
        v = data[k];
        nodes.push(new CUI.ObjectDumperNode({
          key: k,
          data: v,
          do_open: this._do_open,
          parse_json: this._parse_json
        }));
      }
    }
    return nodes;
  };

  return ObjectDumperNode;

})(CUI.ListViewTreeNode);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Output,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Output = (function(superClass) {
  extend(Output, superClass);

  function Output() {
    return Output.__super__.constructor.apply(this, arguments);
  }

  Output.prototype.initOpts = function() {
    Output.__super__.initOpts.call(this);
    return this.addOpts({
      placeholder: {
        "default": "",
        check: String
      },
      text: {
        check: String
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      getValue: {
        check: Function
      },
      multiline: {
        check: Boolean,
        "default": true,
        mandatory: true
      },
      allow_delete: {
        mandatory: true,
        "default": false,
        check: Boolean
      }
    });
  };

  Output.prototype.readOpts = function() {
    var i, k, len, ref;
    Output.__super__.readOpts.call(this);
    ref = ["undo_support", "check_changed", "mark_changed"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this.removeOpt(k);
      this["_" + k] = false;
    }
    return this;
  };

  Output.prototype.init = function() {
    this.__textSpan = new Label({
      markdown: this._markdown,
      multiline: this._multiline,
      "class": "cui-data-field-output-label"
    });
    this.setText(this._text);
    return this.__textSpan;
  };

  Output.prototype.setText = function(txt, markdown) {
    if (markdown == null) {
      markdown = null;
    }
    if (isEmpty(txt)) {
      this.__textSpan.addClass("cui-output-empty");
      txt = this._placeholder;
    } else {
      this.__textSpan.removeClass("cui-output-empty");
    }
    if (markdown === null) {
      return this.__textSpan.setText(txt, this._markdown);
    } else {
      return this.__textSpan.setText(txt, markdown);
    }
  };

  Output.prototype.checkValue = function() {};

  Output.prototype.displayValue = function() {
    var ref, ref1, ret;
    Output.__super__.displayValue.call(this);
    if (this.getName()) {
      ret = this.getValue();
      if (!isEmpty(ret)) {
        if ((ref = this.__deleteBtn) != null) {
          ref.show();
        }
      } else {
        if ((ref1 = this.__deleteBtn) != null) {
          ref1.hide();
        }
      }
      if (isContent(ret)) {
        this.replace(ret);
      } else {
        this.setText(ret, false);
      }
    }
    return this;
  };

  Output.prototype.getValue = function() {
    var value;
    value = Output.__super__.getValue.call(this);
    if (this._getValue) {
      return this._getValue.call(this, value, this.getData());
    } else {
      return value;
    }
  };

  Output.prototype.render = function() {
    Output.__super__.render.call(this);
    this.replace(this.__textSpan);
    if (this._allow_delete && this.hasData()) {
      this.addClass("cui-output--deletable");
      this.__deleteBtn = new Button({
        icon: "remove",
        appearance: "flat",
        onClick: (function(_this) {
          return function() {
            return _this.setValue(null, {
              no_trigger: false
            });
          };
        })(this)
      });
      this.append(this.__deleteBtn);
    }
    return this;
  };

  return Output;

})(DataFieldInput);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var OutputContent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

OutputContent = (function(superClass) {
  extend(OutputContent, superClass);

  function OutputContent() {
    return OutputContent.__super__.constructor.apply(this, arguments);
  }

  OutputContent.prototype.initOpts = function() {
    OutputContent.__super__.initOpts.call(this);
    return this.addOpts({
      placeholder: {
        "default": "",
        check: String
      },
      content: {
        check: function(v) {
          return isElement(v) || isElement(v.DOM);
        }
      },
      getValue: {
        check: Function
      }
    });
  };

  OutputContent.prototype.setContent = function(content) {
    if (content == null) {
      content = null;
    }
    CUI.debug("setContent", this.DOM, content);
    if (!content) {
      this.DOM.addClass("cui-output-empty");
      return this.empty();
    } else {
      this.DOM.removeClass("cui-output-empty");
      return this.replace(content);
    }
  };

  OutputContent.prototype.displayValue = function() {
    OutputContent.__super__.displayValue.call(this);
    if (this.getName()) {
      this.setContent(this.getValue());
    }
    return this;
  };

  OutputContent.prototype.getValue = function() {
    var value;
    value = OutputContent.__super__.getValue.call(this);
    if (this._getValue) {
      return this._getValue.call(this, value);
    } else {
      return value;
    }
  };

  OutputContent.prototype.render = function() {
    OutputContent.__super__.render.call(this);
    return this.setContent(this._content);
  };

  return OutputContent;

})(DataFieldInput);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var MultiOutput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiOutput = (function(superClass) {
  extend(MultiOutput, superClass);

  function MultiOutput() {
    return MultiOutput.__super__.constructor.apply(this, arguments);
  }

  MultiOutput.prototype.initOpts = function() {
    MultiOutput.__super__.initOpts.call(this);
    return this.addOpts({
      control: {
        mandatory: true,
        check: MultiInputControl
      }
    });
  };

  MultiOutput.prototype.displayValue = function() {
    var key;
    MultiOutput.__super__.displayValue.call(this);
    key = this._control.getPreferredKey();
    assert(key, "Output.displayValue", "MultiInputControl: no preferred key set.", {
      control: this._control
    });
    this.setText(this.getValue()[key.name]);
    return this;
  };

  return MultiOutput;

})(Output);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FormButton,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FormButton = (function(superClass) {
  extend(FormButton, superClass);

  function FormButton(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FormButton.__super__.constructor.call(this, this.opts);
  }

  FormButton.prototype.getButtonOpts = function() {
    var i, k, len, opts, ref;
    opts = {
      icon: this._icon
    };
    ref = ["appearance"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      opts[k] = this["_" + k];
    }
    return opts;
  };

  FormButton.prototype.render = function() {
    FormButton.__super__.render.call(this);
    if (CUI.__ng__) {
      this.__checkbox.addClass("cui-button-button");
    }
  };

  FormButton.prototype.getCheckboxClass = function() {
    return "cui-button-form-button";
  };

  FormButton.prototype.initOpts = function() {
    FormButton.__super__.initOpts.call(this);
    return this.addOpts({
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      appearance: {
        check: ["link", "flat", "normal", "important"]
      }
    });
  };

  return FormButton;

})(Checkbox);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Form,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Form = (function(superClass) {
  extend(Form, superClass);

  function Form() {
    return Form.__super__.constructor.apply(this, arguments);
  }

  Form.prototype.initOpts = function() {
    Form.__super__.initOpts.call(this);
    return this.addOpts({
      fields: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v) || CUI.isArray(v);
        }
      },
      class_table: {
        check: String
      },
      header: {
        check: Array
      },
      horizontal: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || (isInteger(v) && v > 0);
        }
      },
      appearance: {
        "default": "normal",
        mandatory: true,
        check: ["normal", "separators"]
      },
      maximize: {
        "default": false,
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean
      },
      maximize_vertical: {
        check: Boolean
      },
      render_as_block: {
        check: Boolean
      },
      render_as_grid: {
        "default": false,
        mandatory: true,
        check: Boolean
      },
      top: {},
      bottom: {}
    });
  };

  Form.prototype.readOpts = function() {
    var cb_opts, i, k, len1, ref, ref1, vl_opts;
    Form.__super__.readOpts.call(this);
    if (this._horizontal === 1) {
      this.__horizontal = null;
    } else {
      this.__horizontal = this._horizontal;
    }
    if (CUI.__ng__) {
      if (this.__horizontal && this.__horizontal !== true) {
        console.error("new Form: opts.horizontal not supported in CUI.Form 'ng'.", {
          opts: this.opts
        });
      }
      if (this._header) {
        console.error("new Form: opts.header not supported in CUI.Form 'ng'.", {
          opts: this.opts
        });
      }
    }
    vl_opts = {
      "class": "cui-form cui-form-appearance-" + this._appearance
    };
    ref = ["maximize", "maximize_horizontal", "maximize_vertical"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (this.hasSetOpt(k)) {
        vl_opts[k] = this.getSetOpt(k);
      }
    }
    if (this.hasSetOpt("top")) {
      vl_opts.top = {
        content: this._top
      };
    }
    if (this.hasSetOpt("bottom")) {
      vl_opts.bottom = {
        content: this._bottom
      };
    }
    if ((ref1 = this._form) != null ? ref1.checkbox : void 0) {
      assert(CUI.isPlainObject(this._form.checkbox, "new Form", "opts.form.checkbox needs to be PlainObject.", {
        opts: this.opts
      }));
      assert(this._name, "new Form", "opts.form.checkbox requires opts.name to be set.", {
        opts: this.opts
      });
      assert(!this._form.checkbox.data, "new Form", "opts.form.checkbox cannot have 'data' set.", {
        opts: this.opts
      });
      assert(!this._form.checkbox.name, "new Form", "opts.form.checkbox cannot have 'name' set.", {
        opts: this.opts
      });
      cb_opts = copyObject(this._form.checkbox, true);
      cb_opts.data = this.__checkbox_data = {
        checkbox: false
      };
      cb_opts.name = "checkbox";
      this.__checkbox = new Checkbox(cb_opts).start();
      Events.listen({
        type: "data-changed",
        node: this.__checkbox,
        call: (function(_this) {
          return function() {
            if (_this.__checkbox_data.checkbox) {
              return _this.__checkbox_set_data[_this._name] = _this.__checkbox_form_data;
            } else {
              return delete _this.__checkbox_set_data[_this._name];
            }
          };
        })(this)
      });
    } else {
      this.checkbox = null;
    }
    this.__verticalLayout = new VerticalLayout(vl_opts);
    if (this._render_as_grid) {
      this.__verticalLayout.addClass("cui-form--grid");
    }
    return this.__verticalLayout;
  };

  Form.prototype.getCheckbox = function() {
    return this.__checkbox;
  };

  Form.prototype.initTemplate = function() {
    return this.registerTemplate(this.__verticalLayout.getLayout());
  };

  Form.prototype.getLayout = function() {
    return this.__verticalLayout;
  };

  Form.prototype.__createFields = function() {
    var _field, field, fields, fs, i, idx, len1;
    fs = [];
    fields = this.getArrayFromOpt("fields");
    for (idx = i = 0, len1 = fields.length; i < len1; idx = ++i) {
      field = fields[idx];
      if (!field) {
        continue;
      }
      if (CUI.isFunction(field)) {
        _field = DataField["new"](field(this));
      } else {
        _field = DataField["new"](field);
      }
      _field.setForm(this);
      fs.push(_field);
    }
    return fs;
  };

  Form.prototype.getNameOpt = function() {
    return {
      name: {
        check: String
      }
    };
  };

  Form.prototype.init = function() {
    this.__initUndo();
    this.initFields();
    return this.setFormDepth();
  };

  Form.prototype.initFields = function() {
    this.__fields = this.__createFields();
    return this.__fields;
  };

  Form.prototype.reload = function() {
    this.initFields();
    this.callOnOthers("setData", this.__data);
    return Form.__super__.reload.call(this);
  };

  Form.prototype.displayValue = function() {
    if (this.__checkbox) {
      this.__checkbox.displayValue();
    }
    return Form.__super__.displayValue.call(this);
  };

  Form.prototype.getParentData = function() {
    return this.__parent_data || this.__data;
  };

  Form.prototype.setData = function(data) {
    if (this._name && this.__checkbox) {
      assert(!CUI.isFunction(data), "Form.setData", "opts.data cannot be set by Function when data is managed by opts.form.checkbox.", {
        opts: this.opts
      });
    }
    if (this._name && !CUI.isFunction(data)) {
      if (this.__checkbox) {
        this.__checkbox_set_data = data;
        if (data[this._name]) {
          this.__checkbox_form_data = data[this._name];
          this.__checkbox_data.checkbox = true;
        } else {
          this.__checkbox_form_data = {};
          this.__checkbox_data.checkbox = false;
        }
        Form.__super__.setData.call(this, this.__checkbox_form_data);
      } else {
        if (isUndef(data[this._name])) {
          data[this._name] = {};
        }
        this.__parent_data = data;
        Form.__super__.setData.call(this, data[this._name]);
      }
    } else {
      Form.__super__.setData.call(this, data);
    }
    if (CUI.isFunction(this._fields) && this.__fields && this.__fields.length === 0) {
      this.initFields();
      this.callOnOthers("setData", this.__data);
    }
    return this;
  };

  Form.prototype.__setRowVisibility = function(tr) {
    var _f, df, i, len1, ref;
    df = DOM.data(tr, "data-field");
    if (!df) {
      console.warn("Form.__setRowVisibility", "data-field not found", df, this);
      return;
    }
    ref = df.getAllDataFields();
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _f = ref[i];
      if (!_f.isHidden()) {
        CUI.DOM.showElement(tr);
        return;
      }
    }
    CUI.DOM.hideElement(tr);
  };

  Form.prototype.render = function() {
    var ref;
    Form.__super__.render.call(this);
    this.renderTable();
    if (!this.hasContentForAppend() || ((ref = this.__checkbox) != null ? ref.getValue() : void 0) === false) {
      CUI.DOM.hideElement(this.DOM);
    } else {
      CUI.DOM.showElement(this.DOM);
    }
    return this;
  };

  Form.prototype.getTable = function() {
    assert(!CUI.__ng__, "Form.getTable is obsolete in \"ng\" design.", {
      form: this
    });
    return this.table;
  };

  Form.prototype.renderAsBlock = function() {
    var f, fields, i, len1, ref;
    if (this.getCheckbox()) {
      return true;
    }
    if (this._render_as_block === false) {
      return false;
    }
    if (this._render_as_block === true) {
      return true;
    }
    fields = this.getFields();
    for (i = 0, len1 = fields.length; i < len1; i++) {
      f = fields[i];
      if ((ref = f._form) != null ? ref.label : void 0) {
        return true;
      }
      if (f instanceof Form) {
        if (f.renderAsBlock()) {
          return true;
        }
      }
    }
    return false;
  };

  Form.prototype.hasContentForAppend = function() {
    var ref;
    if (((ref = this.__fields) != null ? ref.length : void 0) > 0) {
      return true;
    } else {
      return false;
    }
  };

  Form.prototype.renderTable = function() {
    var append, container, field_has_left, field_idx, fields, form_depth, get_append, get_label, layout, len, render_next_field, table, table_has_left;
    layout = this.getLayout();
    form_depth = parseInt(CUI.DOM.getAttribute(this.DOM, "cui-form-depth"));
    CUI.DOM.setAttribute(layout.center(), "cui-form-depth", form_depth);
    layout.empty("center");
    container = layout.center();
    Events.listen({
      node: container,
      type: "form-check-row-visibility",
      instance: this,
      call: (function(_this) {
        return function(ev) {
          var tr;
          tr = CUI.DOM.closest(ev.getNode(), ".cui-form-tr,.cui-form-block,.cui-form-row");
          ev.stopPropagation();
          if (tr) {
            _this.__setRowVisibility(tr);
          }
        };
      })(this)
    });
    table = null;
    table_has_left = null;
    append = (function(_this) {
      return function(stuff, to) {
        if (!to) {
          layout.append(stuff, "center");
        } else if (stuff) {
          to.appendChild(stuff);
        }
      };
    })(this);
    if (this._class_table) {
      CUI.DOM.addClass(container, this._class_table);
    }
    get_append = (function(_this) {
      return function(v, info) {
        if (info == null) {
          info = _this;
        }
        if (v instanceof Form) {
          return v.DOM;
        } else if (CUI.isPlainObject(v)) {
          return new MultilineLabel(v).DOM;
        } else if (isString(v)) {
          return new MultilineLabel({
            text: v
          }).DOM;
        } else if (v != null ? v.DOM : void 0) {
          return v.DOM;
        } else if (CUI.isFunction(v)) {
          return get_append(v(info));
        } else if (isEmpty(v)) {
          return null;
        } else {
          return v;
        }
      };
    })(this);
    get_label = (function(_this) {
      return function(field, register) {
        var label, lbl, ref;
        if (register == null) {
          register = false;
        }
        lbl = (ref = field._form) != null ? ref.label : void 0;
        if (!lbl) {
          return;
        }
        if (isString(lbl)) {
          label = CUI.DOM.element("label");
          label.textContent = lbl;
          field.registerLabel(label);
          return label;
        }
        return get_append(lbl);
      };
    })(this);
    fields = this.getFields();
    len = fields.length;
    field_idx = -1;
    field_has_left = (function(_this) {
      return function(_field) {
        var fopts;
        fopts = (_field != null ? _field._form : void 0) || {};
        if (fopts.label) {
          return true;
        }
        if (fopts.use_field_as_label) {
          console.error("Form: use_field_as_label is obsolete in \"ng\" design", _this);
          return true;
        }
        return false;
      };
    })(this);
    render_next_field = (function(_this) {
      return function() {
        var add_hint_div, blk, cb, classes, field, grid, has_left, hint_div, i, idx, left_side, level, name, ref, ref1, ref2, row, td, tr;
        field_idx = field_idx + 1;
        if (field_idx === len) {
          return;
        }
        field = fields[field_idx];
        hint_div = null;
        grid = (ref = field._form) != null ? ref.grid : void 0;
        if (field._form && (!isNull(field._form.hint) || field._form.right)) {
          add_hint_div = function() {
            if (hint_div) {
              return;
            }
            return hint_div = CUI.DOM.element("DIV", {
              "class": "cui-form-hint",
              "data-for-field": field.getUniqueId()
            });
          };
          if (!isNull(field._form.hint)) {
            add_hint_div();
            if (isString(field._form.hint)) {
              hint_div.appendChild(new Label({
                "class": "cui-form-hint-label",
                icon: field._form.hint_icon,
                text: field._form.hint,
                multiline: true,
                markdown: true
              }).DOM);
            } else {
              CUI.DOM.append(hint_div, field._form.hint);
            }
          }
          if (field._form.right) {
            add_hint_div();
            console.error("Form.renderTable: form.right is deprecated. Use 'hint' instead. Form:", _this, "Field:", field, "Field#", field_idx);
            append(get_append(field._form.right), hint_div);
          }
        }
        if (field instanceof Form && field.renderAsBlock()) {
          level = parseInt(CUI.DOM.getAttribute(_this.DOM, "cui-form-depth")) + 1;
          if (!level) {
            level = 1;
          }
          if (level > 3) {
            level = 3;
          }
          cb = field.getCheckbox();
          if (cb) {
            (function(cb, field) {
              return Events.listen({
                type: "data-changed",
                node: cb,
                call: function() {
                  if (cb.getValue()) {
                    blk.addClass("cui-form-block--checkbox-checked");
                    return CUI.DOM.showElement(field.DOM);
                  } else {
                    blk.removeClass("cui-form-block--checkbox-checked");
                    return CUI.DOM.hideElement(field.DOM);
                  }
                }
              });
            })(cb, field);
            left_side = cb;
          } else {
            left_side = get_label(field);
          }
          blk = new CUI.Block({
            "class": "cui-form-block",
            level: level,
            header: left_side,
            content: [get_append(field), hint_div]
          });
          if (cb) {
            blk.addClass("cui-form-block--has-checkbox");
            if (cb.getValue()) {
              blk.addClass("cui-form-block--checkbox-checked");
            } else {
              blk.removeClass("cui-form-block--checkbox-checked");
            }
          }
          append(blk);
          DOM.data(blk.DOM, "data-field", field);
          _this.__setRowVisibility(blk.DOM);
          table = null;
          table_has_left = null;
          render_next_field();
          return;
        }
        if (!table) {
          has_left = false;
          for (idx = i = ref1 = field_idx, ref2 = len; i < ref2; idx = i += 1) {
            if (field_has_left(fields[idx])) {
              has_left = true;
              break;
            }
          }
          if (!has_left) {
            table = CUI.DOM.element("DIV", {
              "class": "cui-form-container"
            });
            table_has_left = false;
          } else {
            table = CUI.DOM.element("DIV", {
              "class": "cui-form-table"
            });
            table_has_left = true;
          }
          if (_this.__horizontal) {
            CUI.DOM.addClass(table, "cui-form--horizontal");
          }
          CUI.DOM.setAttribute(table, "cui-form-depth", form_depth);
          append(table);
        }
        name = field.getName();
        classes = [];
        if (name) {
          classes.push("cui-form-field-name--" + name);
        }
        if (field instanceof Select) {
          classes.push("cui-form-field-type--select");
        } else if (field instanceof Checkbox) {
          classes.push("cui-form-field-type--checkbox");
        } else if (field instanceof Input) {
          classes.push("cui-form-field-type--input");
        }
        if (table_has_left) {
          tr = CUI.DOM.element("DIV", {
            "class": "cui-form-tr " + classes.join(" "),
            "data-for-field": field.getUniqueId()
          });
          td = CUI.DOM.element("DIV", {
            "class": "cui-form-td cui-form-key"
          });
          append(get_label(field, true), td);
          tr.appendChild(td);
          td = CUI.DOM.element("DIV", {
            "class": "cui-form-td cui-form-value"
          });
          append(get_append(field), td);
          append(hint_div, td);
          tr.appendChild(td);
          DOM.data(tr, "data-field", field);
          _this.__setRowVisibility(tr);
          if (grid) {
            tr.setAttribute("data-cui-grid", grid);
          }
          table.appendChild(tr);
        } else {
          row = CUI.DOM.element("DIV", {
            "class": "cui-form-row " + classes.join(" "),
            "data-for-field": field.getUniqueId()
          });
          row.appendChild(get_append(field));
          append(get_append(field), row);
          append(hint_div, row);
          DOM.data(row, "data-field", field);
          if (grid) {
            row.setAttribute("data-cui-grid", grid);
          }
          table.appendChild(row);
        }
        return render_next_field();
      };
    })(this);
    render_next_field();
    Events.listen({
      type: "data-changed",
      node: container,
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          var ref;
          if (!info.element) {
            return;
          }
          if ((ref = info.action) === "goto" || ref === "reset") {
            return;
          }
          _this.__undo.log[++_this.__undo.idx] = {
            name: info.element.getName(),
            undo_idx: info.undo_idx,
            action: info.action
          };
          _this.__undo.log.splice(_this.__undo.idx + 1);
        };
      })(this)
    });
    return container;
  };

  Form.prototype.unregisterTableListeners = function() {
    return Events.ignore({
      node: this.getLayout().center(),
      instance: this
    });
  };

  Form.prototype.remove = function() {
    this.unregisterTableListeners();
    return Form.__super__.remove.call(this);
  };

  Form.prototype.__initUndo = function() {
    if (this.__undo) {
      return;
    }
    return this.__undo = {
      log: [],
      idx: -1
    };
  };

  Form.prototype.getLog = function() {
    var i, l, len1, log, ref;
    log = [];
    ref = this.__undo.log;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      l = ref[i];
      log.push(l.name + " " + l.action + " " + l.undo_idx);
    }
    return log.join("\n");
  };

  Form.prototype.undo = function() {
    var df, f, i, j, l, len1, len2, ref, ref1;
    if (this.__undo.idx === -1) {
      return false;
    }
    if (this.__undo.idx === 0) {
      ref = this.getFields();
      for (i = 0, len1 = ref.length; i < len1; i++) {
        df = ref[i];
        df.goto(this.__undo.idx--);
      }
      return true;
    }
    l = this.__undo.log[--this.__undo.idx];
    ref1 = this.getRootForm().getFieldsByName(l.name);
    for (j = 0, len2 = ref1.length; j < len2; j++) {
      f = ref1[j];
      f.goto(l.undo_idx);
    }
    return true;
  };

  Form.prototype.redo = function() {
    var f, i, l, len1, ref;
    if (this.__undo.idx === this.__undo.log.length - 1) {
      return false;
    }
    l = this.__undo.log[++this.__undo.idx];
    ref = this.getRootForm().getFieldsByName(l.name);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      f = ref[i];
      f.goto(l.undo_idx);
    }
    return true;
  };

  Form.prototype.getFieldByIdx = function(idx) {
    assert(isInteger(idx) && idx >= 0, this.__cls + ".getFieldByIdx", "idx must be Integer.", {
      idx: idx
    });
    return this.getFields("getFieldByIdx")[idx];
  };

  Form.prototype.updateHint = function(field_name, hint, trigger_resize) {
    var els, field;
    if (trigger_resize == null) {
      trigger_resize = true;
    }
    field = this.getFieldsByName(field_name)[0];
    if (!field) {
      console.error("Form.updateHint:", field_name, "not found.");
      return;
    }
    els = CUI.DOM.matchSelector(this.getLayout().DOM, ".cui-form-hint[data-for-field='" + field.getUniqueId() + "'] > .cui-form-hint-label");
    if (els.length !== 1) {
      console.error("Form.updateHint:", field_name, "not found in DOM.");
      return;
    }
    CUI.DOM.data(els[0]).element.setText(hint);
    if (trigger_resize) {
      Events.trigger({
        type: "content-resize",
        node: els[0]
      });
    }
    return this;
  };

  Form.prototype.__setClassOnField = function(field_name, cls, add_remove) {
    var field, i, len1, ref, row;
    ref = this.getFieldsByName(field_name);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      field = ref[i];
      row = CUI.DOM.closest(field.DOM, "[data-for-field]");
      if (!row) {
        continue;
      }
      if (add_remove) {
        CUI.DOM.addClass(row, cls);
      } else {
        CUI.DOM.removeClass(row, cls);
      }
    }
    return this;
  };

  Form.prototype.addClassToField = function(field_name, cls) {
    return this.__setClassOnField(field_name, cls, true);
  };

  Form.prototype.removeClassFromField = function(field_name, cls) {
    return this.__setClassOnField(field_name, cls, false);
  };

  Form.prototype.getFieldsByName = function(name, found_fields) {
    var _field, i, len1, ref;
    if (found_fields == null) {
      found_fields = [];
    }
    assert(isString(name), this.__cls + ".getFieldsByName", "name must be String.", {
      name: name
    });
    ref = this.getFields("getFieldsByName");
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _field = ref[i];
      if (_field.getName() === name) {
        found_fields.push(_field);
      }
      if (_field instanceof Form) {
        _field.getFieldsByName(name, found_fields);
      }
    }
    return found_fields;
  };

  Form.prototype.getFields = function(func) {
    return this.__fields;
  };

  Form.prototype.isDataField = function() {
    if (this._name) {
      return true;
    } else {
      return false;
    }
  };

  Form.prototype.hasData = function() {
    return false;
  };

  Form.prototype.getValue = function() {
    var data, field, i, k, len1, ref;
    if (!this._name) {
      data = {};
      ref = this.getDataFields();
      for (i = 0, len1 = ref.length; i < len1; i++) {
        field = ref[i];
        if (k = field.getName()) {
          data[k] = field.getValue();
        }
      }
      return data;
    } else {
      data = copyObject(this.__data, true);
      delete data._undo;
      return data;
    }
  };

  Form.prototype.isChanged = function() {
    var _field, i, len1, ref;
    ref = this.getFields();
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _field = ref[i];
      if (_field.isChanged()) {
        return true;
      }
    }
    return false;
  };

  Form.prototype.destroy = function() {
    if (this.table) {
      this.unregisterTableListeners();
      DOM.remove(this.table);
      this.table = null;
    }
    return Form.__super__.destroy.call(this);
  };

  return Form;

})(CUI.DataField);

CUI.Events.registerEvent({
  type: "form-check-row-visibility",
  bubble: true
});

Form = CUI.Form;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FormPopover,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

FormPopover = (function(superClass) {
  extend(FormPopover, superClass);

  function FormPopover(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FormPopover.__super__.constructor.call(this, this.opts);
    this.__old_display = null;
    this.__old_render = null;
    this;
  }

  FormPopover.prototype.initOpts = function() {
    FormPopover.__super__.initOpts.call(this);
    return this.addOpts({
      popover: {
        "default": {},
        check: "PlainObject"
      },
      button: {
        "default": {},
        check: function(v) {
          return CUI.isPlainObject(v) && !v.onClick;
        }
      },
      trigger_data_changed_while_open: {
        "default": false,
        check: Boolean
      },
      renderDisplayButton: {
        check: Function
      },
      renderDisplayContent: {
        check: Function
      }
    });
  };

  FormPopover.prototype.readOpts = function() {
    FormPopover.__super__.readOpts.call(this);
    if (this._class) {
      this.__class = this._class;
      delete this._class;
    }
    this.__fields_is_func = CUI.isFunction(this._fields);
    if (this.__fields_is_func) {
      return assert(this._data_not_for_others !== true, "new FormPopover", "opts.data_not_for_others cannot be set to true if fields are created on open by a Function.", {
        opts: this.opts
      });
    }
  };

  FormPopover.prototype.init = function() {
    if (!this.__fields_is_func) {
      return FormPopover.__super__.init.call(this);
    }
    this.__initUndo();
    return this.setFormDepth();
  };

  FormPopover.prototype.setDataOnOthers = function() {
    if (this.__fields_is_func) {
      return false;
    } else {
      return FormPopover.__super__.setDataOnOthers.call(this);
    }
  };

  FormPopover.prototype.isChanged = function() {
    if (this.__fields) {
      return FormPopover.__super__.isChanged.call(this);
    } else {
      return false;
    }
  };

  FormPopover.prototype.getFields = function(func) {
    if (func == null) {
      func = "";
    }
    if (func === "render" || func === "displayValue") {
      return [];
    }
    if (func === "show" || func === "hide" || func === "enable" || func === "disable" || func === "getFieldsByName" || func === "getFieldByIdx" || func === "setFormDepth" || func === "getDataFields") {
      return this.__fields || [];
    }
    assert(this.__fields, "FormPopover.getFields(" + func + ")", "Fields not rendered yet. This is a programming error in CUI.");
    return FormPopover.__super__.getFields.call(this);
  };

  FormPopover.prototype.initTemplate = function() {
    var vl;
    vl = new VerticalLayout({
      maximize: false,
      bottom: {}
    });
    return this.registerTemplate(vl.getLayout());
  };

  FormPopover.prototype.hasContentForAppend = function() {
    return true;
  };

  FormPopover.prototype.render = function() {
    var button_opts;
    button_opts = copyObject(this._button, true);
    button_opts.onClick = (function(_this) {
      return function() {
        return _this.__openPopover();
      };
    })(this);
    CUI.mergeMap(button_opts, {
      left: true,
      text: ""
    });
    this.__button = new CUI.defaults["class"].Button(button_opts);
    this.addClass("cui-data-field-input");
    if (this._renderDisplayButton) {
      this.addClass("cui-form-popover-has-button-text");
    }
    this.append(this.__button, "center");
    DataField.prototype.render.call(this);
    return this;
  };

  FormPopover.prototype.getButton = function() {
    return this.__button;
  };

  FormPopover.prototype.displayValue = function() {
    DataField.prototype.displayValue.call(this);
    return this.__renderDisplay();
  };

  FormPopover.prototype.callOnFields = function() {
    var args, df, func, i, len, ref;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    ref = this.getFields();
    for (i = 0, len = ref.length; i < len; i++) {
      df = ref[i];
      df[func].apply(df, args);
    }
    return this;
  };

  FormPopover.prototype.__renderDisplay = function() {
    var display, render, text;
    if (this._renderDisplayContent) {
      display = this._renderDisplayContent(this, this.__data);
    } else if (this._renderDisplayButton) {
      render = this._renderDisplayButton(this, this.__data);
    } else if (!this.__data) {
      text = "Data not set.";
      display = $textEmpty(text);
    } else {
      display = text = "";
    }
    if (this._renderDisplayButton) {
      if (render === false) {
        this.__button.deactivate();
      } else if (render === true) {
        this.__button.activate();
      } else if (render instanceof Icon) {
        this.__button.setIcon(render);
        this.__button.setText();
      } else {
        this.__button.setIcon();
        this.__button.setText(render);
      }
      if (this.__old_render !== null) {
        Events.trigger({
          type: "content-resize",
          node: this.DOM
        });
      }
      this.__old_render = render;
    } else {
      if (this.__old_display === null || this.__old_display !== display) {
        this.replace(display, "bottom");
        if (this.__old_display !== null) {
          Events.trigger({
            type: "content-resize",
            node: this.DOM
          });
        }
        this.__old_display = display;
      }
    }
    this.checkChanged();
    return this;
  };

  FormPopover.prototype.renderTable = function() {
    this.table = FormPopover.__super__.renderTable.call(this);
    this.getLayout().addClass(this.__class);
    return this.table;
  };

  FormPopover.prototype.initPopover = function(opts) {
    return new Popover(opts);
  };

  FormPopover.prototype.getPopoverOpts = function() {
    var pop_opts;
    pop_opts = copyObject(this._popover, true);
    if (!pop_opts.backdrop) {
      pop_opts.backdrop = {};
    }
    if (!pop_opts.backdrop.policy) {
      pop_opts.backdrop.policy = "click";
    }
    if (!pop_opts.pane) {
      pop_opts.pane = {};
    }
    assert(CUI.isPlainObject(pop_opts.pane), "new FormPopover", "opts.pane must be PlainObject", {
      opts: pop_opts
    });
    if (isEmpty(pop_opts["class"])) {
      pop_opts["class"] = "";
    }
    pop_opts["class"] += " cui-form-popover-popover";
    return pop_opts;
  };

  FormPopover.prototype.getPopover = function() {
    return this.__popover;
  };

  FormPopover.prototype.renderAsBlock = function() {
    return false;
  };

  FormPopover.prototype.resetTableAndFields = function() {
    this.callOnFields("remove");
    this.unregisterTableListeners();
    if (CUI.__ng__) {
      CUI.DOM.empty(this.table);
    } else {
      CUI.DOM.remove(this.table);
    }
    this.table = null;
    this.__fields = null;
    return this;
  };

  FormPopover.prototype.__openPopover = function() {
    var onHide, onShow, pop_opts;
    pop_opts = this.getPopoverOpts();
    if (this.__fields_is_func) {
      if (this.table) {
        this.resetTableAndFields();
      }
      this.initFields();
      this.callOnFields("setData", this.__data);
    }
    if (!this.table) {
      this.renderTable();
      this.callOnFields("start");
    }
    if (!pop_opts.hasOwnProperty("element")) {
      pop_opts.element = this.__button;
    }
    onHide = pop_opts.onHide;
    pop_opts.onHide = (function(_this) {
      return function(pop, ev) {
        _this.__closePopover();
        return typeof onHide === "function" ? onHide(pop, ev) : void 0;
      };
    })(this);
    onShow = pop_opts.onShow;
    if (onShow) {
      pop_opts.onShow = (function(_this) {
        return function(pop) {
          return typeof onShow === "function" ? onShow(pop, _this) : void 0;
        };
      })(this);
    }
    pop_opts.pane.content = this.getLayout();
    this.__popover = this.initPopover(pop_opts);
    Events.listen({
      type: "data-changed",
      node: this.__popover,
      call: (function(_this) {
        return function(ev, info) {
          if (info == null) {
            info = {};
          }
          _this.__renderDisplay();
          _this.__dataChanged = info;
          if (_this._trigger_data_changed_while_open) {
            _this.__triggerDataChanged();
          }
        };
      })(this)
    });
    this.__popover.show();
    return this.addClass("focus");
  };

  FormPopover.prototype.__closePopover = function() {
    this.removeClass("focus");
    this.getLayout().DOM.detach();
    this.__popover.destroy();
    this.__popover = null;
    this.__triggerDataChanged();
    return this;
  };

  FormPopover.prototype.closePopover = function() {
    var ref;
    return (ref = this.__popover) != null ? ref.hide() : void 0;
  };

  FormPopover.prototype.hide = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.closePopover();
    return FormPopover.__super__.hide.call(this, trigger_event);
  };

  FormPopover.prototype.__triggerDataChanged = function() {
    if (this.__dataChanged) {
      this.triggerDataChanged();
    }
    return this.__dataChanged = null;
  };

  FormPopover.prototype.triggerDataChanged = function() {
    return Events.trigger({
      type: "data-changed",
      node: this.__button,
      info: this.__dataChanged
    });
  };

  FormPopover.prototype.disable = function() {
    var ref;
    FormPopover.__super__.disable.call(this);
    return (ref = this.__button) != null ? ref.disable() : void 0;
  };

  FormPopover.prototype.enable = function() {
    var ref;
    FormPopover.__super__.enable.call(this);
    return (ref = this.__button) != null ? ref.enable() : void 0;
  };

  FormPopover.prototype.destroy = function() {
    var ref;
    FormPopover.__super__.destroy.call(this);
    if ((ref = this.__popover) != null) {
      ref.destroy();
    }
    return this.__dataChanged = null;
  };

  return FormPopover;

})(Form);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var FormModal,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FormModal = (function(superClass) {
  extend(FormModal, superClass);

  function FormModal(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FormModal.__super__.constructor.call(this, this.opts);
    this.__old_text = null;
    this.__old_display = null;
  }

  FormModal.prototype.initOpts = function() {
    FormModal.__super__.initOpts.call(this);
    this.removeOpt("popover");
    return this.addOpts({
      modal: {
        "default": {},
        check: "PlainObject",
        apply_button: {
          mandatory: true,
          "default": {
            text: "Ok"
          },
          check: (function(_this) {
            return function(v) {
              return CUI.isPlainObject(v);
            };
          })(this)
        }
      }
    });
  };

  FormModal.prototype.initPopover = function(opts) {
    var btn, btn_opts, mod, onClick;
    btn_opts = copyObject(this._modal.apply_button, true);
    onClick = btn_opts.onClick;
    btn_opts.onClick = (function(_this) {
      return function(ev, btn) {
        return CUI.decide(typeof onClick === "function" ? onClick(ev, btn, _this) : void 0).done(function() {
          return _this.__popover.hide();
        });
      };
    })(this);
    btn = new CUI.defaults["class"].Button(btn_opts);
    if (this.hasChanges()) {
      btn.enable();
    } else {
      btn.disable();
    }
    opts.pane.footer_right = btn;
    mod = new Modal(opts);
    if (this.__orig_set_data) {
      Events.listen({
        type: "data-changed",
        node: mod,
        call: (function(_this) {
          return function() {
            if (_this.hasChanges()) {
              return btn.enable();
            } else {
              return btn.disable();
            }
          };
        })(this)
      });
    }
    return mod;
  };

  FormModal.prototype.revertData = function() {
    assert(this.__orig_set_data, "Form.revertData", "Only supported with opts.name set and opts.data PlainObject.", {
      opts: this.opts
    });
    delete this.__data;
    if (this.__orig_data) {
      this.__orig_set_data[this._name] = this.__orig_data;
    } else {
      delete this.__orig_set_data[this._name];
    }
    this.setData(this.__orig_set_data);
    this.resetTableAndFields();
    Events.trigger({
      type: "data-changed",
      node: this.getPopover()
    });
    return this;
  };

  FormModal.prototype.setData = function(data) {
    if (this._name && !CUI.isFunction(data)) {
      if (data[this._name]) {
        this.__orig_data = copyObject(data[this._name], true);
      } else {
        this.__orig_data = void 0;
      }
      this.__orig_set_data = data;
    }
    return FormModal.__super__.setData.call(this, data);
  };

  FormModal.prototype.__closePopover = function() {
    if (this.__orig_set_data) {
      this.__orig_data = copyObject(this.__orig_set_data[this._name], true);
    }
    return FormModal.__super__.__closePopover.call(this);
  };

  FormModal.prototype.hasChanges = function() {
    if (this.__orig_set_data) {
      return JSON.stringify(this.__orig_data) !== JSON.stringify(this.__orig_set_data[this._name]);
    } else {
      return null;
    }
  };

  FormModal.prototype.getPopoverOpts = function() {
    var onCancel, pop_opts;
    pop_opts = copyObject(this._modal, true);
    if (pop_opts.cancel && this.__orig_set_data) {
      onCancel = pop_opts.onCancel;
      pop_opts.onCancel = (function(_this) {
        return function(ev, modal) {
          var dfr;
          dfr = new CUI.Deferred();
          CUI.decide(typeof onCancel === "function" ? onCancel(ev, modal, _this.hasChanges()) : void 0).done(dfr.resolve).fail(dfr.reject);
          dfr.done(function() {
            return _this.revertData();
          });
          return dfr.promise();
        };
      })(this);
    }
    delete pop_opts.apply_button;
    if (isEmpty(pop_opts["class"])) {
      pop_opts["class"] = "";
    }
    pop_opts.element = null;
    if (!pop_opts.pane) {
      pop_opts.pane = {};
    }
    assert(CUI.isPlainObject(pop_opts.pane), "new FormModal", "opts.pane must be PlainObject", {
      opts: pop_opts
    });
    pop_opts["class"] += " cui-form-modal-modal";
    return pop_opts;
  };

  FormModal.prototype.disable = function() {
    var ref;
    FormModal.__super__.disable.call(this);
    return (ref = this.__button) != null ? ref.disable() : void 0;
  };

  FormModal.prototype.enable = function() {
    var ref;
    FormModal.__super__.enable.call(this);
    return (ref = this.__button) != null ? ref.enable() : void 0;
  };

  FormModal.prototype.destroy = function() {
    var ref;
    FormModal.__super__.destroy.call(this);
    return (ref = this.__popover) != null ? ref.destroy() : void 0;
  };

  return FormModal;

})(FormPopover);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DataTable,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DataTable = (function(superClass) {
  extend(DataTable, superClass);

  function DataTable(opts) {
    this.opts = opts;
    DataTable.__super__.constructor.call(this, this.opts);
    Layout.prototype.maximizeAddClasses.call(this);
  }

  DataTable.defaults = {
    plus_button_tooltip: null,
    minus_button_tooltip: null
  };

  DataTable.prototype.initOpts = function() {
    DataTable.__super__.initOpts.call(this);
    return this.addOpts({
      fields: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      new_rows: {
        "default": "edit",
        check: ["edit", "append", "remove_only", "none"]
      },
      no_header: {
        check: Boolean
      },
      rowMove: {
        "default": false,
        check: Boolean
      },
      onRowRemove: {
        check: Function
      },
      onNodeAdd: {
        check: Function
      },
      maximize: {
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean,
        "default": false
      },
      maximize_vertical: {
        check: Boolean,
        "default": false
      },
      footer_right: {
        check: function(v) {
          return isContent(v);
        }
      },
      buttons: {
        mandatory: true,
        "default": [],
        check: function(v) {
          return CUI.isArray(v);
        }
      },
      chunk_size: {
        "default": 0,
        mandatory: true,
        check: function(v) {
          return v >= 0;
        }
      }
    });
  };

  DataTable.prototype.readOpts = function() {
    DataTable.__super__.readOpts.call(this);
    this.__navi_prev = null;
    this.__navi_next = null;
    this.__offset = 0;
    Layout.prototype.maximizeReadOpts.call(this);
    assert(!(this._chunk_size && this._rowMove), "new DataTable", "opts.chunk_size and opts.rowMove are mutually exclusive.", {
      opts: this.opts
    });
    return this;
  };

  DataTable.prototype.getFieldList = function() {
    return this.__fieldList;
  };

  DataTable.prototype.getFieldsByName = function(name, found_fields) {
    var field, i, len1, ref;
    if (found_fields == null) {
      found_fields = [];
    }
    ref = this.getFieldList();
    for (i = 0, len1 = ref.length; i < len1; i++) {
      field = ref[i];
      if (field.getName() === name) {
        found_fields.push(field);
      }
      if (typeof field.getFieldsByName === "function") {
        field.getFieldsByName(name, found_fields);
      }
    }
    return found_fields;
  };

  DataTable.prototype.debug = function() {
    var ref;
    DataTable.__super__.debug.call(this);
    return (ref = this.listView) != null ? ref.debug() : void 0;
  };

  DataTable.prototype.init = function() {
    var _field, field, i, len1, ref, results;
    this.__fieldList = [];
    ref = this.getArrayFromOpt("fields");
    results = [];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      field = ref[i];
      _field = DataField["new"](field);
      results.push(this.__fieldList.push(_field));
    }
    return results;
  };

  DataTable.prototype.disable = function() {
    var ref;
    DataTable.__super__.disable.call(this);
    if ((ref = this.listView) != null) {
      ref.setInactive(true, null);
    }
    return this;
  };

  DataTable.prototype.enable = function() {
    var ref;
    DataTable.__super__.enable.call(this);
    if ((ref = this.listView) != null) {
      ref.setInactive(false, null);
    }
    return this;
  };

  DataTable.prototype.getDefaultValue = function() {
    return [];
  };

  DataTable.prototype.addRow = function(data) {
    var new_node;
    if (data == null) {
      data = {};
    }
    this.rows.push(data);
    new_node = new DataTableNode({
      dataTable: this,
      data: data,
      dataRowIdx: this.rows.length - 1,
      rows: this.rows
    });
    if (typeof this._onNodeAdd === "function") {
      this._onNodeAdd(node);
    }
    this.storeValue(copyObject(this.rows, true));
    if (this._chunk_size > 0) {
      this.__offset = Math.floor((this.rows.length - 1) / this._chunk_size) * this._chunk_size;
      this.displayValue();
    } else {
      this.listView.appendRow(new_node);
    }
    return new_node;
  };

  DataTable.prototype.render = function() {
    var buttons, cls, colClasses, cols, f, footer, i, idx, j, label, len1, len2, load_page, maxis, name, page_data, ref, ref1, ref2, ref3, ref4, ref5, ref6, updateMinusButton;
    DataTable.__super__.render.call(this);
    cols = [];
    colClasses = [];
    maxis = [];
    this.headerRow = new ListViewHeaderRow();
    ref = this.__fieldList;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      f = ref[idx];
      if (((ref1 = f.getOpt("form")) != null ? ref1.column : void 0) === "maximize" || f instanceof DataTable) {
        maxis.push(idx);
      }
    }
    if (maxis.length === 0) {
      maxis.push(0);
    }
    ref2 = this.__fieldList;
    for (idx = j = 0, len2 = ref2.length; j < len2; idx = ++j) {
      f = ref2[idx];
      if (idxInArray(idx, maxis) > -1) {
        cols.push("maximize");
      } else if ((ref3 = f.getOpt("form")) != null ? ref3.column : void 0) {
        cols.push(f._form.column);
      } else if (f.isResizable()) {
        cols.push("auto");
      } else {
        cols.push("fixed");
      }
      name = f.getName();
      label = (ref4 = f._form) != null ? ref4.label : void 0;
      if (isNull(label)) {
        label = name;
      }
      cls = [];
      if (name) {
        cls.push("cui-data-table-column-field-name-" + name);
      }
      cls.push("cui-data-table-column-field-type-" + toDash(f.getElementClass()));
      if ((ref5 = f._form) != null ? ref5.rotate_90 : void 0) {
        cls.push("cui-lv-td-rotate-90");
      }
      colClasses.push(cls);
      this.headerRow.addColumn(new ListViewHeaderColumn({
        rotate_90: (ref6 = f._form) != null ? ref6.rotate_90 : void 0,
        label: {
          text: label,
          multiline: true
        }
      }));
    }
    buttons = this._buttons.slice(0);
    if (this._new_rows !== "none") {
      if (this._new_rows !== "remove_only") {
        buttons.push({
          icon: "plus",
          tooltip: {
            text: CUI.DataTable.defaults.plus_button_tooltip
          },
          group: "plus-minus",
          onClick: (function(_this) {
            return function() {
              return _this.addRow();
            };
          })(this)
        });
      }
      this.minusButton = new CUI.defaults["class"].Button({
        icon: "minus",
        group: "plus-minus",
        tooltip: {
          text: CUI.DataTable.defaults.minus_button_tooltip
        },
        disabled: true,
        onClick: (function(_this) {
          return function() {
            var k, len3, ref7, row;
            ref7 = _this.listView.getSelectedRows();
            for (k = 0, len3 = ref7.length; k < len3; k++) {
              row = ref7[k];
              row.remove();
            }
            _this.storeValue(copyObject(_this.rows, true));
            updateMinusButton();
            if (_this._chunk_size > 0) {
              _this.displayValue();
            }
          };
        })(this)
      });
      buttons.push(this.minusButton);
      updateMinusButton = (function(_this) {
        return function() {
          if (_this.listView.getSelectedRows().length === 0) {
            return _this.minusButton.disable();
          } else {
            return _this.minusButton.enable();
          }
        };
      })(this);
    }
    if (this._chunk_size > 0) {
      buttons.push({
        onConstruct: (function(_this) {
          return function(btn) {
            return _this.__navi_prev = btn;
          };
        })(this),
        icon: "left",
        disabled: true,
        group: "navi",
        onClick: (function(_this) {
          return function() {
            _this.__offset = _this.__offset - _this._chunk_size;
            return _this.displayValue();
          };
        })(this)
      });
      page_data = {};
      load_page = (function(_this) {
        return function() {
          _this.__offset = (page_data.page - 1) * _this._chunk_size;
          return _this.displayValue();
        };
      })(this);
      this.__navi_input = new CUI.NumberInput({
        group: "navi",
        placeholder: "henk",
        data: page_data,
        name: 'page',
        onBlur: (function(_this) {
          return function(input) {
            return input.setValue(null);
          };
        })(this),
        onDataChanged: (function(_this) {
          return function() {
            CUI.debug("input changed to", page_data.page);
            CUI.scheduleCallback({
              ms: 1000,
              call: load_page
            });
          };
        })(this)
      }).start();
      buttons.push(this.__navi_input);
      buttons.push({
        onConstruct: (function(_this) {
          return function(btn) {
            return _this.__navi_next = btn;
          };
        })(this),
        icon: "right",
        disabled: true,
        group: "navi",
        onClick: (function(_this) {
          return function() {
            _this.__offset = _this.__offset + _this._chunk_size;
            return _this.displayValue();
          };
        })(this)
      });
    }
    if (buttons.length) {
      footer = new Buttonbar({
        buttons: buttons
      });
    }
    this.listView = new CUI.ListView({
      "class": "cui-lv--has-datafields",
      selectableRows: this._new_rows !== "none",
      onSelect: updateMinusButton,
      onDeselect: updateMinusButton,
      onRowMove: (function(_this) {
        return function(display_from_i, display_to_i, after) {
          var fr;
          fr = _this.listView.fixedRowsCount;
          display_from_i = _this.__offset + display_from_i;
          display_to_i = _this.__offset + display_to_i;
          moveInArray(display_from_i - fr, display_to_i - fr, _this.rows, after);
          return Events.trigger({
            type: "data-changed",
            node: _this.listView
          });
        };
      })(this),
      cols: cols,
      fixedRows: this._no_header ? 0 : 1,
      footer_left: footer,
      footer_right: this._footer_right,
      fixedCols: this._rowMove ? 1 : 0,
      colResize: this._no_header ? false : true,
      colClasses: colClasses,
      rowMove: this._rowMove,
      maximize: this._maximize,
      maximize_horizontal: this._maximize_horizontal,
      maximize_vertical: this._maximize_vertical
    });
    if (this.isDisabled()) {
      this.listView.setInactive(true, null);
    }
    this.replace(this.listView.render());
    Events.listen({
      type: "data-changed",
      node: this.listView,
      call: (function(_this) {
        return function(ev, info) {
          ev.stopPropagation();
          _this.storeValue(copyObject(_this.rows, true));
        };
      })(this)
    });
    return this;
  };

  DataTable.prototype.displayValue = function() {
    var i, idx, last_page, len, len1, node, page, placeholder, ref, row, rows_sliced, sep;
    this.listView.removeAllRows();
    if (!this._no_header) {
      this.listView.appendRow(this.headerRow);
    }
    this.rows = copyObject(this.getValue(), true);
    if (this._chunk_size > 0) {
      len = this.rows.length;
      if (this.__offset >= len) {
        this.__offset = Math.max(this.__offset - this._chunk_size);
      }
      page = Math.floor(this.__offset / this._chunk_size);
      last_page = Math.ceil(len / this._chunk_size) - 1;
      sep = ' / ';
      placeholder = (page + 1) + sep + (last_page + 1);
      this.__navi_input.setMin(1);
      this.__navi_input.setMax(last_page + 1);
      this.__navi_input.setValue(null);
      this.__navi_input.setPlaceholder(placeholder);
      CUI.DOM.setAttribute(this.__navi_input.getElement(), "data-max-chars", ("" + (last_page + 1)).length * 2 + sep.length);
      if (page > 0) {
        this.__navi_prev.enable();
      } else {
        this.__navi_prev.disable();
      }
      if (page < last_page) {
        this.__navi_next.enable();
      } else {
        this.__navi_next.disable();
      }
    }
    assert(CUI.isArray(this.rows), "DataTable.displayValue", "\"value\" needs to be Array.", {
      data: this.getData(),
      value: this.getValue()
    });
    if (this.rows) {
      if (this._chunk_size > 0) {
        rows_sliced = this.rows.slice(this.__offset, this.__offset + this._chunk_size);
      } else {
        rows_sliced = this.rows;
      }
      for (idx = i = 0, len1 = rows_sliced.length; i < len1; idx = ++i) {
        row = rows_sliced[idx];
        node = new DataTableNode({
          dataTable: this,
          data: row,
          dataRowIdx: idx,
          rows: this.rows,
          check_changed_data: (ref = this.getInitValue()) != null ? ref[idx] : void 0
        });
        if (typeof this._onNodeAdd === "function") {
          this._onNodeAdd(node);
        }
        this.listView.appendRow(node, true);
      }
      this.listView.appendDeferredRows();
    }
    return this;
  };

  return DataTable;

})(CUI.DataFieldInput);

DataTable = CUI.DataTable;
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DataTableNode,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DataTableNode = (function(superClass) {
  extend(DataTableNode, superClass);

  function DataTableNode() {
    return DataTableNode.__super__.constructor.apply(this, arguments);
  }

  DataTableNode.prototype.initOpts = function() {
    DataTableNode.__super__.initOpts.call(this);
    return this.addOpts({
      dataTable: {
        mandatory: true,
        check: DataTable
      },
      data: {
        mandatory: true,
        check: "PlainObject"
      },
      check_changed_data: {
        check: "PlainObject"
      },
      rows: {
        mandatory: true,
        check: "Array"
      },
      dataRowIdx: {
        mandatory: true,
        check: function(v) {
          return v >= 0;
        }
      }
    });
  };

  DataTableNode.prototype.readOpts = function() {
    var _f, f, fopts, i, len, ref;
    DataTableNode.__super__.readOpts.call(this);
    this.__dataTable = this._dataTable;
    this.__data = this._data;
    this.__check_changed_data = this._check_changed_data;
    this.__rows = this._rows;
    assert(this.__rows.indexOf(this.__data) > -1, "new " + (getObjectClass(this)), "opts.data needs to be item in opts.rows Array", {
      opts: this.opts
    });
    this.__fields = [];
    ref = this.__dataTable.getFieldList();
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      fopts = f.getOpts();
      fopts.undo_support = false;
      _f = new window[f.__cls](fopts);
      _f.setForm(this);
      _f.setData(this.__data);
      if (f.hasData()) {
        if (this.__check_changed_data) {
          _f.setCheckChangedValue(this.__check_changed_data[f.getName()]);
        } else {
          _f.setCheckChangedValue(f.getDefaultValue());
        }
      }
      this.__fields.push(_f);
      this.addColumn(new ListViewColumn({
        element: _f.DOM
      }));
    }
    return this;
  };

  DataTableNode.prototype.remove = function() {
    var ref;
    DataTableNode.__super__.remove.call(this);
    if ((ref = this._dataTable._onRowRemove) != null) {
      ref.call(this, this.__data);
    }
    return removeFromArray(this.__data, this.__rows);
  };

  DataTableNode.prototype.getDataTable = function() {
    return this._dataTable;
  };

  DataTableNode.prototype.getFieldByIdx = function(idx) {
    return this.__fields[idx];
  };

  DataTableNode.prototype.getDataRowIdx = function() {
    return this._dataRowIdx;
  };

  DataTableNode.prototype.getFieldsByName = function(name) {
    var f, fields, i, len, ref;
    fields = [];
    ref = this.__fields;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getName() === name) {
        fields.push(f);
      }
    }
    return fields;
  };

  DataTableNode.prototype.getFields = function() {
    return this.__fields;
  };

  DataTableNode.prototype.getData = function() {
    return this.__data;
  };

  DataTableNode.prototype.addedToListView = function() {
    var df, i, len, ref;
    ref = this.__fields;
    for (i = 0, len = ref.length; i < len; i++) {
      df = ref[i];
      df.start();
    }
    return this;
  };

  return DataTableNode;

})(ListViewRow);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Select,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Select = (function(superClass) {
  extend(Select, superClass);

  function Select() {
    return Select.__super__.constructor.apply(this, arguments);
  }

  Select.prototype.initOpts = function() {
    Select.__super__.initOpts.call(this);
    return this.addOpts({
      empty_text: {
        check: String
      },
      not_found_text: {
        "default": "- not found -",
        check: String
      },
      options: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      group: {
        check: String
      },
      onShow: {
        check: Function
      },
      onHide: {
        check: Function
      }
    });
  };

  Select.prototype.init = function() {
    this.__value = null;
    if (!CUI.isFunction(this._options)) {
      return this.__loadOptions();
    }
  };

  Select.prototype.disable = function(__wasAutomaticDisabled) {
    this.__wasAutomaticDisabled = __wasAutomaticDisabled != null ? __wasAutomaticDisabled : false;
    return Select.__super__.disable.call(this);
  };

  Select.prototype.isDisabled = function() {
    if (this.__wasAutomaticDisabled) {
      return false;
    } else {
      return Select.__super__.isDisabled.call(this);
    }
  };

  Select.prototype.enableOption = function(value) {
    var opt;
    opt = this.__getOptionByValue(value);
    if (!opt) {
      return;
    }
    opt.disabled = false;
    return this.displayValue();
  };

  Select.prototype.disableOption = function(value) {
    var opt;
    opt = this.__getOptionByValue(value);
    if (!opt) {
      return;
    }
    opt.disabled = true;
    return this.displayValue();
  };

  Select.prototype.__getOptionByValue = function(value) {
    var i, len, opt, ref;
    ref = this.getOptions();
    for (i = 0, len = ref.length; i < len; i++) {
      opt = ref[i];
      if (opt.value === value) {
        return opt;
      }
    }
    return null;
  };

  Select.prototype.enable = function(automatic) {
    if (automatic == null) {
      automatic = false;
    }
    if (automatic) {
      if (this.__wasAutomaticDisabled) {
        return Select.__super__.enable.call(this);
      } else {

      }
    } else {
      return Select.__super__.enable.call(this);
    }
  };

  Select.prototype.__loadOptions = function(event) {
    var btn, icon_right, ref, ret;
    if (((ref = this.__optionsPromise) != null ? ref.state() : void 0) === "pending") {
      return this.__optionsPromise;
    }
    ret = this.getArrayFromOpt("options", event, true);
    if (isPromise(ret)) {
      this.__optionsPromise = ret;
      btn = this.getButton();
      if (btn) {
        icon_right = btn.getIconRight();
        btn.setIconRight("spinner");
        this.__optionsPromise.always((function(_this) {
          return function() {
            return btn.setIconRight(icon_right);
          };
        })(this));
      }
    } else {
      this.__optionsPromise = CUI.resolvedPromise(ret);
    }
    this.__optionsPromise.done((function(_this) {
      return function(__options) {
        var first_value_opt, i, idx, len, opt, ref1;
        _this.__options = __options;
        first_value_opt = void 0;
        ref1 = _this.__options;
        for (idx = i = 0, len = ref1.length; i < len; idx = ++i) {
          opt = ref1[idx];
          opt._idx = idx;
          if (isUndef(opt.text) && !isUndef(opt.value) && !opt.icon) {
            opt.text = "" + opt.value;
          }
          if (isUndef(opt.value) && !isUndef(opt.text)) {
            opt.value = opt.text;
          }
          if (!isUndef(opt.value) && first_value_opt === void 0) {
            first_value_opt = opt;
          }
        }
        _this._default_opt = void 0;
        if (first_value_opt) {
          _this.default_opt = first_value_opt;
          return _this.__value = _this.default_opt.value;
        } else {
          return CUI.warn("Select " + (_this.getName()) + ": did not find a value opt and no empty text is defined.", {
            opts: _this.opts
          });
        }
      };
    })(this));
    return this.__optionsPromise;
  };

  Select.prototype.setData = function(data) {
    Select.__super__.setData.call(this, data, false);
    if (CUI.isFunction(this._options)) {
      this.__loadOptions().done((function(_this) {
        return function() {
          return _this.initData();
        };
      })(this));
    } else {
      this.initData();
    }
    return this;
  };

  Select.prototype.getCheckboxClass = function() {
    return "cui-button-select";
  };

  Select.prototype.registerLabel = function() {};

  Select.prototype.getButtonOpts = function() {
    var ref;
    return {
      group: this._group,
      role: "select",
      left: true,
      menu: {
        active_item_idx: ((ref = this.default_opt) != null ? ref._idx : void 0) || null,
        allow_null: !isEmpty(this._empty_text),
        "class": "ez-menu-select",
        onDeactivate: (function(_this) {
          return function(btn, item, idx, flags) {
            if (flags.prior_activate) {
              return;
            }
            _this.storeValue(null, flags);
            if (_this.isDestroyed()) {
              return;
            }
            _this.displayValue();
            return _this;
          };
        })(this),
        onClick: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onClick) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onShow: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onShow) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onHide: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onHide) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onActivate: (function(_this) {
          return function(btn, item, idx, flags) {
            _this.storeValue(_this.__options[idx].value, flags);
            if (_this.isDestroyed()) {
              return;
            }
            _this.displayValue();
            return _this;
          };
        })(this),
        items: (function(_this) {
          return function(event) {
            return _this.__loadOptions(event).done(function() {
              return _this.displayValue();
            });
          };
        })(this),
        has_items: true
      }
    };
  };

  Select.prototype.getDefaultValue = function() {
    if (this.default_opt) {
      return this.default_opt.value;
    } else {
      return void 0;
    }
  };

  Select.prototype.getValue = function() {
    if (this.hasData()) {
      return Select.__super__.getValue.call(this);
    } else {
      return this.__value;
    }
  };

  Select.prototype.checkValue = function(v, flags) {
    return true;
  };

  Select.prototype.reload = function() {
    if (CUI.isFunction(this._options)) {
      this.__loadOptions();
    }
    return Select.__super__.reload.call(this);
  };

  Select.prototype.storeValue = function(value, flags) {
    if (this.hasData()) {
      Select.__super__.storeValue.call(this, value, flags);
    } else {
      this.__value = value;
    }
    return this;
  };

  Select.prototype.displayValue = function() {
    DataFieldInput.prototype.displayValue.call(this);
    if (!this.__optionsPromise && CUI.isFunction(this._options)) {
      this.__loadOptions();
    }
    this.__optionsPromise.done((function(_this) {
      return function() {
        var found_opt, i, idx, len, max_chars, opt, ref, ref1, ref2, txt;
        found_opt = null;
        max_chars = null;
        ref = _this.__options;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          opt = ref[idx];
          if (found_opt === null && opt.value === _this.getValue()) {
            found_opt = opt;
          }
          if (((ref1 = opt.text) != null ? ref1.length : void 0) > max_chars) {
            max_chars = (ref2 = opt.text) != null ? ref2.length : void 0;
          }
        }
        if (found_opt) {
          if (found_opt.icon) {
            _this.__checkbox.setIcon(found_opt.icon);
          } else {
            _this.__checkbox.setIcon(null);
          }
          txt = found_opt.text_selected || found_opt.text;
          _this.__checkbox.menuSetActiveIdx(found_opt._idx);
        } else {
          if (_this.getValue() === null && !isEmpty(_this._empty_text)) {
            txt = _this._empty_text;
          } else {
            txt = _this._not_found_text + ":" + _this.getValue();
          }
          _this.__checkbox.menuSetActiveIdx(null);
        }
        _this.__checkbox.setText(txt);
        if ((txt != null ? txt.length : void 0) > max_chars) {
          max_chars = txt.length;
        }
        return _this.__checkbox.setTextMaxChars(max_chars);
      };
    })(this));
    return this;
  };

  Select.prototype.getOptions = function() {
    return this.__options;
  };

  Select.newSelectOrOutput = function(opts) {
    var out_opts;
    if (opts.options.length === 1) {
      out_opts = {
        form: opts.form,
        text: opts.options[0].text
      };
      return new Output(out_opts);
    } else {
      return new Select(opts);
    }
  };

  return Select;

})(Checkbox);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var StickyHeader,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StickyHeader = (function(superClass) {
  extend(StickyHeader, superClass);

  function StickyHeader(opts) {
    this.opts = opts != null ? opts : {};
    StickyHeader.__super__.constructor.call(this, this.opts);
    this.header = new Template({
      name: "sticky-header",
      map: {
        center: true
      }
    });
    this.registerTemplate(this.header);
    this.addClass("cui-sticky-header-level-" + this._level);
    if (!isEmpty(this._text)) {
      this.replace($text(this._text), "center");
    } else {
      this.replace(this._content, "center");
    }
    this._control.addStickyHeader(this);
  }

  StickyHeader.prototype.initOpts = function() {
    StickyHeader.__super__.initOpts.call(this);
    return this.addOpts({
      control: {
        mandatory: true,
        check: StickyHeaderControl
      },
      text: {
        check: String
      },
      content: {},
      level: {
        "default": 0,
        check: function(v) {
          return v === 0 || v === 1 || v === 2;
        }
      }
    });
  };

  StickyHeader.prototype.getLevel = function() {
    return this._level;
  };

  return StickyHeader;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var StickyHeaderControl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StickyHeaderControl = (function(superClass) {
  extend(StickyHeaderControl, superClass);

  function StickyHeaderControl(opts) {
    var ref;
    this.opts = opts != null ? opts : {};
    StickyHeaderControl.__super__.constructor.call(this, this.opts);
    if ((ref = DOM.data(this._element, "stickyHeaderControl")) != null) {
      ref.destroy();
    }
    DOM.data(this._element, "stickyHeaderControl", this);
    this.__control = $div("cui-sticky-header-control");
    Events.listen({
      instance: this,
      type: "viewport-resize",
      node: this._element,
      call: (function(_this) {
        return function() {
          return _this.__positionControl();
        };
      })(this)
    });
    this.__positionControl();
    this._element.append(this.__control);
    this.headers = [];
    this.newStickyHeaders = [];
    this.__hiddenHeaders = [];
    this.__positioned = false;
    Events.listen({
      node: this._element,
      type: "scroll",
      instance: this,
      call: (function(_this) {
        return function(ev) {
          _this.position();
        };
      })(this)
    });
  }

  StickyHeaderControl.prototype.initOpts = function() {
    StickyHeaderControl.__super__.initOpts.call(this);
    return this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return isElement(v);
        }
      }
    });
  };

  StickyHeaderControl.prototype.__positionControl = function() {
    var dim;
    dim = CUI.DOM.getDimensions(this._element);
    CUI.DOM.setStyle(this.__control, {
      left: dim.clientBoundingRect.left,
      top: dim.clientBoundingRect.top
    });
    CUI.DOM.setDimension(this.__control, "marginBoxWidth", dim.clientWidth);
  };

  StickyHeaderControl.prototype.isInDOM = function() {
    return this.__control && DOM.isInDOM(this.__control);
  };

  StickyHeaderControl.prototype.addStickyHeader = function(stickyHeader) {
    assert(!this.__positioned || DOM.isInDOM(this.__control), this.__cls + ".addStickyHeader", "StickyHeaderControl is not in DOM tree anymore. Cannot add a new StickyHeader.");
    assert(stickyHeader instanceof StickyHeader, this.__cls + ".addStickyHeader", "Needs to be instance of StickyHeader but is " + (getObjectClass(stickyHeader)), {
      stickyHeader: stickyHeader
    });
    return this.newStickyHeaders.push(stickyHeader);
  };

  StickyHeaderControl.prototype.initNewStickyHeaders = function() {
    var dom, header, j, k, len, len1, measure_headers, nsh, ref;
    measure_headers = [];
    ref = this.newStickyHeaders;
    for (j = 0, len = ref.length; j < len; j++) {
      nsh = ref[j];
      dom = nsh.DOM;
      header = {
        stickyHeader: nsh,
        level: nsh.getLevel(),
        node: dom.cloneNode(true)
      };
      this.headers.push(header);
      measure_headers.push(header);
      header.node.style.visiblity = "hidden";
      this.__control.prepend(header.node);
    }
    this.newStickyHeaders.splice(0);
    for (k = 0, len1 = measure_headers.length; k < len1; k++) {
      header = measure_headers[k];
      header.dimInControl = DOM.getDimensions(header.node);
      this.__control.removeChild(header.node);
      header.node.style.visiblity = "";
    }
    return this;
  };

  StickyHeaderControl.prototype.destroy = function() {
    DOM.removeData(this._element, "stickyHeaderControl");
    Events.ignore({
      instance: this
    });
    this.__control.remove();
    this.__headers = null;
    return this.newStickyHeaders = null;
  };

  StickyHeaderControl.prototype.position = function() {
    var cut, extraTop, header, hiddenHeader, hideHeader, i, idx, j, k, l, len, len1, len2, len3, m, n, next_header, o, ref, ref1, ref2, ref3, ref4, scrollTop, slot, slots, top, top_space;
    if (!this.isInDOM()) {
      return;
    }
    this.__positioned = true;
    this.initNewStickyHeaders();
    this._element.append(this.__control);
    scrollTop = this._element.scrollTop;
    slots = [];
    extraTop = 0;
    ref = this.headers;
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      header = ref[idx];
      extraTop = 0;
      for (i = k = 0, ref1 = header.level; k < ref1; i = k += 1) {
        slot = slots[i];
        if (slot === null) {
          break;
        }
        extraTop += slots[i].dimInControl.marginBoxHeight;
      }
      if (header.stickyHeader.DOM.offsetTop < scrollTop + extraTop + header.dimInControl.marginTop) {
        slots[header.level] = header;
        for (i = l = ref2 = header.level + 1, ref3 = slots.length; l < ref3; i = l += 1) {
          slots[i] = null;
        }
      } else {
        next_header = header;
        top_space = 0;
        for (m = 0, len1 = slots.length; m < len1; m++) {
          slot = slots[m];
          if (slot === null) {
            break;
          }
          top_space += slot.dimInControl.marginBoxHeight;
        }
        break;
      }
    }
    if (next_header) {
      cut = next_header.stickyHeader.DOM.offsetTop - scrollTop - top_space;
      cut = cut - next_header.dimInControl.marginTop;
    } else {
      cut = 0;
    }
    ref4 = this.__hiddenHeaders;
    for (n = 0, len2 = ref4.length; n < len2; n++) {
      hiddenHeader = ref4[n];
      hiddenHeader.style.visibility = "";
    }
    this.__hiddenHeaders.splice(0);
    this.__control.empty();
    top = 0;
    for (idx = o = 0, len3 = slots.length; o < len3; idx = ++o) {
      slot = slots[idx];
      if (slot === null) {
        break;
      }
      this.__control.prepend(slot.node);
      if (cut < 0 && slot.level === next_header.level) {
        top += cut;
      }
      hideHeader = slot.stickyHeader.DOM;
      hideHeader.style.visibility = "hidden";
      this.__hiddenHeaders.push(hideHeader);
      slot.node.style.top = top + "px";
      top += slot.dimInControl.marginBoxHeight;
    }
    this.__control.css({
      height: top
    });
    return this;
  };

  return StickyHeaderControl;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var DigiDisplay,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DigiDisplay = (function(superClass) {
  extend(DigiDisplay, superClass);

  function DigiDisplay(opts) {
    this.opts = opts != null ? opts : {};
    DigiDisplay.__super__.constructor.call(this, this.opts);
    this.__digitsMap = [];
    this.createMarkup();
    this.registerDOMElement(this.__displayDiv);
  }

  DigiDisplay.prototype.initOpts = function() {
    DigiDisplay.__super__.initOpts.call(this);
    return this.addOpts({
      digits: {
        mandatory: true,
        check: Array
      }
    });
  };

  DigiDisplay.prototype.display = function(str) {
    var _idx, c, fc, idx, info, j, len, ref;
    ref = str.split("");
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      c = ref[idx];
      if (idx === this._digits.length) {
        break;
      }
      info = this.__digitsMap[idx];
      if (!info) {
        continue;
      }
      if (info.map.hasOwnProperty(c)) {
        _idx = info.map[c];
      } else {
        _idx = 0;
      }
      fc = info.first_div;
      if (!info.height) {
        info.height = fc.outerHeight();
      }
      fc.css("marginTop", "-" + (_idx * info.height) + "px");
      fc.attr("c", c);
      fc.attr("idx", _idx);
    }
    return this;
  };

  DigiDisplay.prototype.createMarkup = function() {
    var c, container, digit, digit_idx, fc, i, idx, j, k, len, map, matched, ref;
    this.__displayDiv = $div("cui-digi-display");
    ref = this._digits;
    for (digit_idx = j = 0, len = ref.length; j < len; digit_idx = ++j) {
      digit = ref[digit_idx];
      if (digit["static"]) {
        this.__displayDiv.append(container = $div("cui-digi-display-static cui-digi-display-" + digit_idx));
        container.append($text(digit["static"])).addClass(digit["class"]);
        if (digit.attr) {
          container.attr(digit.attr);
        }
        continue;
      }
      digit.__regexp = new RegExp(digit.mask);
      this.__displayDiv.append(container = $div("cui-digi-display-container cui-digi-display-" + digit_idx));
      container.addClass(digit["class"]);
      if (digit.attr) {
        container.attr(digit.attr);
      }
      this.__digitsMap[digit_idx] = {
        map: (map = {})
      };
      container.append(fc = $div("cui-digi-display-digit").html("&nbsp;"));
      this.__digitsMap[digit_idx].first_div = fc;
      idx = 1;
      matched = false;
      for (i = k = 32; k <= 128; i = ++k) {
        if (digit.__regexp.exec(c = String.fromCharCode(i))) {
          if (i === 32) {
            container.append($div("cui-digi-display-digit").html("&nbsp;"));
          } else {
            container.append($div("cui-digi-display-digit").text(c));
          }
          map[c] = idx;
          idx++;
          matched = true;
        }
      }
      assert(matched, "DigiDisplay.createMarkup", "Digit " + digit_idx + " not matched against the regexp. ASCII range 32-128 is allowed.", {
        digit: digit
      });
    }
    return this.__displayDiv;
  };

  return DigiDisplay;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Table = (function(superClass) {
  extend(Table, superClass);

  function Table(opts) {
    var cls, col, header, i, j, len, len1, ref, ref1, row, th, txt;
    this.opts = opts != null ? opts : {};
    Table.__super__.constructor.call(this, this.opts);
    cls = [];
    if (this._size === "mini") {
      cls.push("cui-table--mini");
    }
    if (this._class) {
      cls.push(this._class);
    }
    if (this._flex) {
      cls.push("cui-table--flex");
    }
    this.__table = $table(cls.join(" "));
    this.registerDOMElement(this.__table, false);
    if (this._header) {
      header = $tr("cui-table-header");
      ref = this.__columns;
      for (i = 0, len = ref.length; i < len; i++) {
        col = ref[i];
        if (col.text) {
          txt = col.text;
        } else {
          txt = col.name;
        }
        th = $th("cui-table-th " + col.__class);
        th.textContent = txt;
        header.appendChild(th);
      }
      this.__table.appendChild(header);
    }
    ref1 = this._rows;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      row = ref1[j];
      this.addRow(row);
    }
    this;
  }

  Table.prototype.initOpts = function() {
    var is_array_of_maps;
    Table.__super__.initOpts.call(this);
    is_array_of_maps = (function(_this) {
      return function(v, check) {
        var _v, i, idx, len;
        if (!CUI.isArray(v)) {
          return false;
        }
        for (idx = i = 0, len = v.length; i < len; idx = ++i) {
          _v = v[idx];
          if (check) {
            v[idx] = CUI.Element.readOpts(_v, "new Table", check);
          } else if (!CUI.isPlainObject(_v)) {
            return false;
          }
        }
        return true;
      };
    })(this);
    return this.addOpts({
      "class": {
        check: String
      },
      header: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      columns: {
        check: function(v) {
          return is_array_of_maps(v, {
            "class": {
              mandatory: true,
              check: String,
              "default": ""
            },
            name: {
              mandatory: true,
              check: String
            },
            text: {
              check: String
            }
          });
        }
      },
      key_value: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      rows: {
        mandatory: true,
        "default": [],
        check: function(v) {
          return CUI.isArray(v);
        }
      },
      flex: {
        "default": false,
        check: Boolean
      },
      size: {
        mandatory: true,
        "default": "normal",
        check: ["normal", "mini"]
      }
    });
  };

  Table.prototype.readOpts = function() {
    var col, i, len, ref;
    Table.__super__.readOpts.call(this);
    if (this._key_value) {
      assert(!this._columns && !this.opts.hasOwnProperty("header"), "new Table", "opts.key_value cannot be set together with opts.header or opts.columns.", {
        opts: this.opts
      });
      this._header = false;
      this.__columns = [
        {
          name: "key"
        }, {
          name: "value"
        }
      ];
    } else {
      this.__columns = copyObject(this._columns, true);
    }
    ref = this.__columns;
    for (i = 0, len = ref.length; i < len; i++) {
      col = ref[i];
      if (col.name) {
        col.__class = " cui-td--" + col.name;
      } else {
        col.__class = "";
      }
      if (!isEmpty(col["class"])) {
        col.__class += " " + col["class"];
      }
    }
    return this;
  };

  Table.prototype.addRow = function(row) {
    var col, i, len, ref, td, tr, value;
    tr = $tr("cui-table-row");
    ref = this.__columns;
    for (i = 0, len = ref.length; i < len; i++) {
      col = ref[i];
      td = $td("cui-table-td" + col.__class);
      value = row[col.name];
      if (isString(value)) {
        CUI.DOM.addClass(td, "cui-td--text-content");
        td.textContent = value;
      } else {
        CUI.DOM.append(td, value);
      }
      tr.appendChild(td);
    }
    this.__table.appendChild(tr);
    return this;
  };

  Table.keyValueRowsFromMap = function(map) {
    var k, results, v;
    results = [];
    for (k in map) {
      v = map[k];
      results.push({
        key: k,
        value: v
      });
    }
    return results;
  };

  return Table;

})(CUI.DOM);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowser = (function(superClass) {
  extend(DocumentBrowser, superClass);

  function DocumentBrowser() {
    return DocumentBrowser.__super__.constructor.apply(this, arguments);
  }

  DocumentBrowser.prototype.initOpts = function() {
    DocumentBrowser.__super__.initOpts.call(this);
    return this.addOpts({
      gotoLocation: {
        check: Function,
        "default": (function(_this) {
          return function(nodePath, search, nodeIdx) {
            return _this.loadLocation(nodePath, search, nodeIdx);
          };
        })(this)
      },
      marked_opts: {
        "default": {},
        mandatory: true,
        check: function(v) {
          var _k, _v;
          if (!CUI.isPlainObject(v)) {
            return false;
          }
          for (_k in v) {
            _v = v[_k];
            if (_k === "image" || _k === "link") {
              return false;
            }
          }
          return true;
        }
      },
      getMarkdown: {
        "default": function(v) {
          return v;
        },
        check: Function
      },
      renderHref: {
        check: Function,
        "default": (function(_this) {
          return function(href, nodePath) {
            return href;
          };
        })(this)
      },
      url: {
        check: function(v) {
          return !!CUI.parseLocation(v);
        }
      }
    });
  };

  DocumentBrowser.prototype.readOpts = function() {
    var k, ref, renderer, v;
    DocumentBrowser.__super__.readOpts.call(this, this.opts);
    this.__marked_opts = copyObject(this._marked_opts);
    if (!this.__marked_opts.renderer) {
      this.__marked_opts.renderer = new marked.Renderer();
    }
    renderer = this.__marked_opts.renderer;
    ref = {
      sanitize: false
    };
    for (k in ref) {
      v = ref[k];
      if (!this.__marked_opts.hasOwnProperty(k)) {
        this.__marked_opts[k] = v;
      }
    }
    renderer.image = (function(_this) {
      return function(href, title, text) {
        return _this.__node.rendererImage(href, title, text);
      };
    })(this);
    renderer.link = (function(_this) {
      return function(href, title, text) {
        return _this.__node.rendererLink(href, title, text);
      };
    })(this);
    return this.__words = {};
  };

  DocumentBrowser.prototype.renderHref = function(href, nodePath) {
    return this._renderHref(href, nodePath);
  };

  DocumentBrowser.prototype.marked = function(__node, markdown) {
    var dfr, mark, ret;
    this.__node = __node;
    dfr = new CUI.Deferred();
    mark = (function(_this) {
      return function(markdown) {
        return dfr.resolve(marked(markdown, _this.__marked_opts));
      };
    })(this);
    ret = this._getMarkdown(markdown);
    if (isPromise(ret)) {
      ret.done((function(_this) {
        return function(markdown) {
          return mark(markdown);
        };
      })(this)).fail(dfr.reject);
    } else {
      mark(ret);
    }
    return dfr.promise();
  };

  DocumentBrowser.prototype.loadLocation = function(nodePath, search, _nodeIdx) {
    if (!nodePath) {
      if (!this.__tree.root.children.length) {
        return;
      }
      return this.loadLocation(this.__tree.root.children[0].getNodePath());
    }
    return this.__tree.root.selectLocation(nodePath).done((function(_this) {
      return function(node) {
        var nodeIdx;
        nodeIdx = parseInt(_nodeIdx);
        if (!node.isSelected()) {
          node.select({
            search: search,
            nodeIdx: nodeIdx
          });
        }
        return _this.loadContent(node, search, nodeIdx);
      };
    })(this)).fail((function(_this) {
      return function() {
        return _this.loadEmpty();
      };
    })(this));
  };

  DocumentBrowser.prototype.loadEmpty = function() {
    return this.__layout.replace(new EmptyLabel({
      text: "No article available."
    }), "center");
  };

  DocumentBrowser.prototype.loadContent = function(node, search, nodeIdx) {
    return node.loadContent().done((function(_this) {
      return function(content, htmlNodes, texts) {
        var _node, html, i, len, nodes, scroll_node, searchQuery, text_matches, text_node_idx, tm;
        if (!search) {
          _this.__layout.replace(htmlNodes, "center");
          return;
        }
        scroll_node = null;
        searchQuery = new CUI.DocumentBrowser.SearchQuery({
          search: search
        });
        nodes = CUI.DOM.htmlToNodes(_this.marked(node, content));
        text_matches = [];
        text_node_idx = 0;
        CUI.DOM.findTextInNodes(nodes, function(node, textContent) {
          var text_match;
          text_node_idx = text_node_idx + 1;
          text_match = searchQuery.match(textContent);
          if (!text_match) {
            return;
          }
          console.debug("matches", searchQuery, textContent);
          text_match.__mark_all = nodeIdx === text_node_idx - 1;
          text_match.__node = node;
          return text_matches.push(text_match);
        });
        console.debug("text matches", text_matches);
        for (i = 0, len = text_matches.length; i < len; i++) {
          tm = text_matches[i];
          html = tm.getHighlighted();
          if (tm.__mark_all) {
            html = "<span class='cui-document-browser-marked-node'>" + html + "</span>";
          }
          _node = CUI.DOM.replaceWith(tm.__node, CUI.DOM.htmlToNodes(html));
          if (tm.__mark_all) {
            scroll_node = _node;
          }
        }
        _this.__layout.replace(nodes, "center");
        _this.__layout.prepend(node.getMainArticleUrl(), "center");
        if (scroll_node) {
          return CUI.DOM.scrollIntoView(scroll_node);
        } else {
          return _this.__layout.center().scrollTop = 0;
        }
      };
    })(this)).fail((function(_this) {
      return function() {
        return _this.loadEmpty();
      };
    })(this));
  };

  DocumentBrowser.prototype.getRootNode = function() {
    return this.__tree.root;
  };

  DocumentBrowser.prototype.__doSearch = function(search) {
    var i, len, match, matches;
    this.__searchResult.empty("center");
    if (search.trim().length > 2) {
      matches = this.__tree.root.findContent(new CUI.DocumentBrowser.SearchQuery({
        search: search
      }));
      for (i = 0, len = matches.length; i < len; i++) {
        match = matches[i];
        this.__searchResult.append(match.render(), "center");
      }
      if (matches.length === 0) {
        this.__searchResult.append(new Label({
          markdown: true,
          text: "Nothing found for **" + search + "**.",
          multiline: true
        }), "center");
      }
      return this.showSearch(true);
    } else {
      matches = [];
      return this.showSearch(false);
    }
  };

  DocumentBrowser.prototype.addWords = function(texts) {
    var _word, i, j, len, len1, ref, text, word;
    return;
    for (i = 0, len = texts.length; i < len; i++) {
      text = texts[i];
      ref = text.split(/(\s+)/);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        _word = ref[j];
        word = _word.replace(/[\^\$\"\.,\-\(\)\s\t]/g, "");
        if (word.length === 0) {
          continue;
        }
        if (!this.__words.hasOwnProperty(word)) {
          this.__words[word] = 1;
        } else {
          this.__words[word] += 1;
        }
      }
    }
    return this;
  };

  DocumentBrowser.prototype.showSearch = function(on_off) {
    if (on_off) {
      this.__resetBtn.show();
      this.__searchBtn.hide();
      CUI.DOM.remove(this.__tree.DOM);
      return this.__leftLayout.replace(this.__searchResult, "content");
    } else {
      this.__resetBtn.hide();
      this.__searchBtn.show();
      CUI.DOM.remove(this.__searchResult.DOM);
      return this.__leftLayout.replace(this.__tree.DOM, "content");
    }
  };

  DocumentBrowser.prototype.render = function() {
    var data, do_search, search_input;
    data = {
      search: ""
    };
    do_search = (function(_this) {
      return function() {
        return _this.__doSearch(data.search);
      };
    })(this);
    search_input = new Input({
      data: data,
      name: "search",
      onDataChanged: (function(_this) {
        return function() {
          return CUI.scheduleCallback({
            ms: 200,
            call: do_search
          });
        };
      })(this)
    });
    this.__searchResult = new VerticalList();
    this.__tree = new ListViewTree({
      cols: ["maximize"],
      selectable: true,
      onSelect: (function(_this) {
        return function(ev, info) {
          if (ev != null ? ev.search : void 0) {
            return _this._gotoLocation(info.node.getNodePath(), ev.search, ev.nodeIdx);
          } else {
            return _this._gotoLocation(info.node.getNodePath());
          }
        };
      })(this),
      onDeselect: (function(_this) {
        return function(ev, info) {};
      })(this),
      root: new CUI.DocumentBrowser.RootNode({
        browser: this,
        url: this._url
      })
    });
    this.__leftLayout = new SimplePane({
      header_center: search_input.start(),
      header_right: [
        this.__searchBtn = new Button({
          icon: "search",
          onClick: (function(_this) {
            return function() {
              return _this.showSearch(true);
            };
          })(this)
        }), this.__resetBtn = new Button({
          icon: "remove",
          hidden: true,
          onClick: (function(_this) {
            return function() {
              return _this.showSearch(false);
            };
          })(this)
        })
      ],
      content: this.__tree.render(false)
    });
    this.__layout = new HorizontalLayout({
      "class": "cui-document-browser",
      maximize: true,
      left: {
        "class": "cui-document-browser-list",
        content: this.__leftLayout,
        flexHandle: {
          hidden: false
        }
      },
      center: {
        "class": "cui-document-browser-center",
        content: $text(this._url)
      }
    });
    return this.__layout;
  };

  DocumentBrowser.prototype.load = function() {
    return this.__tree.root.open().done((function(_this) {
      return function() {
        var count, ref, word;
        _this.__all_words = [];
        ref = _this.__words;
        for (word in ref) {
          count = ref[word];
          _this.__all_words.push({
            word: word,
            count: count,
            sorted: word.toLocaleLowerCase().split("").sort(function(a, b) {
              return compareIndex(a, b);
            }).join("")
          });
        }
        _this.__all_words.sort(function(a, b) {
          return b.count - a.count;
        });
        return console.debug("words", _this.__words, _this.__all_words);
      };
    })(this));
  };

  return DocumentBrowser;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.DocumentBrowser.Node = (function(superClass) {
  extend(Node, superClass);

  function Node() {
    return Node.__super__.constructor.apply(this, arguments);
  }

  Node.prototype.readOpts = function() {
    Node.__super__.readOpts.call(this);
    this.__url = this._url;
    if (this.__url.endsWith("/")) {
      return this.__url = this.__url.substr(0, this.__url.length - 1);
    }
  };

  Node.prototype.initOpts = function() {
    Node.__super__.initOpts.call(this);
    return this.addOpts({
      browser: {
        mandatory: true,
        check: CUI.DocumentBrowser
      },
      url: {
        check: function(v) {
          return !!CUI.parseLocation(v);
        }
      },
      path: {
        "default": [],
        check: Array
      },
      title: {
        check: String
      }
    });
  };

  Node.prototype.getChildren = function() {
    if (this.opts.leaf) {
      return [];
    }
    if (this.children) {
      return new CUI.resolvedPromise(this.children);
    } else {
      return this.__loadChildren();
    }
  };

  Node.prototype.__loadChildren = function(dive) {
    var dfr, xhr;
    if (dive == null) {
      dive = true;
    }
    this.loadContent();
    dive = true;
    dfr = new CUI.Deferred();
    xhr = new CUI.XHR({
      url: this.__url + this.getNodePath("menu.cms"),
      responseType: "text"
    });
    xhr.start().done((function(_this) {
      return function(data) {
        var child, children, children_done, i, idx, info, item, items, j, len, len1, m, path, ref, row, title;
        if (data.startsWith("<")) {
          _this.opts.leaf = true;
          dfr.resolve([]);
          return;
        }
        children = [];
        items = [];
        ref = data.split("\n");
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          m = row.match(/^\s*(\S+?)(|=(\S+))\s*$/);
          if (!m) {
            continue;
          }
          info = m[1].split(":");
          if (m[3]) {
            title = m[3];
          } else {
            title = info[0];
          }
          path = _this._path.slice(0);
          path.push(info[0]);
          items.push({
            title: title,
            path: path
          });
        }
        if (items.length === 0) {
          _this.opts.leaf = true;
          dfr.resolve([]);
          return;
        }
        children_done = 0;
        for (idx = j = 0, len1 = items.length; j < len1; idx = ++j) {
          item = items[idx];
          child = new CUI.DocumentBrowser.Node({
            browser: _this._browser,
            url: _this.__url,
            title: item.title,
            path: item.path
          });
          children.push(child);
          if (dive) {
            child.__loadChildren(false).always(function() {
              children_done = children_done + 1;
              if (children_done === items.length) {
                _this.children = children;
                return dfr.resolve(children);
              }
            });
          }
        }
        if (!dive) {
          dfr.resolve(children);
        }
      };
    })(this)).fail((function(_this) {
      return function() {
        _this.opts.leaf = true;
        return dfr.resolve([]);
      };
    })(this));
    return dfr.promise();
  };

  Node.prototype.getMainArticleUrl = function() {
    return this.__url + this.getNodePath(this.getLastPathElement() + ".md");
  };

  Node.prototype.loadIncludes = function(content, nodePath, includes) {
    var dfr, load_next_include, new_includes;
    if (includes == null) {
      includes = [];
    }
    dfr = new CUI.Deferred();
    new_includes = includes.slice(0);
    load_next_include = (function(_this) {
      return function() {
        var match, replace_in_content, url;
        match = content.match(/@@include\(\s*(.*?)\s*\)/);
        if (!match) {
          dfr.resolve(content);
          return;
        }
        url = _this.absoluteUrl(nodePath, match[1]);
        replace_in_content = function(replace_content) {
          var arr;
          arr = [content.substr(0, match.index), content.substr(match.index + match[0].length)];
          arr.splice(1, 0, replace_content);
          content = arr.join("");
          return load_next_include();
        };
        if (indexOf.call(includes, url) >= 0) {
          replace_in_content("**(Recursion: " + match[1] + ")**");
        } else {
          new_includes.push(url);
          new CUI.XHR({
            url: _this.__url + url,
            responseType: "text"
          }).start().done(function(include_content) {
            var parts;
            parts = url.split("/");
            parts.pop();
            return _this.loadIncludes(include_content, parts.join("/"), new_includes).done(function(_content) {
              return replace_in_content(_content);
            });
          }).fail(function() {
            return replace_in_content("**(Error: " + match[1] + ")**");
          });
        }
      };
    })(this);
    load_next_include();
    return dfr.promise();
  };

  Node.prototype.loadContent = function() {
    var dfr;
    if (this.__content) {
      new CUI.resolvedPromise(this.__content, this.__htmlNodes, this.__texts);
    }
    dfr = new CUI.Deferred();
    new CUI.XHR({
      url: this.getMainArticleUrl(),
      responseType: "text"
    }).start().done((function(_this) {
      return function(__content) {
        _this.__content = __content;
        if (_this.__content.startsWith("<")) {
          dfr.reject();
          return;
        }
        return _this.loadIncludes(_this.__content, _this.getNodePath()).fail(dfr.reject).done(function(content) {
          return _this._browser.marked(_this, content).done(function(content) {
            _this.__htmlNodes = CUI.DOM.htmlToNodes(content);
            _this.__texts = CUI.DOM.findTextInNodes(_this.__htmlNodes);
            _this._browser.addWords(_this.__texts);
            return dfr.resolve(_this.__content, _this.__htmlNodes, _this.__texts);
          });
        }).fail(dfr.reject);
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  Node.prototype.findContent = function(searchQuery, matches) {
    var c, i, idx, idx_hits, j, k, len, len1, ref, ref1, ref2, regExpe, remove_matched_part, results, text, text_match, text_matches, title_match;
    if (matches == null) {
      matches = [];
    }
    assert(searchQuery instanceof CUI.DocumentBrowser.SearchQuery, "DocumentBrowserNode.findContent", "searchQuery needs to be instance of CUI.DocumentBrowser.SearchQuery.", {
      searchQuery: searchQuery
    });
    regExpe = searchQuery.getRegExps();
    idx_hits = (function() {
      results = [];
      for (var i = 0, ref = regExpe.length - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this);
    remove_matched_part = (function(_this) {
      return function(match) {
        var _match, j, len, ref1;
        if (idx_hits.length === 0) {
          return;
        }
        ref1 = match.getMatches();
        for (j = 0, len = ref1.length; j < len; j++) {
          _match = ref1[j];
          removeFromArray(_match.regExp_idx, idx_hits);
          if (idx_hits.length === 0) {
            return;
          }
        }
      };
    })(this);
    title_match = searchQuery.match(this._title);
    if (title_match) {
      remove_matched_part(title_match);
    }
    text_matches = [];
    if (this.__texts) {
      ref1 = this.__texts;
      for (idx = j = 0, len = ref1.length; j < len; idx = ++j) {
        text = ref1[idx];
        text_match = searchQuery.match(text);
        if (!text_match) {
          continue;
        }
        text_match.nodeIdx = idx;
        text_matches.push(text_match);
        remove_matched_part(text_match);
      }
    }
    if (idx_hits.length === 0) {
      matches.push(new CUI.DocumentBrowser.NodeMatch({
        node: this,
        searchQuery: searchQuery,
        title_match: title_match,
        text_matches: text_matches
      }));
    }
    if (this.children) {
      ref2 = this.children;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        c = ref2[k];
        c.findContent(searchQuery, matches);
      }
    }
    return matches;
  };

  Node.prototype.getBrowser = function() {
    return this._browser;
  };

  Node.prototype.selectLocation = function(nodePath, dfr) {
    var select_child;
    if (dfr == null) {
      dfr = new CUI.Deferred();
    }
    if (nodePath === this.getNodePath()) {
      dfr.resolve(this);
      return;
    }
    select_child = (function(_this) {
      return function() {
        var c, i, len, ref;
        if (_this.opts.leaf) {
          dfr.fail(_this);
        }
        ref = _this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (nodePath.startsWith(c.getNodePath() + "/") || nodePath === c.getNodePath()) {
            c.selectLocation(nodePath, dfr);
            return;
          }
        }
        console.error("Unable to find:", nodePath, "in", _this.getNodePath());
        return dfr.fail();
      };
    })(this);
    if (this.children) {
      select_child();
    } else {
      this.open().always((function(_this) {
        return function() {
          return select_child();
        };
      })(this));
    }
    return dfr;
  };

  Node.prototype.getLastPathElement = function() {
    return this._path[this._path.length - 1];
  };

  Node.prototype.getNodePath = function(filename) {
    var nodePath;
    nodePath = "/" + this._path.join("/");
    if (!filename) {
      return nodePath;
    } else if (nodePath === "/") {
      return nodePath + filename;
    } else {
      return nodePath + "/" + filename;
    }
  };

  Node.prototype.getTitlePath = function() {
    var i, len, node, ref, texts;
    texts = [];
    ref = this.getPath(true);
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      if (node.isRoot()) {
        continue;
      }
      texts.push(node.getTitle());
    }
    return texts;
  };

  Node.prototype.getTitle = function() {
    return this._title;
  };

  Node.prototype.absoluteUrl = function(base, relative) {
    var i, len, part, parts, stack;
    stack = base.split("/");
    parts = relative.split("/");
    for (i = 0, len = parts.length; i < len; i++) {
      part = parts[i];
      if (part === ".") {
        continue;
      }
      if (part === "..") {
        stack.pop();
      } else {
        stack.push(part);
      }
    }
    return stack.join("/");
  };

  Node.prototype.rendererLink = function(href, title, text) {
    title = href;
    href = this._browser.renderHref(href, this.getNodePath());
    return "<a href='" + href + "' title='" + CUI.escapeAttribute(title) + "'>" + text + "</a>";
  };

  Node.prototype.rendererImage = function(href, title, text) {
    var _href, url;
    if (href.startsWith("http:") || href.startsWith("//")) {
      url = null;
    } else if (href.startsWith("/")) {
      url = this.__url;
    } else {
      url = this.__url + this.getNodePath();
    }
    if (url !== null) {
      _href = this.absoluteUrl(url, href);
    } else {
      _href = href;
    }
    return "<img src='" + _href + "' alt='" + CUI.escapeAttribute(text) + "' title='" + CUI.escapeAttribute(title) + "'></img>";
  };

  Node.prototype.renderContent = function() {
    return new Label({
      text: this._title,
      multiline: true
    });
  };

  return Node;

})(CUI.ListViewTreeNode);

CUI.DocumentBrowser.RootNode = (function(superClass) {
  extend(RootNode, superClass);

  function RootNode() {
    return RootNode.__super__.constructor.apply(this, arguments);
  }

  return RootNode;

})(CUI.DocumentBrowser.Node);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowser.NodeMatch = (function(superClass) {
  extend(NodeMatch, superClass);

  function NodeMatch() {
    return NodeMatch.__super__.constructor.apply(this, arguments);
  }

  NodeMatch.prototype.initOpts = function() {
    NodeMatch.__super__.initOpts.call(this);
    return this.addOpts({
      title_match: {
        check: CUI.DocumentBrowser.SearchMatch
      },
      text_matches: {
        check: function(v) {
          var i, item, len;
          for (i = 0, len = v.length; i < len; i++) {
            item = v[i];
            if (!(item instanceof CUI.DocumentBrowser.SearchMatch)) {
              return false;
            }
          }
          return true;
        }
      },
      searchQuery: {
        check: CUI.DocumentBrowser.SearchQuery
      },
      node: {
        check: CUI.DocumentBrowser.Node
      }
    });
  };

  NodeMatch.prototype.marked = function(markdown) {
    return this._node.getBrowser().marked(this._node, markdown);
  };

  NodeMatch.prototype.render = function() {
    var arr, fn, html, i, j, lbl, len, len1, li, part, ref, ref1, text_match, titlePath, ul;
    titlePath = [];
    ref = this._node.getTitlePath();
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      titlePath.push(toHtml(part));
    }
    if (this._title_match) {
      titlePath[titlePath.length - 1] = this._title_match.getHighlighted();
    }
    lbl = new Label({
      "class": "cui-document-browser-search-match--title",
      multiline: true,
      content: CUI.DOM.htmlToNodes(titlePath.join("<span class='cui-document-browser-node-match-hierarchy'>" + new Icon({
        icon: "right"
      }).DOM.outerHTML + "</span>"))
    });
    CUI.DOM.setAttribute(lbl.DOM, "tabindex", 0);
    Events.listen({
      type: "focus",
      node: lbl,
      call: (function(_this) {
        return function(ev) {
          _this._node.select({
            search: _this._searchQuery.getSearch()
          });
        };
      })(this)
    });
    arr = [lbl];
    if (this._text_matches) {
      ul = CUI.DOM.element("UL");
      arr.push(ul);
      ref1 = this._text_matches;
      fn = (function(_this) {
        return function(text_match) {
          return Events.listen({
            type: "focus",
            node: li,
            call: function(ev) {
              _this._node.select({
                search: _this._searchQuery.getSearch(),
                nodeIdx: text_match.nodeIdx
              });
            }
          });
        };
      })(this);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        text_match = ref1[j];
        html = text_match.getHighlighted(true);
        li = CUI.DOM.element("LI", {
          title: text_match.getString(),
          tabindex: 0
        });
        fn(text_match);
        CUI.DOM.append(li, CUI.DOM.htmlToNodes(html));
        ul.appendChild(li);
      }
    }
    return arr;
  };

  return NodeMatch;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowser.SearchMatch = (function(superClass) {
  extend(SearchMatch, superClass);

  function SearchMatch() {
    return SearchMatch.__super__.constructor.apply(this, arguments);
  }

  SearchMatch.prototype.initOpts = function() {
    SearchMatch.__super__.initOpts.call(this);
    return this.addOpts({
      searchQuery: {
        mandatory: true,
        check: CUI.DocumentBrowser.SearchQuery
      },
      string: {
        mandator: true,
        check: String
      }
    });
  };

  SearchMatch.prototype.readOpts = function() {
    SearchMatch.__super__.readOpts.call(this);
    return this.__matches = [];
  };

  SearchMatch.prototype.addMatch = function(match) {
    return this.__matches.push(match);
  };

  SearchMatch.prototype.getMatches = function() {
    return this.__matches;
  };

  SearchMatch.prototype.getString = function() {
    return this._string;
  };

  SearchMatch.prototype.getHighlighted = function(shrink_long) {
    var char_id, char_id_curr, char_id_prev, chars, i, idx, j, len, m, m_idx, ref, ref1, ref2, shrink, splits, str, txt_chars;
    if (shrink_long == null) {
      shrink_long = false;
    }
    str = this._string;
    char_id = (function(_this) {
      return function(char) {
        if (char === void 0) {
          return null;
        } else {
          return char.join(".");
        }
      };
    })(this);
    shrink = (function(_this) {
      return function(text) {
        var parts;
        parts = text.split(/\s+/);
        if (parts.length > 6) {
          parts.splice(3, parts.length - 6, "...");
        }
        return parts.join(" ");
      };
    })(this);
    chars = [];
    chars.length = str.length;
    ref = this.__matches;
    for (m_idx = i = 0, len = ref.length; i < len; m_idx = ++i) {
      m = ref[m_idx];
      for (idx = j = ref1 = m.index, ref2 = m.index + m[0].length; ref1 <= ref2 ? j < ref2 : j > ref2; idx = ref1 <= ref2 ? ++j : --j) {
        if (!chars[idx]) {
          chars[idx] = [];
        }
        chars[idx].push(m.regExp_idx);
      }
    }
    splits = [];
    idx = 0;
    while (idx < chars.length) {
      char_id_prev = char_id(chars[idx - 1]);
      char_id_curr = char_id(chars[idx]);
      if (char_id_prev && char_id_curr !== char_id_prev) {
        splits.push("</span>");
      }
      if (char_id_curr && char_id_curr !== char_id_prev) {
        splits.push("<span class=\"cui-document-browser-search-match-mark cui-search-match--" + chars[idx].join(" cui-search-match--") + "\">");
      }
      txt_chars = [];
      while (true) {
        txt_chars.push(str[idx]);
        idx = idx + 1;
        if (idx === chars.length || chars[idx] || char_id_curr) {
          break;
        }
      }
      splits.push(toHtml(shrink(txt_chars.join(""))));
    }
    if (char_id_curr) {
      splits.push("</span>");
    }
    return splits.join("");
  };

  return SearchMatch;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowser.SearchQuery = (function(superClass) {
  extend(SearchQuery, superClass);

  function SearchQuery() {
    return SearchQuery.__super__.constructor.apply(this, arguments);
  }

  SearchQuery.prototype.initOpts = function() {
    SearchQuery.__super__.initOpts.call(this);
    return this.addOpts({
      search: {
        mandatory: true,
        check: String
      }
    });
  };

  SearchQuery.prototype.readOpts = function() {
    var i, len, ref, str;
    SearchQuery.__super__.readOpts.call(this);
    this.__regExpe = [];
    ref = this._search.trim().split(/\s+/);
    for (i = 0, len = ref.length; i < len; i++) {
      str = ref[i];
      if (str.trim() === "") {
        continue;
      }
      this.__regExpe.push(new RegExp(RegExp.escape(str), "ig"));
    }
  };

  SearchQuery.prototype.getRegExps = function() {
    return this.__regExpe;
  };

  SearchQuery.prototype.getSearch = function() {
    return this._search;
  };

  SearchQuery.prototype.match = function(str, strip) {
    var i, idx, j, len, len1, match, matches, ref, regExp, search_match;
    search_match = null;
    if (isEmpty(str)) {
      return search_match;
    }
    ref = this.__regExpe;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      regExp = ref[idx];
      matches = [];
      while ((match = regExp.exec(str)) !== null) {
        matches.push(match);
      }
      if (matches.length > 0) {
        if (!search_match) {
          search_match = new CUI.DocumentBrowser.SearchMatch({
            searchQuery: this,
            string: str
          });
        }
        for (j = 0, len1 = matches.length; j < len1; j++) {
          match = matches[j];
          match.regExp_idx = idx;
          search_match.addMatch(match);
        }
      }
    }
    return search_match;
  };

  return SearchQuery;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Slider = (function(superClass) {
  extend(Slider, superClass);

  function Slider() {
    return Slider.__super__.constructor.apply(this, arguments);
  }

  Slider.prototype.initOpts = function() {
    Slider.__super__.initOpts.call(this);
    return this.addOpts({
      value: {
        check: function(v) {
          return isInteger(v);
        }
      },
      min: {
        mandatory: true,
        "default": 0,
        check: function(v) {
          return isInteger(v);
        }
      },
      max: {
        mandatory: true,
        "default": 100,
        check: function(v) {
          return isInteger(v);
        }
      },
      onDragstart: {
        check: Function
      },
      onDragging: {
        check: Function
      },
      onDrop: {
        check: Function
      },
      onUpdate: {
        check: Function
      }
    });
  };

  Slider.prototype.readOpts = function() {
    Slider.__super__.readOpts.call(this);
    this.__distance = this._max - this._min;
    assert(this.__distance > 1, 'new Slider', 'opts.min and opts.max need to be at least 2 apart.');
    return this.__value = this.getDefaultValue();
  };

  Slider.prototype.getTemplate = function() {
    return this.__slider = new CUI.Template({
      name: "slider",
      map: {
        track: true,
        track_visual: true,
        handle: true
      }
    });
  };

  Slider.prototype.initDimensions = function() {
    this.__track_dim = CUI.DOM.getDimensions(this.__track);
    this.__handle_dim = CUI.DOM.getDimensions(this.__handle);
    return this.__track_available = {
      width: this.__track_dim.contentBoxWidth - (this.__handle_dim.borderBoxWidth / 2),
      height: this.__track_dim.contentBoxHeight - (this.__handle_dim.borderBoxHeight / 2)
    };
  };

  Slider.prototype.render = function() {
    Slider.__super__.render.call(this);
    this.__handle = this.__slider.map.handle;
    this.__track = this.__slider.map.track;
    new CUI.Draggable({
      element: this.__handle,
      helper: null,
      dragstart: (function(_this) {
        return function(ev, gd) {
          _this.initDimensions();
          _this.addClass('cui-slider--dragging');
          _this.__last_diff_x = 0;
          _this.__start_value = _this.__value;
          return typeof _this._onDragstart === "function" ? _this._onDragstart(_this, _this.__start_value) : void 0;
        };
      })(this),
      dragstop: (function(_this) {
        return function() {
          _this.setValue(_this.__start_value);
          _this.removeClass('cui-slider--dragging');
          return typeof _this._onDrop === "function" ? _this._onDrop(_this) : void 0;
        };
      })(this),
      dragend: (function(_this) {
        return function() {
          _this.removeClass('cui-slider--dragging');
          return typeof _this._onDrop === "function" ? _this._onDrop(_this) : void 0;
        };
      })(this),
      dragging: (function(_this) {
        return function(ev, gd) {
          var diff_x, precision, precision_factor, use_precision;
          diff_x = gd.dragDiff.bare_x - _this.__last_diff_x;
          _this.__last_diff_x = gd.dragDiff.bare_x;
          precision = _this.__track_available.width / _this.__distance;
          precision_factor = gd.dragDiff.bare_y / 5;
          if (precision_factor > 1) {
            use_precision = Math.min(1, precision * precision_factor);
          } else {
            use_precision = precision;
          }
          _this.setValue(_this.__value + (diff_x / use_precision));
          return typeof _this._onDragging === "function" ? _this._onDragging(_this, _this.getValue()) : void 0;
        };
      })(this)
    });
    return Events.listen({
      type: 'click',
      node: this.__slider.map.track_visual,
      call: (function(_this) {
        return function(ev) {
          var click_clientX, track_clientX;
          _this.initDimensions();
          track_clientX = _this.__track_dim.clientBoundingRect.left;
          click_clientX = ev.getNativeEvent().clientX;
          _this.setValue((click_clientX - track_clientX) / _this.__track_available.width * _this.__distance);
        };
      })(this)
    });
  };

  Slider.prototype.getValue = function() {
    if (this.hasData()) {
      return Slider.__super__.getValue.call(this);
    } else {
      return this.__value;
    }
  };

  Slider.prototype.getHandle = function() {
    return this.__slider.map.handle;
  };

  Slider.prototype.setValue = function(_v, flags) {
    var v;
    v = Math.round(Math.min(Math.max(this._min, _v), this._max));
    this.__value = v;
    Slider.__super__.setValue.call(this, this.__value, flags);
    return this;
  };

  Slider.prototype.getDefaultValue = function() {
    if (this._value === void 0) {
      return this._min;
    } else {
      return this._value;
    }
  };

  Slider.prototype.displayValue = function() {
    var percent;
    percent = this.getValue() / this._max * 100;
    CUI.DOM.setStyle(this.__handle, {
      left: percent + '%'
    });
    return typeof this._onUpdate === "function" ? this._onUpdate(this, this.getValue()) : void 0;
  };

  Slider.prototype.checkValue = function(v, flags) {
    if (v < this._min || v > this._max) {
      throw new CheckValueError('value needs to be between ' + this._min + ' and ' + this._max);
    }
    return this;
  };

  return Slider;

})(CUI.DataField);
// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.CSVData = (function(superClass) {
  extend(CSVData, superClass);

  function CSVData() {
    return CSVData.__super__.constructor.apply(this, arguments);
  }

  CSVData.prototype.initOpts = function() {
    CSVData.__super__.initOpts.call(this);
    return this.addOpts({
      rows: {
        check: function(v) {
          return CUI.isArray(v) && v.length > 0;
        }
      }
    });
  };

  CSVData.prototype.readOpts = function() {
    CSVData.__super__.readOpts.call(this);
    this.__max_column_count = 0;
    if (this._rows) {
      this.rows = this._rows;
    } else {
      this.rows = [];
    }
    this.giveAllRowsSameNumberOfColumns();
  };

  CSVData.prototype.giveAllRowsSameNumberOfColumns = function() {
    var col_count, i, idx, j, k, len1, len2, ref, ref1, ref2, ref3, row;
    this.__max_column_count = 0;
    ref = this.rows;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      row = ref[i];
      col_count = row.length;
      if (col_count > this.__max_column_count) {
        this.__max_column_count = col_count;
      }
    }
    ref1 = this.rows;
    for (j = 0, len2 = ref1.length; j < len2; j++) {
      row = ref1[j];
      if (row.length < this.__max_column_count) {
        for (idx = k = ref2 = row.length, ref3 = this.__max_column_count; ref2 <= ref3 ? k < ref3 : k > ref3; idx = ref2 <= ref3 ? ++k : --k) {
          row[idx] = null;
        }
      }
    }
  };

  CSVData.prototype.getMaxColumnCount = function() {
    return this.__max_column_count;
  };

  CSVData.prototype.getRows = function() {
    return this.rows;
  };

  CSVData.prototype.getRow = function(row_i) {
    return this.rows[row_i];
  };

  CSVData.prototype.getRowsCount = function() {
    return this.rows.length;
  };

  CSVData.prototype.debug = function() {
    return console.debug("rows:", this.rows);
  };

  CSVData.prototype.toText = function(_opts) {
    var _row, _rows, col, cr, i, idx, j, len1, len2, nl, opts, quote, ref, row, str;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "CSVData.toText", {
      delimiter: {
        mandatory: true,
        "default": ";",
        check: (function(_this) {
          return function(v) {
            return CUI.isString(v) && v.length > 0;
          };
        })(this)
      },
      quotechar: {
        mandatory: true,
        "default": '"',
        check: (function(_this) {
          return function(v) {
            return CUI.isString(v) && v.length > 0;
          };
        })(this)
      },
      always_quote: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      equal_columns: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      newline: {
        mandatory: true,
        "default": String.fromCharCode(10),
        check: (function(_this) {
          return function(v) {
            return CUI.isString(v) && v.length > 0;
          };
        })(this)
      }
    });
    if (opts.equal_columns) {
      this.giveAllRowsSameNumberOfColumns();
    }
    nl = String.fromCharCode(10);
    cr = String.fromCharCode(13);
    _rows = [];
    ref = this.rows;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      row = ref[i];
      _row = [];
      for (idx = j = 0, len2 = row.length; j < len2; idx = ++j) {
        col = row[idx];
        if (idx > 0) {
          _row.push(opts.delimiter);
        }
        if (isEmpty(col)) {
          str = "";
        } else {
          str = "" + col;
        }
        if (opts.always_quote) {
          quote = true;
        } else if (str.indexOf(opts.delimiter) > -1) {
          quote = true;
        } else if (str.indexOf(opts.quotechar) > -1) {
          quote = true;
        } else if (str.indexOf(nl) > -1) {
          quote = true;
        } else if (str.indexOf(cr) > -1) {
          quote = true;
        } else {
          quote = false;
        }
        if (quote) {
          _row.push(CUI.CSVData.quote(str, opts.quotechar));
        } else {
          _row.push(str);
        }
      }
      _rows.push(_row.join(""));
    }
    return _rows.join(opts.newline);
  };

  CSVData.prototype.parse = function(_opts) {
    var auto_delimiters, auto_quotechars, column_chars, column_idx, columns, delimiter, dfr, do_work, idx, in_quotes, len, lines, opts, quotechar, text;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "CSVData.parse", {
      text: {
        mandatory: true,
        check: String
      },
      delimiter: {
        check: String
      },
      quotechar: {
        check: String
      },
      defer: {
        mandatory: true,
        "default": true,
        check: Boolean
      }
    });
    this.rows = [];
    text = opts.text;
    columns = [];
    column_idx = 0;
    column_chars = [];
    len = text.length;
    idx = 0;
    in_quotes = false;
    lines = 0;
    auto_quotechars = ['"', "'"];
    auto_delimiters = [",", ";", "\t"];
    if (opts.delimiter !== void 0) {
      delimiter = opts.delimiter;
    } else {
      delimiter = null;
    }
    if (opts.quotechar !== void 0) {
      quotechar = opts.quotechar;
    } else {
      quotechar = null;
    }
    if (opts.defer) {
      dfr = new CUI.Deferred();
    }
    do_work = (function(_this) {
      return function() {
        var char, charCode, end_column, end_row, info, nextCharCode;
        end_column = function() {
          columns[column_idx] = column_chars.join("");
          column_chars.splice(0);
          return column_idx = column_idx + 1;
        };
        end_row = function() {
          if (columns.length > 0) {
            lines = lines + 1;
            _this.rows.push(columns);
            columns = [];
          }
          return column_idx = 0;
        };
        while (idx < len) {
          char = text.charAt(idx);
          if (quotechar === null && indexOf.call(auto_quotechars, char) >= 0) {
            quotechar = char;
          }
          if (delimiter === null && indexOf.call(auto_delimiters, char) >= 0) {
            delimiter = char;
          }
          if (char === quotechar) {
            if (in_quotes) {
              if (text[idx + 1] === quotechar) {
                column_chars.push(char);
                idx = idx + 2;
                continue;
              } else {
                in_quotes = false;
                idx = idx + 1;
                continue;
              }
            } else {
              in_quotes = true;
              idx = idx + 1;
              continue;
            }
          }
          if (char === delimiter) {
            if (in_quotes) {
              column_chars.push(char);
              idx = idx + 1;
              continue;
            } else {
              end_column();
              idx = idx + 1;
              continue;
            }
          }
          charCode = text.charCodeAt(idx);
          nextCharCode = text.charCodeAt(idx + 1);
          if (charCode === 13 || charCode === 10) {
            if (in_quotes) {
              column_chars.push(String.fromCharCode(10));
            } else {
              end_column();
              end_row();
              if (lines % 1000 === 0 && opts.defer) {
                dfr.notify({
                  row_count: lines,
                  file_read_idx: idx,
                  file_length: len
                });
                CUI.setTimeout({
                  ms: 10,
                  call: do_work
                });
                return;
              }
            }
            if (charCode === 13 && nextCharCode === 10) {
              idx = idx + 2;
            } else {
              idx = idx + 1;
            }
            continue;
          }
          column_chars.push(char);
          idx = idx + 1;
        }
        if (column_chars.length > 0) {
          end_column();
        }
        if (columns.length > 0) {
          end_row();
        }
        _this.giveAllRowsSameNumberOfColumns();
        info = {
          row_count: lines,
          file_length: len,
          rows: _this.rows
        };
        if (opts.defer) {
          return dfr.resolve(info);
        } else {
          return info;
        }
      };
    })(this);
    if (opts.defer) {
      CUI.setTimeout({
        ms: 0,
        call: do_work
      });
      dfr.done((function(_this) {
        return function() {
          return _this.debug();
        };
      })(this));
      return dfr.promise();
    } else {
      return do_work();
    }
  };

  CSVData.quote = function(str, quotechar) {
    if (quotechar == null) {
      quotechar = '"';
    }
    return quotechar + str.replace(new RegExp(escapeRegExp(quotechar), "g"), quotechar + quotechar) + quotechar;
  };

  return CSVData;

})(CUI.Element);
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
CUI.Test = (function() {
  function Test() {}

  Test.prototype.run = function() {
    return this.idx = 0;
  };

  Test.prototype.eq = function(a, b) {
    if (JSON.stringify(a) === JSON.stringify(b)) {
      CUI.info("Test passed: eq: ", a, b);
      return true;
    }
    return CUI.error("Test failed: eq: ", a, b, this.test_func.toString());
  };

  Test.prototype.test = function(test_func) {
    this.test_func = test_func;
    this.test_func();
    return this.idx++;
  };

  Test.tests = [];

  Test.register = function(test) {
    assert(test instanceof Test, "Test.register", "Test needs to be instance of Test", {
      test: test
    });
    test.idx = this.tests.length;
    return this.tests.push(test);
  };

  Test.run = function() {
    var i, len, ref, test;
    ref = this.tests;
    for (i = 0, len = ref.length; i < len; i++) {
      test = ref[i];
      CUI.info("Running Test", getObjectClass(test));
      test.run();
    }
  };

  return Test;

})();
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var Test_MoveInArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Test_MoveInArray = (function(superClass) {
  extend(Test_MoveInArray, superClass);

  function Test_MoveInArray() {
    return Test_MoveInArray.__super__.constructor.apply(this, arguments);
  }

  Test_MoveInArray.prototype.run = function() {
    Test_MoveInArray.__super__.run.call(this);
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 1, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 2, a);
        return _this.eq(a, [1, 0, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 3, a);
        return _this.eq(a, [1, 2, 0, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(1, 0, a);
        return _this.eq(a, [1, 0, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 5, a, true);
        return _this.eq(a, [1, 2, 3, 4, 5, 0]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 5, a);
        return _this.eq(a, [1, 2, 3, 4, 0, 5]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 6, a);
        return _this.eq(a, [1, 2, 3, 4, 5, 0]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(2, 3, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 3, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 3, a, true);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 1, a);
        return _this.eq(a, [0, 3, 1, 2, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(3, 4, a, true);
        return _this.eq(a, [0, 1, 2, 4, 3, 5]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 1, a, true);
        return _this.eq(a, [0, 1, 3, 2, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 3, a, true);
        return _this.eq(a, [1, 2, 3, 0, 4]);
      };
    })(this));
    return this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 4, a, true);
        return _this.eq(a, [1, 2, 3, 4, 0]);
      };
    })(this));
  };

  return Test_MoveInArray;

})(CUI.Test);

CUI.Test.register(new Test_MoveInArray());
// Generated by CoffeeScript 1.10.0

/*
 * coffeescript-ui - Coffeescript User Interface System (CUI)
 * Copyright (c) 2013 - 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/coffeescript-ui, http://www.coffeescript-ui.org
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Test_Promise = (function(superClass) {
  extend(Test_Promise, superClass);

  function Test_Promise() {
    return Test_Promise.__super__.constructor.apply(this, arguments);
  }

  Test_Promise.prototype.run = function() {
    var dfr, p;
    p = new Promise(function(resolve, reject) {
      return CUI.setTimeout({
        call: (function(_this) {
          return function() {
            p.then(function(v1) {
              console.debug("hello2", v1);
              p.then(function(v1) {
                return console.debug("hello3", v1);
              });
              return console.debug("hello4", v1);
            });
            console.debug("resolve yo2");
            return resolve("yo2");
          };
        })(this)
      });
    });
    p.then((function(_this) {
      return function(v1) {
        return console.debug("hello1", v1);
      };
    })(this));
    dfr = new CUI.Deferred();
    dfr.done((function(_this) {
      return function(v1) {
        return console.debug("dfr1", v1);
      };
    })(this));
    dfr.done((function(_this) {
      return function(v1) {
        console.debug("dfr2", v1);
        dfr.done(function(v1) {
          return console.debug("dfr3", v1);
        });
        return console.debug("dfr4", v1);
      };
    })(this));
    dfr.resolve("yo3");
  };

  return Test_Promise;

})(CUI.Test);

CUI.Test.register(new CUI.Test_Promise());
